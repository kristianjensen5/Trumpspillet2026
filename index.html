<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Grønlandssatire – TrumpV2</title>
<style>
  html,body{margin:0;height:100%;background:#dff4ff;color:#111;font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  canvas{display:block;width:100%;height:100%;touch-action:none}
  .ui{
    position:fixed;left:12px;bottom:12px;z-index:10;
    background:rgba(0,0,0,.7);color:#fff;padding:12px 14px;border-radius:12px;font-size:13px;line-height:1.4;
    box-shadow:0 2px 8px rgba(0,0,0,.4);backdrop-filter:blur(4px);max-width:320px;
    display:flex;flex-direction:column;gap:10px;transition:background 0.2s ease,box-shadow 0.2s ease,padding 0.2s ease
  }
  .ui.collapsed{padding:10px 12px;gap:6px;background:rgba(0,0,0,.55);box-shadow:0 1px 3px rgba(0,0,0,.35)}
  .help-toggle{
    appearance:none;border:none;border-radius:999px;padding:6px 10px;background:rgba(255,255,255,.15);
    color:#fff;font:600 12px system-ui;letter-spacing:.02em;cursor:pointer;display:inline-flex;align-items:center;gap:6px;
    align-self:flex-start;box-shadow:inset 0 0 0 1px rgba(255,255,255,.15);
    transition:background 0.2s ease,transform 0.2s ease,box-shadow 0.2s ease
  }
  .help-toggle:hover,.help-toggle:focus{background:rgba(255,255,255,.25);box-shadow:inset 0 0 0 1px rgba(255,255,255,.35)}
  .help-toggle:focus{outline:none}
  .help-toggle:active{transform:scale(0.97)}
  .help-panel{display:flex;flex-direction:column;gap:6px}
  .ui.collapsed .help-panel{display:none}
  .ui kbd{background:rgba(255,255,255,.18);padding:0 .4em;border-radius:6px}
  .hud{
    position:fixed;right:16px;top:24px;z-index:10;display:flex;flex-direction:column;align-items:flex-end;gap:8px;
    color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.45)
  }
  .chip{display:flex;align-items:center;gap:6px;font-size:13px;font-weight:600;color:inherit}
  .chip canvas{display:block}
  .life-chip{font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,.55)}
  .inv{
    position:fixed;right:16px;top:200px;z-index:9;
    background:rgba(0,0,0,.72);color:#fff;border-radius:12px;padding:10px 8px;display:flex;flex-direction:column;gap:8px;align-items:center;
    max-height:min(70vh, 520px);overflow-y:auto;backdrop-filter:blur(4px);
    box-shadow:0 3px 10px rgba(0,0,0,.35)
  }
  .inv.hidden{display:none}
  .slot{
    width:70px;height:64px;border-radius:10px;background:rgba(255,255,255,.08);
    display:flex;flex-direction:column;align-items:center;justify-content:center;gap:4px;padding:6px 8px;
    box-sizing:border-box;overflow:hidden;flex-shrink:0;box-shadow:inset 0 0 0 1px rgba(255,255,255,.08)
  }
  .slot span{font-size:10px;opacity:.9;text-align:center;line-height:1.1;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#fff}
  .slot b{font-size:11px;text-align:center;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#fff}
  .slot b, .slot span{display:block;text-shadow:0 1px 1px rgba(0,0,0,.5)}
  .slot.empty{background:rgba(255,255,255,.05);border:1px dashed rgba(255,255,255,.28);box-shadow:none}
  .slot canvas{display:block;margin:0 auto;}
  .areas{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:10;display:flex;gap:8px;flex-wrap:wrap;justify-content:center;max-width:90vw}
  .pill{background:rgba(0,0,0,.7);color:#fff;border-radius:12px;padding:6px 12px;font-size:13px;font-weight:500;white-space:nowrap;box-shadow:0 2px 4px rgba(0,0,0,.3)}
  .hint-label{display:none;font-size:12px;opacity:.85}
  .ui.collapsed .hint-label{display:block}
  @media (prefers-reduced-motion: reduce){ * { animation: none !important; transition: none !important; } }
  @media (pointer: coarse){ .ui{font-size:12px} }
  
  /* 80s Retro Intro Screen */
  .intro-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
    /* Replaced purple gradient with warm cream background */
    background: #efe8d2;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    font-family: 'Courier New', monospace; color: #1a1a1a; text-align: center;
    animation: scanlines 2s linear infinite; padding: 20px; box-sizing: border-box;
    gap: 20px;
  }
  @keyframes scanlines {
    0% { background-position: 0 0; }
    100% { background-position: 0 4px; }
  }
  .intro-title {
    font-size: clamp(24px, 8vw, 48px); font-weight: 800; 
    color: #141414;
    text-shadow: 0 1px 0 rgba(255,255,255,0.5), 0 2px 4px rgba(0,0,0,0.2);
    letter-spacing: 1px; margin: 0;
    width: 100%; text-align: center;
  }
  .intro-subtitle {
    font-size: clamp(14px, 4vw, 20px); color: #2a2a2a; 
    text-shadow: 0 1px 0 rgba(255,255,255,0.4);
    opacity: 0.95;
    max-width: 90%; line-height: 1.5; margin: 0;
    width: 100%; text-align: center;
  }
  .intro-prompt {
    font-size: clamp(14px, 3vw, 18px); color: #1f1f1f; 
    text-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 2px 3px rgba(0,0,0,0.2);
    animation: blinkGlow 1.2s ease-in-out infinite; margin: 0;
    width: 100%; text-align: center; font-weight: 700;
    letter-spacing: 1px;
  }
  @keyframes blinkGlow {
    0%, 40% { 
      opacity: 1; 
      text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #ff00ff, 0 0 20px #ff00ff;
      transform: scale(1);
    }
    50%, 90% { 
      opacity: 0.4; 
      text-shadow: 0 0 2px #ff00ff, 0 0 5px #ff00ff;
      transform: scale(0.98);
    }
    100% { 
      opacity: 1; 
      text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #ff00ff, 0 0 20px #ff00ff;
      transform: scale(1);
    }
  }
  .intro-button {
    appearance: none; border: 2px solid #2b2b2b; background: rgba(0,0,0,.06);
    color: #1e1e1e; font-family: 'Courier New', monospace; font-weight: 800;
    padding: 10px 18px; border-radius: 10px; cursor: pointer;
    text-shadow: 0 1px 0 rgba(255,255,255,0.5);
    box-shadow: 0 0 0 0 rgba(0,0,0,0);
    transition: transform .08s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease;
  }
  .intro-button:hover { background: rgba(0,0,0,.1); border-color:#1e1e1e; }
  .intro-button:focus { outline: none; box-shadow: 0 0 0 3px rgba(0,0,0,.12); }
  .intro-button:active { transform: scale(0.98); background: rgba(0,0,0,.15); }

  /* Override the intro canvas border to match darker UI */
  #intro-canvas { border-color: #3a3a3a !important; }
</style>

<!-- ==================== DATA DEFINITIONS ==================== -->
<script id="game-config" type="application/json">
  
{
  "CFG": {
    "NON_VIOLENT": false,
    "SPEED": 210,
    "INTERACT_DIST": 48,
    "BUBBLE_TIME": 2000,
    "SCALE": 1,
    "SHOW_PULSE": false,
    "DEBUG": false,
    "SHOW_FPS": false
  },
  "GAME_CONSTANTS": {
    "CHAR": {
      "WIDTH": 24,
      "HEIGHT": 44,
      "BEAR_WIDTH": 70,
      "BEAR_HEIGHT": 40
    },
    "UI": {
      "BUBBLE_FONT_SIZE": 12,
      "BUBBLE_LINE_HEIGHT": 16,
      "BUBBLE_PADDING": 8,
      "BUBBLE_TAIL_OFFSET": 18,
      "BUBBLE_Y_OFFSET": 46,
      "BUBBLE_TAIL_Y": 30,
      "PULSE_DISTANCE": 110,
      "INTERACTION_FEEDBACK_SIZE": 3,
      "CLICK_DISTANCE": 100,
      "BUBBLE_PALETTES": {
        "trump":   { "fill": "rgba(255,165,0,.85)", "stroke": "rgba(60,40,0,.9)", "text": "#111", "tail": "#ffbf47" },
        "mette":   { "fill": "rgba(40,80,120,.85)", "stroke": "rgba(180,210,240,.9)", "text": "#fff", "tail": "rgba(40,80,120,.85)" },
        "bear":    { "fill": "rgba(240,240,240,.85)", "stroke": "rgba(50,50,50,.7)", "text": "#111", "tail": "rgba(240,240,240,.85)" },
        "aide":    { "fill": "rgba(40,80,140,.85)", "stroke": "rgba(220,230,255,.9)", "text": "#fff", "tail": "rgba(40,80,140,.85)" },
        "default": { "fill": "rgba(0,0,0,.7)", "stroke": "rgba(255,255,255,.85)", "text": "#fff", "tail": "rgba(0,0,0,.7)" }
      }
    },
    "WORLD": {
      "FLOOR_HEIGHT": 120,
      "PLAYER_START_X": 160,
      "HELI_Y_OFFSET": 18,
      "GREENLAND": {
        "MINE_X": 520,
        "RIG_X": 380,
        "HELI_X": 160,
        "BEAR_X": 760,
        "METTE_X": 980
      },
      "OVAL": {
        "DOOR_X": 160,
        "AIDE_X": 380,
        "HELI_X": 160,
        "YES_X": 820
      },
      "KREMLIN": {
        "DOOR_X": 160,
        "PUTIN_X": 380,
        "HELI_X": 160
      }
    },
    "PHYSICS": {
      "GRAVITY": 1400,
      "BEAR_SPEED": 100,
      "BEAR_ANGRY_SPEED": 300,
      "BEAR_CHASE_DISTANCE": 30,
      "BEAR_ATTACK_CHANCE": 0.02,
      "KNOCKBACK_FORCE": 280,
      "HORIZONTAL_KNOCKBACK": 60,
      "SCREEN_MARGIN": 40,
      "BOUNCE_DAMPING": 0.3,
      "CHASE_DAMPING": 0.96,
      "NORMAL_DAMPING": 0.92,
      "GROUND_DAMPING_CHASE": 0.95,
      "GROUND_DAMPING_NORMAL": 0.85
    },
    "COINS": {
      "GREENLAND_POSITIONS": [
        {"x": 250, "y": -35}, {"x": 450, "y": -45}, {"x": 650, "y": -40}, {"x": 850, "y": -42},
        {"x": 200, "y": -30}, {"x": 750, "y": -38}, {"x": 550, "y": -43}, {"x": 350, "y": -37},
        {"x": 950, "y": -33}, {"x": 150, "y": -41}, {"x": 400, "y": -60}, {"x": 800, "y": -65}
      ],
      "OVAL_POSITIONS": [
        {"x": 300, "y": -40}, {"x": 500, "y": -45}, {"x": 700, "y": -35},
        {"x": 900, "y": -43}, {"x": 400, "y": -38}, {"x": 800, "y": -42}, {"x": 600, "y": -65}
      ],
      "KREMLIN_POSITIONS": [
        {"x": 400, "y": -40}, {"x": 700, "y": -35}, {"x": 200, "y": -38}, {"x": 500, "y": -65}
      ]
    },
    "ANIMATION": {
      "BLINK_DURATION": 150,
      "NOD_SPEED": 0.8,
      "PRESS_EFFECT_DURATION": 200,
      "SHAKE_AMPLITUDE": 8,
      "SHAKE_DURATION": 600,
      "FEEDBACK_DURATION": 500,
      "WATER_RISE_SPEED": 480,
      "EXPLOSION_DELAY": 2000,
      "INTRO_UPDATE_MS": 100
    },
    "GAME": {
      "TOTAL_TIME_MS": 360000,
      "NEEDED_PER_AREA": 3,
      "RELATIONSHIP_THRESHOLDS": {
        "TRUST_LOW": 30,
        "RESPECT_LOW": 30,
        "FEAR_HIGH": 70
      }
    },
    "PERFORMANCE": {
      "TARGET_FPS": 60,
      "MIN_FPS": 30,
      "MOUSE_THROTTLE_MS": 16,
      "MAX_BORDER_POINTS": 200,
      "PARTICLE_LIMITS": {
        "BLOOD": 100,
        "SPARKS": 50,
        "DOWNWASH": 30,
        "OIL": 40,
        "FLAME": 25
      }
    }
  }
}
</script>

<script id="game-text-data" type="application/json">
  
{
  "ITEM_META": {
    "tan": { "id": "tan", "name": "Selvbruner", "stats": { "karisma": 2, "visdom": -1, "stil": 1 } },
    "shoes": { "id": "shoes", "name": "Guldsneakers", "stats": { "tempo": 100 } },
    "maga": { "id": "maga", "name": "MAGA-cap", "stats": { "karisma": 5, "visdom": -5 } },
    "dynamite": { "id": "dynamite", "name": "Dynamit", "stats": { "destruction": 999 } }
  },
  "BIDEN_LINES": [
    "Trump is a threat to our democracy.",
    "I'm the only one who can beat Trump.",
    "This is a battle for the soul of the nation.",
    "We must stand up to lies and defend the truth.",
    "Our democracy only works when we all do our part."
  ],
  "PRAISE": [
    "Genius move, sir!",
    "Historic leadership!",
    "Best decision ever!",
    "Total victory!",
    "Markets love it!"
  ],
  "COUNTRIES": [
    "Canada", "Mexico", "Germany", "France", "Denmark", "China", "India",
    "Brazil", "Japan", "Australia", "Norway", "Sweden", "Finland", "UK", "Italy"
  ],
  "EPSTEIN": {
    "DUMMY_NAMES": [
      "John Anderson", "Sarah Mitchell", "Robert Johnson", "Emily Davis", "Michael Brown",
      "Jessica Wilson", "David Martinez", "Ashley Taylor", "Christopher Lee", "Amanda White",
      "James Thompson", "Nicole Garcia", "Daniel Rodriguez", "Melissa Clark", "Matthew Lopez",
      "Stephanie Hill", "Kevin Green", "Lauren Adams", "Brian Baker", "Christina Nelson",
      "Ryan Carter", "Megan Phillips", "Justin Turner", "Rachel Collins", "Tyler Evans",
      "Samantha Stewart", "Brandon Morris", "Victoria Reed", "Jonathan Cook", "Heather Bell",
      "Nicholas Wright", "Courtney Murphy", "Aaron Rivera", "Danielle Cooper", "Jeremy King"
    ],
    "TRUMP_NAME_VARIATIONS": [
      "Donald Trump", "Donald J. Trump", "Donald John Trump", "D. Trump",
      "Mr. Trump", "President Trump", "POTUS Trump", "DJ Trump",
      "The Donald", "Donald"
    ],
    "DOC_TEMPLATES": [
      "Meeting scheduled with {name} on Tuesday at 3:00 PM regarding the Atlantic City project.",
      "{name} called to discuss the upcoming real estate acquisition in Manhattan.",
      "Confidential: {name} was present at the Mar-a-Lago dinner party on November 15th.",
      "Flight manifests show {name} traveled to Nassau on private aircraft N218DT.",
      "{name} contacted the office requesting a private meeting with senior leadership.",
      "Internal memo: {name} has been cleared for access to the VIP guest list.",
      "Phone records indicate multiple calls between {name} and the executive office.",
      "{name} was photographed at the charity gala fundraiser at Trump International.",
      "Security clearance approved for {name} - access level: Executive Floor only.",
      "Travel expenses reimbursement for {name}: $15,000 for Caribbean business trip."
    ]
  },
  "DIALOG": {
    "TRUMP_ABSURD": [
      "Mine!",
      "Rules are stupid.",
      "Pathetic danes.",
      "Boom. Everywhere.",
      "Enough talk. Now fight."
    ],
    "METTE_DIPLO": [
      "Grønland er ikke til salg — lad os tage det i en work group.",
      "Det skader USA's ry — work group.",
      "NATO er i fare — work group.",
      "... work group?"
    ]
  }
}
</script>

<script>
/* ================================================================
   MINI-TOC — TRUMPSPILLET 2026
   Brug denne til at arbejde i udsnit (Windsurf / GPT)

   ------------------------------------------------
   DATA / CONFIG
   ------------------------------------------------
   - GAME_CONFIG (JSON)        → #game-config (application/json) (linje ~129)

   ------------------------------------------------
   CORE
   ------------------------------------------------
   - CORE_CONSTANTS            → CFG, GAME_CONSTANTS (linje ~472)
   - CORE_SCENE_SYSTEM         → Scene, SceneManager (linje ~495)
   - CORE_PERF                → PERF (FPS, render time) (linje ~610)
   - CORE_GLOBAL_STATE         → GS (cleared, over, achievements) (linje ~1306)
   - CORE_RELATIONSHIPS        → RELATIONSHIPS, adjustRelationship() (linje ~1368)

   ------------------------------------------------
   GRAPHICS / ASSETS
   ------------------------------------------------
   - GRAPHICS_SYSTEM           → GRAPHICS, drawOrFallback, loadImage (linje ~618)
   - ASSET_PACK_LOADER         → applyAssetPack(), SVG support (linje ~840)
   - LOTTIE_FINAL_ART          → LOTTIE_ART, birthday/final art (linje ~881)
   - GRAPHICS_DIMENSIONS       → GRAPHICS_DIMENSIONS helpers (linje ~618)

   ------------------------------------------------
   CANVAS / ENGINE
   ------------------------------------------------
   - CANVAS_SETUP              → canvas, ctx, DPR, W/H (linje ~946)
   - CANVAS_FIT_RESIZE         → fit(), resize listener (linje ~982)
   - WORLD_RESCALE             → rescaleAll(), scale helpers (linje ~1015)
   - MAIN_LOOP                 → update(), draw(), requestAnimationFrame (linje ~9902)
   - SAFE_EXECUTION            → safeExecute(), safeDraw() (linje ~9879)

   ------------------------------------------------
   INPUT
   ------------------------------------------------
   - INPUT_GLOBAL_KEYDOWN      → stor keydown-handler (intro, overlays, game) (linje ~1084)
   - INPUT_KEYUP               → keyup handler (linje ~1240)
   - INPUT_OVERLAYS            → choiceOverlay, infoCard, continueOverlay (linje ~1054)
   - INPUT_SPECIAL_MODES       → golf, tug-of-war, border-draw (linje ~1363)
   - INPUT_ACTIONS             → jump, interact, inventory, debug, tweet (linje ~1194)

   ------------------------------------------------
   UI (DOM)
   ------------------------------------------------
   - UI_HELP_CARD              → help toggle + localStorage (linje ~1328)
   - UI_HUD                    → lives, chips, status (linje ~2127)
   - UI_INVENTORY              → inventory DOM + render (linje ~2010)
   - UI_OVERLAYS               → info, choice, flag, continue (linje ~6792)

   ------------------------------------------------
   GAMEPLAY (SHARED)
   ------------------------------------------------
   - PLAYER_STATE              → position, velocity, speed, items (linje ~1903)
   - PLAYER_MOVEMENT           → walk, jump, gravity (linje ~9964)
   - INVENTORY_SYSTEM          → inventory array, useItem() (linje ~1951)
   - INTERACTION_DISPATCH      → interact(), nearest-object logic (linje ~5867)
   - ACHIEVEMENTS              → awards, counters, win conditions (linje ~1723)

   ------------------------------------------------
   SCENES
   ------------------------------------------------
   - SCENE_INTRO               → intro screen + canvas art (linje ~1496)
   - SCENE_GREENLAND           → mine, rig, heli, bear, Mette, coins (linje ~4315)
   - SCENE_OVAL                → White House, aide, yes-group (linje ~4370)
   - SCENE_KREMLIN             → Putin, tug-of-war, cameras (linje ~4713)
   - SCENE_EPSTEIN             → files / document mini-game (linje ~4737)
   - SCENE_GOLF                → Mar-a-Lago Mini-Putt (GOLF state + input + physics) (linje ~2408)

   ------------------------------------------------
   AUDIO
   ------------------------------------------------
   - AUDIO_SYSTEM              → AudioContext, initAudio() (linje ~1451)
   - SFX_LIBRARY               → SFX.click(), explosion(), tweet(), etc. (linje ~1491)

   ------------------------------------------------
   DEBUG / DEV
   ------------------------------------------------
   - DEBUG_FLAGS               → CFG.DEBUG, SHOW_FPS (linje ~1194)
   - DEBUG_TOOLS               → overlays, logs, helpers (linje ~11079)

   ------------------------------------------------
   TIP (Windsurf):
   Sig fx:
   “Arbejd kun i INPUT_GLOBAL_KEYDOWN”
   “Ret kun INTERACTION_DISPATCH i SCENE_GREENLAND”
================================================================ */
</script>

</head>
<body>
<canvas id="game"></canvas>

<div class="ui collapsed" id="help-card">
  <button id="help-toggle" class="help-toggle" type="button" aria-expanded="false" aria-controls="help-panel">
    ❔ Vis styring
  </button>
  <div class="help-panel" id="help-panel" hidden>
    <div>←↓→ bevægelse · <kbd>Space</kbd>/<kbd>↑</kbd> hop · <kbd>E</kbd> interagér · <kbd>I</kbd> info · <kbd>B</kbd> inventar · <kbd>T</kbd> tweet</div>
    <small style="opacity: 0.8;"><kbd>R</kbd> reset · <kbd>N</kbd> non-violent · <kbd>F</kbd> FPS · <kbd>K</kbd> debug</small>
  </div>
  <span class="hint-label" aria-hidden="true">E: interagér</span>
  <!-- .hint-label is used to keep wording centralized if you localize -->
  
</div>
<div id="hud" class="hud"></div>
<div id="inv" class="inv" role="region" aria-label="Inventar" aria-hidden="false"></div>
<div id="areas2" class="areas"></div>
<div id="medal-display" class="medals" style="position:fixed;top:8px;right:8px;background:rgba(0,0,0,0.7);padding:6px 12px;border-radius:8px;color:#fff;font-size:12px;z-index:100;display:flex;gap:4px;align-items:center;"></div>
<div id="intro" class="intro-screen">
  <canvas id="intro-canvas" width="600" height="400" style="image-rendering: pixelated; border: 2px solid #00ffff; background: #000022; max-width: min(90vw, 600px); height: auto; flex-shrink: 0;"></canvas>
  <div class="intro-title">Try not to destroy the world Donald</div>
  <div class="intro-subtitle">Being the best president ever is tough. Bet YOU can't handle it</div>
  <div class="intro-prompt" aria-live="polite">Tryk Enter eller klik Start for at begynde</div>
  <button id="start-btn" class="intro-button" type="button" aria-label="Start spil">Start</button>
</div>


<!-- Lottie (Bodymovin) for AE JSON rendering -->
<script>
  // Avoid RequireJS/AMD "mismatch define" when embedded in pages that load require.js
  window.__lottie_old_define = window.define;
  window.define = undefined;
  window.__lottie_old_module = window.module;
  window.module = undefined;
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
<script>
  // Restore AMD globals for host page
  window.define = window.__lottie_old_define;
  window.module = window.__lottie_old_module;
  window.__lottie_old_define = undefined;
  window.__lottie_old_module = undefined;
</script>
<script>
  (() => {
    'use strict';

    // ===== LOAD DATA FROM JSON BLOCKS =====
    const loadData = (id) => {
      const el = document.getElementById(id);
      if (!el) {
        console.error(`Missing data block: ${id}`);
        return {};
      }
      try {
        return JSON.parse(el.textContent);
      } catch (err) {
        console.error(`Failed to parse ${id}:`, err);
        return {};
      }
    };

    // Load game configuration
    const configData = loadData('game-config');
    const CFG = configData.CFG || {};
    const GAME_CONSTANTS = configData.GAME_CONSTANTS || {};

    // Load text/dialog data
    const textData = loadData('game-text-data');
    const ITEM_META = textData.ITEM_META || {};
    const BIDEN_LINES = textData.BIDEN_LINES || [];
    const PRAISE = textData.PRAISE || [];
    const COUNTRIES = textData.COUNTRIES || [];
    const EPSTEIN_DATA = textData.EPSTEIN || {};
    const DUMMY_NAMES = EPSTEIN_DATA.DUMMY_NAMES || [];
    const TRUMP_NAME_VARIATIONS = EPSTEIN_DATA.TRUMP_NAME_VARIATIONS || [];
    const DOC_TEMPLATES = EPSTEIN_DATA.DOC_TEMPLATES || [];
    const DIALOG = textData.DIALOG || {};
    const TRUMP_ABSURD = DIALOG.TRUMP_ABSURD || [];
    const METTE_DIPLO = DIALOG.METTE_DIPLO || [];

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         1. CORE SYSTEMS                                    ║
  // ║  Scene management, graphics config, asset loading, performance monitoring  ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Scene System ----------
  class Scene {
    constructor(name) {
      this.name = name;
      this.objects = [];
      this.characters = [];
      this.initialized = false;
    }
    
    init() {
      if (this.initialized) return;
      this.reset();
      this.initialized = true;
    }
    
    reset() {
      // Override in subclasses
    }
    
    update(dt) {
      // Override in subclasses
      this.characters.forEach(char => {
        if (char.update) char.update(dt);
      });
    }
    
    draw(ctx) {
      // Override in subclasses
      this.objects.forEach(obj => {
        if (obj.draw) obj.draw(ctx);
      });
      this.characters.forEach(char => {
        if (char.draw) char.draw(ctx);
      });
    }
    
    handleClick(x, y) {
      // Override in subclasses
      return false; // Return true if click was handled
    }
    
    handleInteraction(obj) {
      // Override in subclasses  
      return false; // Return true if interaction was handled
    }
    
    getNearestObject(x, y, maxDistance = GAME_CONSTANTS.UI.PULSE_DISTANCE) {
      let nearest = null;
      let nearestDist = maxDistance * CFG.SCALE;
      
      [...this.objects, ...this.characters].forEach(obj => {
        if (!obj.x || !obj.y) return;
        const dist = Math.hypot(x - obj.x, y - obj.y);
        if (dist < nearestDist) {
          nearest = obj;
          nearestDist = dist;
        }
      });
      
      return nearest ? { obj: nearest, dist: nearestDist } : null;
    }
  }
  
  // Scene Manager
  const SceneManager = {
    scenes: new Map(),
    currentScene: null,
    
    registerScene(scene) {
      this.scenes.set(scene.name, scene);
    },
    
    switchToScene(sceneName) {
      const scene = this.scenes.get(sceneName);
      if (!scene) {
        console.warn(`Scene '${sceneName}' not found`);
        return false;
      }
      
      this.currentScene = scene;
      scene.init();
      return true;
    },
    
    getCurrentScene() {
      return this.currentScene;
    },
    
    update(dt) {
      if (this.currentScene) {
        safeExecute(() => this.currentScene.update(dt), `Scene ${this.currentScene.name} update`);
      }
    },
    
    draw(ctx) {
      if (this.currentScene) {
        safeDraw(() => this.currentScene.draw(ctx), `Scene ${this.currentScene.name} draw`);
      }
    },
    
    handleClick(x, y) {
      if (this.currentScene) {
        return safeExecute(() => this.currentScene.handleClick(x, y), `Scene ${this.currentScene.name} click`, false);
      }
      return false;
    },
    
    handleInteraction(obj) {
      if (this.currentScene) {
        return safeExecute(() => this.currentScene.handleInteraction(obj), `Scene ${this.currentScene.name} interaction`, false);
      }
      return false;
    }
  };
  
  // Performance monitoring
  const PERF = {
    frameCount: 0,
    lastFpsUpdate: 0,
    fps: 0,
    renderTime: 0,
    particleCount: 0
  };

  function estimateBirthdayArtHitRel(img){
    try {
      const w = img.naturalWidth || img.width || 0;
      const h = img.naturalHeight || img.height || 0;
      if (!w || !h) return null;
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const cctx = c.getContext('2d', { willReadFrequently: true });
      cctx.drawImage(img, 0, 0);
      const data = cctx.getImageData(0, 0, w, h).data;
      const x0 = Math.floor(w * 0.32), x1 = Math.floor(w * 0.68);
      const y0 = Math.floor(h * 0.18), y1 = Math.floor(h * 0.55);
      let bestY = Math.floor(h * 0.33);
      let bestScore = 0;
      for (let y = y0; y <= y1; y++) {
        let score = 0;
        let idx = (y * w + x0) * 4;
        for (let x = x0; x <= x1; x++) {
          const a = data[idx + 3];
          if (a > 40 && data[idx] < 80 && data[idx + 1] < 80 && data[idx + 2] < 80) score++;
          idx += 4;
        }
        if (score > bestScore) { bestScore = score; bestY = y; }
      }
      if (bestScore > 0) return bestY / h;
    } catch(_){}
    return null;
  }
  
  // ---------- Graphics Configuration System ----------
  const GRAPHICS = {
    // Image cache for loaded custom graphics
    images: new Map(),
    loading: new Set(),
    
    // Configuration for custom graphics URLs
    config: {
      // Characters
      trump: null,           // URL for Trump sprite
      mette: null,          // URL for Mette sprite
      putin: null,          // URL for Putin sprite
      bear: null,           // URL for Bear sprite
      aide: null,           // URL for Aide sprite
      
      // Backgrounds
      greenland_bg: null,   // URL for Greenland background
      oval_bg: null,        // URL for Oval Office background  
      kremlin_bg: null,     // URL for Kremlin background
      
      // Objects
      helicopter: null,     // URL for helicopter sprite
      mine: null,           // URL for mine sprite
      rig: null,            // URL for oil rig sprite
      flag: null,           // URL for flag sprite
      phone: null,          // URL for phone sprite
      door: null,           // URL for door sprite
      gold_bar: null,       // URL for gold bar (coin) sprite
      dynamite: null,       // URL for dynamite item sprite
      yes_member: null,     // URL for praising group member sprite
      glacier: null,        // URL for glacier sprite
      birthday_art: null,   // URL for final 8-bit birthday drawing

      // Game Over art (per-cause or default)
      gameover_default: null,   // URL used if no cause-specific art provided
      gameover_ice: null,       // URL for ice/water failure
      gameover_nuke: null,      // URL for nuclear failure
      gameover_kremlin: null,   // URL for Kremlin caught failure
      gameover_epstein: null,   // URL for Epstein fail
      
      // Items
      tan_bottle: null,     // URL for tan bottle item
      maga_cap: null,       // URL for MAGA cap item
      golden_shoes: null,   // URL for gold sneakers item
      gold_statue: null,    // URL for gold statue item
      
      // Effects
      missile: null,        // URL for missile sprite
      explosion: null,      // URL for explosion effect
      
      // UI Elements
      inventory_bg: null,   // URL for inventory background
      button: null,         // URL for button sprite

      // Rendering options for specific assets
      birthday_art_fit: null, // 'cover' | 'contain' | 'height' (default 'contain')
      gameover_fit: null,     // 'cover' | 'contain' (default 'contain')

      // Optional localized titles/subtitles for game over causes
      // Example: gameover_title_nuke: 'Kaboom', gameover_subtitle_nuke: 'Maybe not push that button'
      // These are free-form config keys applied via the asset pack 'options'
    },
    
    // Load an image from URL and cache it
    loadImage(key, url) {
      if (!url) return null;
      if (this.images.has(key)) return this.images.get(key);
      if (this.loading.has(key)) return null;
      
      this.loading.add(key);
      const img = new Image();
      try {
        // Set crossOrigin only for remote http(s) URLs; avoid for data: and local/relative paths
        if (typeof url === 'string' && /^https?:/i.test(url)) {
          img.crossOrigin = 'anonymous'; // For CORS support on remote URLs
        }
      } catch(_){}
      
      img.onload = () => {
        this.images.set(key, img);
        this.loading.delete(key);
        if (key === 'birthday_art') {
          const rel = estimateBirthdayArtHitRel(img);
          if (typeof rel === 'number') window.BIRTHDAY_ART_HIT_REL = rel;
        }
        if (CFG.DEBUG) console.log(`Loaded custom graphic: ${key}`);
      };
      
      img.onerror = () => {
        this.loading.delete(key);
        console.warn(`Failed to load custom graphic: ${key} from ${url}`);
      };
      
      img.src = url;
      return null; // Will be available on next frame
    },
    
    // Get cached image or load if needed
    getImage(key) {
      const url = this.config[key];
      if (!url) return null;
      return this.loadImage(key, url);
    },
    
    // Draw image if available, otherwise use fallback function
    drawOrFallback(ctx, key, fallbackFn, ...args) {
      const img = this.getImage(key);
      if (img && img.complete) {
        // Extract x, y from args for image drawing
        const [x, y] = args;
        return this.drawImage(ctx, img, x, y);
      } else {
        fallbackFn(...args);
        return false;
      }
    },
    
    // Draw image with proper scaling and positioning
    drawImage(ctx, img, x, y, width = null, height = null, centered = true) {
      if (!img || !img.complete) return false;
      
      const w = width || img.width * CFG.SCALE;
      const h = height || img.height * CFG.SCALE;
      const dx = centered ? x - w/2 : x;
      const dy = centered ? y - h/2 : y;
      
      ctx.drawImage(img, dx, dy, w, h);
      return true;
    },

    // Draw full-screen background if available (cover)
    drawBackground(ctx, key) {
      const url = this.config[key];
      if (!url) return false;
      const img = this.images.get(key);
      if (!(img && img.complete)) {
        this.loadImage(key, url);
        return false;
      }
      // Simple stretch to canvas size; callers can layer content atop
      ctx.drawImage(img, 0, 0, W, H);
      return true;
    },

    // Check if an image is loaded and ready
    imageReady(key){ const img = this.images.get(key); return !!(img && img.complete); },
    
    // Update configuration from external source
    updateConfig(newConfig) {
      Object.assign(this.config, newConfig);
      if (CFG.DEBUG) console.log('Updated graphics configuration:', this.config);
    },
    
    // Clear cache (useful for reloading graphics)
    clearCache() {
      this.images.clear();
      this.loading.clear();
    }
  };
  
  // Expose graphics system globally for external configuration
  window.GRAPHICS = GRAPHICS;
  // Default to the local birthday drawing if no asset pack overrides it
  if (!GRAPHICS.config.birthday_art) {
    GRAPHICS.config.birthday_art = 'drawing.png';
  }
  
  // Convenience function for setting graphics URLs
  window.setGraphic = function(key, url) {
    if (GRAPHICS.config.hasOwnProperty(key)) {
      GRAPHICS.config[key] = url;
      if (CFG.DEBUG) console.log(`Set graphic ${key} to: ${url}`);
    } else {
      console.warn(`Unknown graphic key: ${key}. Available keys:`, Object.keys(GRAPHICS.config));
    }
  };
  
  // Function to set multiple graphics at once
  window.setGraphics = function(configObject) {
    GRAPHICS.updateConfig(configObject);
  };
  
  // -------- Asset Pack Loader (single-file friendly) --------
  // Pack schema:
  // {
  //   images: { key: dataUrlOrHttpUrl, ... },
  //   svgs:   { key: "<svg ...>...</svg>", ... },
  //   lottie: { birthday_art: { ... JSON ... } }
  // }
  function svgToDataUrl(svgString){
    try { return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); }
    catch(_) { return 'data:image/svg+xml;utf8,' + encodeURIComponent(svgString); }
  }
  window.applyAssetPack = function(pack){
    if (!pack || typeof pack !== 'object') { console.warn('applyAssetPack: invalid pack'); return false; }
    const conf = {};
    if (pack.images && typeof pack.images === 'object'){
      for (const [k,v] of Object.entries(pack.images)){
        conf[k] = v; // supports data URLs or http(s) URLs
      }
    }
    // Optional generic options (non-image keys)
    if (pack.options && typeof pack.options === 'object'){
      for (const [k,v] of Object.entries(pack.options)){
        conf[k] = v;
      }
    }
    if (pack.svgs && typeof pack.svgs === 'object'){
      for (const [k,svg] of Object.entries(pack.svgs)){
        conf[k] = svgToDataUrl(String(svg||''));
      }
    }
    if (Object.keys(conf).length){
      GRAPHICS.updateConfig(conf);
      GRAPHICS.clearCache(); // ensure fresh loads on next draw
      // If a direct image is supplied for the final art, prefer it over Lottie
      if (conf.birthday_art) { try { setBirthdayLottieJSON(null); } catch(_){} }
    }
    if (pack.lottie && pack.lottie.birthday_art){
      try { setBirthdayLottieJSON(pack.lottie.birthday_art); } catch(e){ console.warn('Failed to set Lottie JSON from asset pack', e); }
    }
    if (CFG.DEBUG) console.log('Asset pack applied');
    return true;
  };
  window.applyAssetPackFromScript = function(id='asset-pack'){
    try {
      const el = document.getElementById(id);
      if (!el) return false;
      const json = JSON.parse(el.textContent||'{}');
      return window.applyAssetPack(json);
    } catch(e){ console.warn('applyAssetPackFromScript failed', e); return false; }
  };

  // Optional Lottie manager for the final art (requires lottie-web on window.bodymovin)
  const LOTTIE_ART = {
    json: null,
    anim: null,
    container: null,
    canvasEl: null,
    ready: false,
    targetW: 0,
    targetH: 0,
    ensure(){
      if (!window.bodymovin || !this.json) return false;
      if (this.anim) return true;
      // Create hidden container in DOM so lottie can manage its own canvas
      this.container = document.createElement('div');
      Object.assign(this.container.style, { position: 'absolute', left: '-99999px', top: '-99999px', width: '10px', height: '10px', pointerEvents: 'none' });
      document.body.appendChild(this.container);
      this.anim = window.bodymovin.loadAnimation({
        container: this.container,
        renderer: 'canvas',
        loop: false,
        autoplay: true,
        animationData: this.json,
        rendererSettings: { clearCanvas: true, preserveAspectRatio: 'none' }
      });
      this.ready = false;
      const readyFn = () => {
        this.canvasEl = this.container.querySelector('canvas');
        this.ready = !!this.canvasEl;
      };
      this.anim.addEventListener('DOMLoaded', readyFn);
      this.anim.addEventListener('complete', readyFn);
      return true;
    },
    resize(w, h){
      if (!this.ensure()) return false;
      if (this.targetW === w && this.targetH === h) return true;
      this.targetW = w; this.targetH = h;
      this.container.style.width = Math.max(1, Math.floor(w)) + 'px';
      this.container.style.height = Math.max(1, Math.floor(h)) + 'px';
      try { this.anim.resize(); } catch(_){}
      return true;
    }
  };
  window.setBirthdayLottieJSON = function(json){
    try { LOTTIE_ART.json = json; LOTTIE_ART.ready = false; if (LOTTIE_ART.anim){ LOTTIE_ART.anim.destroy(); LOTTIE_ART.anim = null; } } catch(_){}
  };

  // Attempt to load birthday art JSON only if embedded inline
  try {
    const inline = document.getElementById('birthday-lottie-json');
    if (inline && inline.textContent) {
      try { const json = JSON.parse(inline.textContent); setBirthdayLottieJSON(json); if (CFG.DEBUG) console.log('Loaded inline birthday Lottie JSON'); }
      catch(e){ console.warn('Inline birthday JSON parse failed', e); }
    }
  } catch(_){}
  
  // 3) Finally, try to apply a comprehensive asset-pack if embedded
  try { applyAssetPackFromScript('asset-pack'); } catch(_){}
  try { document.addEventListener('DOMContentLoaded', ()=>{ try { applyAssetPackFromScript('asset-pack'); } catch(_){} }); } catch(_){}

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         2. CANVAS & RENDERING SETUP                        ║
  // ║  Canvas initialization, scaling, resize handling                           ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Canvas ----------
  const cvs = document.getElementById('game');
  if (!cvs) {
    console.error('Canvas element "game" not found!');
    return;
  }
  const ctx = cvs.getContext('2d');
  if (!ctx) {
    console.error('2D context not supported!');
    return;
  }
  let currentCursor = 'default';
  function setCanvasCursor(cursor){
    const next = cursor || 'default';
    if (currentCursor !== next){
      try { cvs.style.cursor = next; } catch(_){}
      currentCursor = next;
    }
  }
  // Accessibility hint for screen readers
  try { cvs.setAttribute('aria-label','Spilområde'); } catch(_){}
  let W=0,H=0,DPR=1, last=performance.now(), deltaTime=0;
  const TARGET_FPS = (GAME_CONSTANTS.PERFORMANCE && GAME_CONSTANTS.PERFORMANCE.TARGET_FPS) || 60;
  const MAX_DELTA = 1000 / ((GAME_CONSTANTS.PERFORMANCE && GAME_CONSTANTS.PERFORMANCE.MIN_FPS) || 30); // Cap at configured min FPS
  let skyGrad = null; // cached sky gradient
  // ambient clouds
  let CLOUDS = [];
  // Optional background image for border map (set via setMapImage(url))
  const MAP_IMG = new Image();
  let MAP_IMG_READY = false;
  function setMapImage(url){
    MAP_IMG_READY = false;
    MAP_IMG.onload = ()=>{ MAP_IMG_READY = true; };
    MAP_IMG.onerror = ()=>{ MAP_IMG_READY = false; };
    if (url) MAP_IMG.src = url;
  }

  function fit() {
    try {
      const oldScale = CFG.SCALE || 1;
      DPR = window.devicePixelRatio || 1;
      W = Math.round(innerWidth);
      H = Math.round(innerHeight);
      cvs.width = Math.round(W*DPR);
      cvs.height = Math.round(H*DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
      CFG.SCALE = Math.max(0.8, Math.min(1.4, W/1200));
      // cache gradient per size
      skyGrad = ctx.createLinearGradient(0,0,0,H);
      skyGrad.addColorStop(0,'#dff4ff');
      skyGrad.addColorStop(1,'#a7dfff');
      // Rescale world positions to new scale to avoid drift on resize
      const ratio = CFG.SCALE / oldScale;
      if (ratio && Math.abs(ratio-1) > 0.001) {
        try { rescaleAll(ratio); } catch(e){ if (CFG.DEBUG) console.warn('rescaleAll failed', e); }
      }
    } catch(err) {
      console.warn('Canvas resize failed:', err);
      // Fallback values
      W = W || 800;
      H = H || 600;
      CFG.SCALE = CFG.SCALE || 1;
    }
  }
  fit();
  addEventListener('resize', fit);

  // Rescale helpers for window resize
  function scaleProps(obj, props, r){ if (!obj) return; props.forEach(p=>{ if (typeof obj[p]==='number') obj[p]*=r; }); }
  function rescaleArray(arr, props, r){ if (!arr) return; arr.forEach(o=>scaleProps(o, props, r)); }
  function rescaleAll(r){
    // Player and ground anchor
    scaleProps(player, ['x','y','w','h'], r);
    player.y = H - world.floor; // stick to ground after resize
    // Greenland
    scaleProps(GL.mine, ['x','y'], r);
    scaleProps(GL.rig, ['x','y'], r);
    scaleProps(GL.heli, ['x','y'], r);
    scaleProps(GL.bear, ['x','y'], r);
    scaleProps(GL.mette, ['x','y'], r);
    if (GL.flag) scaleProps(GL.flag, ['x','y'], r);
    rescaleArray(GL.items, ['x','y'], r);
    rescaleArray(GL.glaciers, ['x','y'], r); // w/h are logical sizes
    rescaleArray(GL.coins, ['x','y'], r);
    // Oval
    scaleProps(OV.door, ['x','y'], r);
    scaleProps(OV.aide, ['x','y'], r);
    scaleProps(OV.heli, ['x','y'], r);
    scaleProps(OV.yes, ['x','y'], r);
    if (OV.buttons) OV.buttons.forEach(b=>scaleProps(b, ['x','y','w','h'], r));
    rescaleArray(OV.coins, ['x','y'], r);
    // Kremlin
    scaleProps(KR.door, ['x','y'], r);
    scaleProps(KR.putin, ['x','y'], r);
    scaleProps(KR.heli, ['x','y'], r);
    scaleProps(KR.camera, ['x','y'], r);
    rescaleArray(KR.statues, ['x','y'], r);
    rescaleArray(KR.coins, ['x','y'], r);
    // Ambient clouds and FX (best-effort)
    if (CLOUDS) CLOUDS.forEach(c=>{ scaleProps(c, ['x','y','w','h','vx'], r); });
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         3. INPUT HANDLING                                  ║
  // ║  Keyboard, mouse, touch input, overlays                                    ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Input ----------
  const keys = new Set();
  let choiceOverlay = null; // {text, onKey(k)}
  let flagOverlay = null; // {flagType, startTime} - shows flag planted on Ukraine
  // Continue overlay state (voting machine or tweet-to-continue)
  let continueOverlay = null; // { mode:'voting'|'tweet', phase:'idle'|'spinning'|'done', start, nextAt, interval, inc, stepsLeft, idx, words, stopped, stopAt, stopAtTime, grantDone }
  function startContinueOverlay(mode='voting'){
    continueOverlay = {
      mode,
      phase: 'idle',
      start: nowMs(),
      // Slot-like decelerating steps
      interval: 80, // ms between changes at start
      inc: 36,      // increase per step (slows down)
      stepsLeft: 0, // idle until triggered
      nextAt: nowMs() + 80,
      words: ['DEMOCRAT','INDEPENDENT','REPUBLICAN','TRUMP'],
      idx: 0, // start at DEMOCRAT
      stopped: false,
      stopAt: 'TRUMP',
      stopAtTime: 0,
      grantDone: false
    };
    
    // Virtual canvas size for golf scene (fallback if external loaders aren't present)
    const VIRTUAL_W = window.VIRTUAL_W || 960, VIRTUAL_H = window.VIRTUAL_H || 540;
    window.VIRTUAL_W = VIRTUAL_W; window.VIRTUAL_H = VIRTUAL_H;
    GS.over = true;
    GS.overMode = 'continue';
  }
  function closeContinueOverlay(){ continueOverlay = null; }
  let tweetCount = 0;
  // INPUT_GLOBAL_KEYDOWN
  addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    let handled = false;
    
    // Intro screen handling
    if (scene === 'intro') {
      if (k === 'enter' || e.code === 'Enter' || (k.length === 1 && k !== ' ' && k !== 'e')) { startGame(); handled = true; }
      if (handled) e.preventDefault();
      return;
    }
    
    // Game over screen handling
    if (GS.over && GS.overMode === 'epstein_success' && (k==='enter' || e.code==='Enter' || (k && k.length===1))){
      GS.over = false; GS.overMode = null; GS.overText = '';
      switchScene('greenland');
      handled = true;
      if (handled) e.preventDefault();
      return;
    }
    if (GS.over && GS.overMode === 'epstein_fail' && (k==='enter' || e.code==='Enter' || (k && k.length===1))){
      GS.over = false; GS.overMode = null; GS.overText = '';
      switchScene('greenland');
      handled = true;
      if (handled) e.preventDefault();
      return;
    }
    if (GS.over && GS.overMode && String(GS.overMode).startsWith('go_') && (k==='enter' || e.code==='Enter' || (k && k.length===1))){
      // Transition from cause art to Continue overlay (voting machine)
      startContinueOverlay('voting');
      handled = true;
      if (handled) e.preventDefault();
      return;
    }
    if (GS.over && GS.overMode === 'continue' && (k==='enter' || e.code==='Enter' || k==='t')){
      // If idle, start spinning; if done, respawn
      if (continueOverlay && continueOverlay.phase === 'idle'){
        continueOverlay.phase = 'spinning';
        continueOverlay.stepsLeft = 12 + Math.floor(Math.random()*6);
        continueOverlay.interval = 80; continueOverlay.inc = 32;
        continueOverlay.nextAt = nowMs() + continueOverlay.interval;
      } else if (continueOverlay && continueOverlay.phase === 'done'){
        GS.over = false; GS.overMode = null; GS.overText=''; GO.cause=null; closeContinueOverlay();
        switchScene('greenland');
      }
      handled = true;
      if (handled) e.preventDefault();
      return;
    }
    if (GS.over && k === 'r' && e.shiftKey) {
      // Full game restart - go back to intro screen
      resetStateDefaults();
      inventory.length = 0; 
      collectedCoins = 0; // Reset coin counter
      player.goldBalance = 0;
      renderInv();
      player.baseSpeedMul = 1;
      player.goldenShoesOn = false;
      updatePlayerSpeedMul();
      player.tanLevel = 0; 
      player.capOn = false; 
      player.speedBoost10 = false; player.healthBoost18 = false; player.masterCollector = false; // Reset coin rewards
      renderHUD();
      GS.over = false;
      GS.overText = '';
      scene = 'intro';
      document.getElementById('intro').style.display = 'block';
      handled = true;
    if (handled) e.preventDefault();
    return;
  }
  
    if (choiceOverlay) {
      const count = choiceOverlay.options ? choiceOverlay.options.length : 0;
      if (k==='arrowup' || k==='w') {
        if (count) { choiceOverlay.selected = (choiceOverlay.selected - 1 + count) % count; choiceOverlay.hoverIndex = null; }
        handled = true;
      } else if (k==='arrowdown' || k==='s') {
        if (count) { choiceOverlay.selected = (choiceOverlay.selected + 1) % count; choiceOverlay.hoverIndex = null; }
        handled = true;
      } else if (k==='enter' || k===' ') {
        const opt = count ? choiceOverlay.options[choiceOverlay.selected] : null;
        if (opt) { choiceOverlay.onKey(opt.key); }
        handled = true;
      } else if (k.length === 1 && k >= '1' && k <= '9') {
        const idx = Number(k) - 1;
        if (count && idx >= 0 && idx < count) { choiceOverlay.selected = idx; choiceOverlay.onKey(k); handled = true; }
      } else if (k==='escape' || k==='esc') { closeChoice(); handled = true; }
    } else if (infoCard) {
      if (k==='enter' || (k && k.length===1)) { infoCard.onKey(k); handled = true; }
      else if (k==='escape' || k==='esc') { closeInfoCard(); handled = true; }
    } else if (flagOverlay) {
      // Only Enter key closes flag overlay
      if (k==='enter') { closeFlagOverlay(); handled = true; }
    } else if (borderDraw){
      if (k==='enter'){ stopBorderDraw(true); handled = true; }
      else if (k==='escape' || k==='esc'){ stopBorderDraw(false); handled = true; }
      else if (k==='backspace'){ if (borderDraw.points.length>0) borderDraw.points.pop(); handled = true; }
      else if (k==='u' && borderDraw.points.length>2){ smoothBorder(); handled = true; }
      else if (k==='c'){ borderDraw.points = []; isDrawing = false; lastDrawPoint = null; handled = true; }
    } else if (tug && (k==='a' || k==='d' || k==='f' || k==='k')){ 
      handleTugKey(k); handled = true; 
    } else if (scene==='golf') {
      handled = golfHandleKeyDown(e, k);
    } else {
      // Normal game controls
      keys.add(k);
      // Epstein scene: pause/resume toggle
      if (scene==='epstein' && k==='p') { EP.paused = !EP.paused; say(player, EP.paused? 'Paused' : 'Resumed', 900); handled = true; }
      if (k==='n') CFG.NON_VIOLENT = !CFG.NON_VIOLENT;
      else if (k==='f') CFG.SHOW_FPS = !CFG.SHOW_FPS; // Toggle FPS display
      else if (k==='k') CFG.DEBUG = !CFG.DEBUG; // Toggle debug mode (changed from backtick to 'k')
      else if (k==='t') doTweet();
      else if (k===' ' || k==='arrowup') doJump();
      else if (k==='1' || k==='2' || k==='3' || k==='4') { useInventoryKey(k); handled = true; }
      else if (k==='i') { const open = helpToggleEl && helpToggleEl.getAttribute('aria-expanded') === 'true'; setHelpCardState(!open); handled = true; }
      else if (k==='b') toggleInventory();
      else if (k==='d') { 
        const dyn = inventory.find(it=>it.id==='dynamite' && (it.qty||0)>0);
        if (dyn){ player.selectedItem = (player.selectedItem==='dynamite')? null : 'dynamite'; renderInv(); handled=true; }
      }
      else if (k==='e') {
        // Guitar Hero redact in Epstein scene
        if (scene==='epstein' && EP.gameActive && !EP.paused) {
          handleEpsteinGuitarHero();
          handled = true;
        } else {
          // Interact (including planting dynamite across scenes)
          interact();
          handled = true;
        }
      }
      // Reset handling
      else if (k==='r') {
        if (e.shiftKey){ // hard reset
          resetStateDefaults();
          inventory.length = 0; 
          collectedCoins = 0; // Reset coin counter
          player.goldBalance = 0;
          renderInv();
          player.baseSpeedMul = 1; player.goldenShoesOn = false; updatePlayerSpeedMul();
          player.tanLevel = 0; player.capOn = false; 
          player.speedBoost10 = false; player.healthBoost18 = false; player.masterCollector = false; // Reset coin rewards
          renderHUD();
        } else {
          resetStateDefaults();
        }
        if (scene==='greenland') resetGreenland(); else resetOval();
        handled = true;
      }
      
      if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(k)) handled = true;
    }
    
    if (handled) e.preventDefault();
  }, {passive:false});
  // END INPUT_GLOBAL_KEYDOWN
  addEventListener('keyup', e => {
    
    const k = e.key.toLowerCase();
    if (scene==='golf' && golfHandleKeyUp(e, k)){
      e.preventDefault();
      return;
    }
    keys.delete(k);
  });

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         4. UTILITY FUNCTIONS                               ║
  // ║  Math helpers, collision detection, timing utilities                       ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Hjælpere ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const nowMs = ()=>performance.now();
  function updatePlayerSpeedMul(){
    player.speedMul = (player.baseSpeedMul || 1) * (player.goldenShoesOn ? 2 : 1);
  }
  function pointInPolygon(px, py, poly){
    let inside = false;
    for (let i=0, j=poly.length-1; i<poly.length; j=i++){
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];
      const intersect = ((yi>py)!=(yj>py)) && (px < (xj-xi)*(py-yi)/(yj-yi+1e-6)+xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }
  // Distance from point to axis-aligned rectangle (centered at cx,cy, size w x h)
  function distToRect(px,py,cx,cy,w,h){
    const dx = Math.max(Math.abs(px-cx) - w/2, 0);
    const dy = Math.max(Math.abs(py-cy) - h/2, 0);
    return Math.hypot(dx, dy);
  }
  function heliProximity(heli, px, py){
    // Generous rectangle covering cabin/rotor area down to ground, shifted slightly right
    const cx = heli.x + 20*CFG.SCALE;
    const cy = heli.y - 6*CFG.SCALE;
    const w = 220*CFG.SCALE; // wide so side standing counts
    const h = 120*CFG.SCALE; // tall to include ground under rotor
    return distToRect(px, py, cx, cy, w, h);
  }
  
  // Helper function to darken colors for button press effect
  function darkenColor(color) {
    if (color.startsWith('#')) {
      const hex = color.slice(1);
      const num = parseInt(hex, 16);
      const r = Math.max(0, (num >> 16) - 40);
      const g = Math.max(0, ((num >> 8) & 0x00FF) - 40);
      const b = Math.max(0, (num & 0x0000FF) - 40);
      return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
    }
    return color; // fallback if not hex color
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         5. GAME STATE & RELATIONSHIPS                      ║
  // ║  Global game state, relationship tracking, audio system                    ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Don't-destroy-the-world Game State ----------
  const GS = {
    cleared: { greenland:0, oval:0, kremlin:0, epstein:0 },
    // Align required tasks per area with GAME_CONSTANTS
    needPerArea: (GAME_CONSTANTS && GAME_CONSTANTS.GAME && GAME_CONSTANTS.GAME.NEEDED_PER_AREA) || 5,
    over: false,
    overText: '',
    lives: 0,
    nobelAwarded: false,
    achievements: {
      perfectDiplomat: false, // Win with all relationships > 70
      collector: false, // Win with 10+ inventory items
      twitterAddict: false, // Tweet 5+ times
      bearWhisperer: false, // Defeat bear without infection
      nobelLaureate: false
    },
    // Medal system - one per scene
    medals: {
      greenland: false,  // Grønlandsflag - blow up Lars Løkke
      oval: false,       // Pulitzer - complete quiz with 100% approval
      kremlin: false,    // Nobel - win handshake with Putin
      epstein: false,    // Art Diploma - redact all names + art
      golf: false        // FIFA - beat Biden
    }
  };

  // Medal definitions with display info
  const MEDAL_INFO = {
    greenland: { name: 'Grønlandsflag', icon: '🇬🇱', desc: 'Annektér Grønland' },
    oval: { name: 'Pulitzer', icon: '📰', desc: 'Opnå 100% MAGA approval' },
    kremlin: { name: 'Nobel', icon: '🏅', desc: 'Vind armlægning med Putin' },
    epstein: { name: 'Art Diploma', icon: '🎨', desc: 'Rediger alle dokumenter' },
    golf: { name: 'FIFA Trophy', icon: '🏆', desc: 'Slå Sleepy Joe i golf' }
  };

  function awardMedal(sceneKey) {
    if (GS.medals[sceneKey]) return; // Already awarded
    GS.medals[sceneKey] = true;
    const info = MEDAL_INFO[sceneKey];
    if (info) {
      SFX.achievement();
      say(player, `${info.icon} MEDALJE: ${info.name}!`, 2500);
    }
    saveMedals();
    updateMedalDisplay();
  }

  function saveMedals() {
    try { localStorage.setItem('trumpv2-medals', JSON.stringify(GS.medals)); } catch(_){}
  }

  function loadMedals() {
    try {
      const saved = localStorage.getItem('trumpv2-medals');
      if (saved) {
        const parsed = JSON.parse(saved);
        Object.keys(GS.medals).forEach(k => {
          if (parsed[k]) GS.medals[k] = true;
        });
      }
    } catch(_){}
  }

  function updateMedalDisplay() {
    const el = document.getElementById('medal-display');
    if (!el) return;
    const earned = Object.entries(GS.medals).filter(([k,v]) => v);
    if (earned.length === 0) {
      el.innerHTML = '<span style="opacity:0.5">Ingen medaljer endnu</span>';
    } else {
      el.innerHTML = earned.map(([k]) => {
        const info = MEDAL_INFO[k];
        return `<span title="${info.name}: ${info.desc}" style="font-size:1.4em;cursor:help">${info.icon}</span>`;
      }).join(' ');
    }
  }
  const areasEl2 = document.getElementById('areas2');
  try { areasEl2 && areasEl2.setAttribute('aria-live','polite'); } catch(_){}

  // Toggleable help legend
  const helpCardEl = document.getElementById('help-card');
  const helpPanelEl = document.getElementById('help-panel');
  const helpToggleEl = document.getElementById('help-toggle');
  const helpHintEl = helpCardEl ? helpCardEl.querySelector('.hint-label') : null;
  const HELP_STORAGE_KEY = 'trumpv2-help-open';

  function setHelpCardState(open, opts){
    if (!helpCardEl || !helpPanelEl || !helpToggleEl) return;
    const shouldPersist = !opts || opts.persist !== false;
    helpCardEl.classList.toggle('collapsed', !open);
    helpPanelEl.hidden = !open;
    helpToggleEl.setAttribute('aria-expanded', open ? 'true' : 'false');
    helpToggleEl.textContent = open ? '❔ Skjul styring' : '❔ Vis styring';
    if (helpHintEl) helpHintEl.setAttribute('aria-hidden', open ? 'true' : 'false');
    if (shouldPersist){
      try { localStorage.setItem(HELP_STORAGE_KEY, open ? '1' : '0'); } catch(_){ /* ignore */ }
    }
  }

  if (helpToggleEl){
    // Always start collapsed (ignore any previous preference)
    setHelpCardState(false, { persist:false });
    try { localStorage.setItem(HELP_STORAGE_KEY, '0'); } catch(_){ /* ignore */ }
    helpToggleEl.addEventListener('click', () => {
      const open = helpToggleEl.getAttribute('aria-expanded') === 'true';
      setHelpCardState(!open);
    });
  }

  // Removed global timer — no countdown displayed
  function renderAreas2(){ if (!areasEl2) return; areasEl2.innerHTML=''; [['greenland','🇬🇱 Grønland'],['oval','🏛️ Hvide Hus'],['kremlin','🇷🇺 Kremlin'],['epstein','📄 Epstein files']].forEach(([k,label])=>{ const d=document.createElement('span'); d.className='pill'; const progress = GS.cleared[k] || 0; const needed = GS.needPerArea; let bgColor = 'rgba(200,0,0,.8)'; if (progress >= needed) bgColor = 'rgba(0,150,0,.8)'; else if (progress > 0) bgColor = 'rgba(200,150,0,.8)'; d.style.background = bgColor; d.textContent=`${label}: ${progress}/${needed}`; areasEl2.appendChild(d); }); }
  renderAreas2();
  loadMedals();
  updateMedalDisplay();
  
  // ---------- Game State Variables ----------
  let scene = 'intro'; // 'intro' | 'greenland' | 'oval' | 'kremlin' | 'epstein'
  let introStartTime = 0;
  const world = { floor: 120 };
  let borderDraw = null; // Add this here too
  
  // Removed infection system - replaced with bear chasing
  
  // ---------- Relationship System ----------
  const RELATIONSHIPS = {
    mette: {
      respect: 50, // 0-100
      trust: 50,
      fear: 20,
      lastInteraction: 'neutral'
    },
    putin: {
      respect: 30,
      trust: 20, 
      fear: 10,
      lastInteraction: 'neutral'
    }
  };
  
  function adjustRelationship(character, changes, reason) {
    const rel = RELATIONSHIPS[character];
    if (!rel) return;
    
    // Apply changes with bounds checking
    Object.keys(changes).forEach(stat => {
      if (rel.hasOwnProperty(stat)) {
        rel[stat] = Math.max(0, Math.min(100, rel[stat] + changes[stat]));
      }
    });
    
    // Store context
    rel.lastInteraction = reason;
    rel.lastChange = changes;
    rel.lastChangeTime = nowMs();
    
    if (CFG.DEBUG) console.log(`Relationship with ${character}:`, rel, `(${reason})`);
    
    // Play audio feedback
    ensureAudioInit();
    const totalChange = Object.values(changes).reduce((sum, val) => sum + val, 0);
    if (totalChange > 5) SFX.success();
    else if (totalChange < -5) SFX.error();
    else SFX.click();
  }
  
  function getRelationshipLevel(character, stat) {
    const value = RELATIONSHIPS[character]?.[stat] || 50;
    if (value >= 80) return 'excellent';
    if (value >= 60) return 'good';
    if (value >= 40) return 'neutral';
    if (value >= 20) return 'poor';
    return 'terrible';
  }
  
  function getRelationshipEmoji(character) {
    const rel = RELATIONSHIPS[character];
    if (!rel) return '😐';
    
    const avg = (rel.respect + rel.trust - rel.fear) / 3;
    if (avg >= 70) return '😍'; // Love
    if (avg >= 50) return '😊'; // Like
    if (avg >= 30) return '😐'; // Neutral
    if (avg >= 10) return '😠'; // Dislike
    return '🤬'; // Hate
  }
  
  // Enhanced drawing state
  let isDrawing = false;
  let lastDrawPoint = null;
  const drawingSettings = {
    smoothingDistance: 15, // Minimum distance between points
    maxDrawingSpeed: 1000, // Max pixels per second
    showPreview: true
  };
  
  // ---------- Audio System ----------
  const AUDIO = {
    enabled: true,
    masterVolume: 0.7,
    sounds: {},
    music: null,
    currentTrack: null
  };
  
  // Web Audio API context for better sound control
  let audioContext = null;
  
  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (CFG.DEBUG) console.log('Audio system initialized');
    } catch (e) {
      console.warn('Audio not supported:', e);
      AUDIO.enabled = false;
    }
  }
  
  function playSound(frequency, duration, type = 'sine', volume = 0.3) {
    if (!AUDIO.enabled || !audioContext) return;
    
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = type;
      
      gainNode.gain.value = volume * AUDIO.masterVolume;
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + duration);
    } catch (e) {
      console.warn('Sound play failed:', e);
    }
  }
  
  function playChord(frequencies, duration, volume = 0.2) {
    frequencies.forEach((freq, i) => {
      setTimeout(() => playSound(freq, duration, 'sine', volume), i * 50);
    });
  }
  
  // Sound effect library
  const SFX = {
    click: () => playSound(800, 0.1, 'square', 0.2),
    buttonPress: () => playSound(600, 0.15, 'square', 0.3),
    success: () => playChord([523, 659, 784], 0.5, 0.25), // C-E-G
    error: () => playSound(200, 0.3, 'sawtooth', 0.3),
    helicopter: () => {
      // Simulate rotor sound with multiple tones
      for(let i = 0; i < 10; i++) {
        setTimeout(() => playSound(100 + Math.random()*50, 0.1, 'sawtooth', 0.15), i * 50);
      }
    },
    explosion: () => {
      playSound(60, 0.5, 'sawtooth', 0.4);
      setTimeout(() => playSound(40, 0.8, 'square', 0.3), 100);
    },
    whoosh: () => {
      for(let i = 0; i < 5; i++) {
        setTimeout(() => playSound(400 - i*50, 0.1, 'sine', 0.2), i * 30);
      }
    },
    achievement: () => playChord([523, 659, 784, 1047], 0.8, 0.3), // Victory fanfare
    tweet: () => {
      // Twitter notification sound
      playSound(1000, 0.1, 'sine', 0.15);
      setTimeout(() => playSound(1200, 0.1, 'sine', 0.12), 120);
    },
    heartbeat: () => {
      playSound(80, 0.1, 'sine', 0.4);
      setTimeout(() => playSound(80, 0.1, 'sine', 0.4), 150);
    }
  };
  
  // Initialize audio on first user interaction
  let audioInitialized = false;
  function ensureAudioInit() {
    if (!audioInitialized && audioContext?.state === 'suspended') {
      audioContext.resume();
      audioInitialized = true;
    }
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         6. INTRO SCREEN                                    ║
  // ║  Intro animation, start game logic                                         ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Intro Screen ----------
  function initIntro() {
    introStartTime = nowMs();
    const introCanvas = document.getElementById('intro-canvas');
    if (introCanvas) {
      // Ensure canvas is properly sized
      const rect = introCanvas.getBoundingClientRect();
      introCanvas.width = 600;
      introCanvas.height = 400;
      const ictx = introCanvas.getContext('2d');
      if (CFG.DEBUG) console.log('Drawing intro graphics on canvas', introCanvas.width, 'x', introCanvas.height);
      // Enable image smoothing for pixel art
      ictx.imageSmoothingEnabled = false;
      drawIntroGraphics(ictx, introCanvas.width, introCanvas.height);
    } else {
      if (CFG.DEBUG) console.log('Intro canvas not found!');
    }
  }
  
  function drawIntroGraphics(ctx, w, h) {
    // Clear canvas first
    ctx.clearRect(0, 0, w, h);
    
    // White background behind helicopter and Trump
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
    
    // Draw simple helicopter and Trump using basic shapes - safer approach
    drawIntroHeli(ctx, w/2, h/2 + 20);
    drawIntroTrump(ctx, w/2 + 60, h/2 + 40);
  }
  
  function drawIntroHeli(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Helicopter body
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(-60, -15, 150, 42);
    
    // Cockpit
    ctx.fillStyle = '#86d0ff';
    ctx.fillRect(69, -9, 15, 24);
    
    // Main rotor shaft
    ctx.fillStyle = '#333';
    ctx.fillRect(9, -27, 6, 12);
    
    // Main rotor blades
    ctx.fillStyle = '#333';
    ctx.fillRect(-60, -33, 210, 6);
    
    // Rotor blur effect
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#000';
    ctx.fillRect(-90, -34, 270, 9);
    ctx.globalAlpha = 1;
    
    // Landing skids
    ctx.fillStyle = '#333';
    ctx.fillRect(-45, 27, 90, 6);
    ctx.fillRect(30, 27, 60, 6);
    
    ctx.restore();
  }
  
  function drawIntroTrump(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Trump figure (simplified)
    // Suit
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(-15, 15, 30, 60);
    
    // Shirt
    ctx.fillStyle = '#d8e6ff';
    ctx.fillRect(-12, 18, 24, 36);
    
    // Tie
    ctx.fillStyle = '#e02424';
    ctx.fillRect(-3, 24, 6, 28);
    
    // Head/face
    ctx.fillStyle = '#ffaa66';
    ctx.fillRect(-15, -15, 30, 30);
    
    // Hair
    ctx.fillStyle = '#ffdd44';
    ctx.fillRect(-18, -24, 36, 15);
    
    // Eyes
    ctx.fillStyle = '#111';
    ctx.fillRect(-9, -3, 3, 3);
    ctx.fillRect(6, -3, 3, 3);
    
    // Mouth
    ctx.fillStyle = '#c2185b';
    ctx.fillRect(-6, 6, 12, 3);
    
    ctx.restore();
  }

  // Initialize intro screen
  initIntro();
  
  // Initialize audio system
  initAudio();
  
  // SCENE_ROUTING_STARTGAME (START)
  function startGame(){
    const introEl = document.getElementById('intro');
    if (introEl) introEl.style.display = 'none';
    scene = 'greenland';
    resetGreenland();
    scheduleHeliIntro('Perfect landing! Welcome to Greenland!');
  }
// SCENE_ROUTING_STARTGAME (END)
  window.startGolf = function(entry, opts){
    if (entry && typeof entry === 'object' && !Array.isArray(entry) && !opts){
      opts = entry;
      entry = null;
    }

    if (typeof entry === 'string'){
      const key = entry;
      let loader;
      if (key === 'course-mar-a-lago' && typeof window.__ensureGolfSvgCourse === 'function'){
        try {
          loader = window.__ensureGolfSvgCourse();
        } catch(err){
          console.error('Failed to schedule SVG course load', err);
          loader = Promise.resolve(loadGolfCourseFromDOM(key));
        }
      } else {
        loader = Promise.resolve(loadGolfCourseFromDOM(key));
      }

      loader.then(course => {
        if (course) GOLF.course = course;
        golfStartCourse(opts);
      }).catch(err => {
        console.error('Failed to load golf course', err);
        try {
          const fallback = loadGolfCourseFromDOM(key);
          if (fallback) {
            GOLF.course = fallback;
            golfStartCourse(opts);
            return;
          }
        } catch(_){ }
        try { addCaption(W/2, H/2, 'Golf course data mangler', 1800); } catch(_){ }
      });
      return;
    }

    if (!GOLF.course && typeof window.__ensureGolfSvgCourse === 'function'){
      let handled = false;
      try {
        window.__ensureGolfSvgCourse().then(course => {
          if (course) GOLF.course = course;
          if (!handled) { handled = true; golfStartCourse(opts); }
        }).catch(err => {
          console.error('Failed to forberede golfbane', err);
          if (!handled) { handled = true; golfStartCourse(opts); }
        });
        return;
      } catch(err){
        console.error('Failed to queue SVG course promise', err);
      }
    }

    golfStartCourse(opts);
  };

  // Add click handlers to intro UI
  const introEl = document.getElementById('intro');
  if (introEl) {
    introEl.addEventListener('click', e => {
      if (scene === 'intro') startGame();
    });
  }
  const startBtn = document.getElementById('start-btn');
  if (startBtn) {
    startBtn.addEventListener('click', e => { e.stopPropagation(); startGame(); });
    startBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); startGame(); } });
  }

  function addSafe(sceneKey,id){ const S = sceneKey==='greenland'?GL:sceneKey==='oval'?OV:sceneKey==='kremlin'?KR:EP; if (!S._safe) S._safe=new Set(); if (S._safe.has(id)) return; S._safe.add(id); GS.cleared[sceneKey]++; renderAreas2(); }
  function gameOver(text){ 
    GS.over=true; 
    GS.overText=text;
    SFX.achievement();
  }

  // Cause-based game over (no doom mechanic)
  const GO = { cause: null, timer: null, pending:false, title:null, subtitle:null };
  function gameOverCause(cause, opts){
    const delayMs = (opts && typeof opts.delayMs==='number') ? opts.delayMs : 900; // small delay by default
    GO.cause = cause || 'generic';
    GO.title = (opts && opts.title) || null;
    GO.subtitle = (opts && opts.subtitle) || null;
    if (GO.timer) { try { clearTimeout(GO.timer); } catch(_){} GO.timer=null; }
    GO.pending = true;
    GO.timer = setTimeout(() => {
      GS.overMode = 'go_' + GO.cause;
      GS.over = true;
      GS.overText = '';
      GO.pending = false; GO.timer=null;
      SFX.achievement();
    }, Math.max(0, delayMs));
  }
  
  function determineEnding() {
    const cleared = Object.values(GS.cleared).filter(v=>v>=GS.needPerArea).length;
    const metteRel = RELATIONSHIPS.mette;
    const putinRel = RELATIONSHIPS.putin;
    const totalInventory = inventory.length;
    
    // Calculate relationship averages
    const metteAvg = (metteRel.respect + metteRel.trust - metteRel.fear) / 3;
    const putinAvg = (putinRel.respect + putinRel.trust - putinRel.fear) / 3;
    
    // Check for achievements (no time-based achievements)
    if (metteAvg >= 70 && putinAvg >= 70) GS.achievements.perfectDiplomat = true;
    if (totalInventory >= 10) GS.achievements.collector = true;
    if (tweetCount >= 5) GS.achievements.twitterAddict = true;
    
    // Count achievements for ending bonuses
    const achievementCount = Object.values(GS.achievements).filter(Boolean).length;
    
    // Multiple ending scenarios
    if (cleared >= 3) {
      // Perfect completion endings
      if (GS.achievements.perfectDiplomat) {
        return 'DIPLOMATIC MASTERPIECE!\n🤝 Greenland acquired through mutual respect.\n☮️ World peace achieved!\n🎖️ Perfect Diplomat';
      } else if (achievementCount >= 3) {
        return 'TREMENDOUS SUCCESS!\n🎯 Greenland deal complete!\n🏅 Multiple achievements unlocked!\n⭐ The Art of Excellence!';
      } else if (metteAvg >= 60 || putinAvg >= 60) {
        return 'TREMENDOUS SUCCESS!\n🤝 Greenland deal complete.\n💪 Strong relationships forged!';
      } else {
        return 'DEAL CLOSED!\n🏢 Greenland acquired through determination.\n📘 The Art of the Deal!';
      }
    } else if (cleared >= 2) {
      // Standard success endings
      if (GS.achievements.collector) {
        return 'COLLECTOR\'S TRIUMPH!\n🗃️ Strategic resource mastery!\n💎 Tremendous acquisitions!\n🏪 Ultimate dealmaker!';
      } else if (metteAvg >= 50 && putinAvg >= 50) {
        return 'DIPLOMATIC VICTORY!\n⚖️ Survived with honor intact.\n🤝 All relationships preserved!';
      } else {
        return 'You survived the day!\n💪 A hard-fought victory.';
      }
    } else if (cleared >= 1) {
      // Partial success endings  
      if (GS.achievements.twitterAddict) {
        return 'SOCIAL MEDIA PRESIDENT!\n📱 Twitter mastery achieved!\n📢 Message delivered worldwide!\n⚠️ Minimal other progress...';
      } else if (metteAvg <= 20 && putinAvg <= 20) {
        return 'BRIDGES BURNED!\n🔥 Survived, but diplomatic disaster.\n😞 Very sad relationships.\n💔 Tremendous damage done.';
      } else {
        return 'NARROW ESCAPE!\n😅 Minimal progress made.\n📈 Must try harder next time.';
      }
    } else {
      // Failure endings (no timer-based failure)
      return 'TOTAL FAILURE!\n❌ No progress made anywhere.\n😞 Very disappointing performance!\n🚫 Sad!';
    }
  }
  
  function checkWin(){ 
    const endingText = determineEnding();
    gameOver(endingText);
  }

  function spriteShadow(x,y,w=40,h=10,a=0.2){ ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(x,y,w,h,0,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  // Colored speech bubbles by speaker: 'trump' | 'mette' | 'bear' | 'aide' | 'default'
  // Wrap helper: splits text at word boundaries to ~maxChars per line
  function wrapLines(text, maxChars){
    const chunks = String(text).split('\n');
    const out = [];
    chunks.forEach(chunk => {
      const words = chunk.trim().split(/\s+/).filter(Boolean);
      let line='';
      words.forEach(w=>{
        const test = line ? line + ' ' + w : w;
        if (test.length <= maxChars) line = test; else { if (line) out.push(line); line = w; }
      });
      if (line) out.push(line);
      if (words.length===0) out.push('');
    });
    return out;
  }

  function textBubble(text,x,y,right=false, speaker='default', yOffset=0){
    const pad = GAME_CONSTANTS.UI.BUBBLE_PADDING; 
    ctx.font=`${GAME_CONSTANTS.UI.BUBBLE_FONT_SIZE*CFG.SCALE}px/1.2 system-ui`;
    const lines = wrapLines(text, 30);
    const lineH = GAME_CONSTANTS.UI.BUBBLE_LINE_HEIGHT*CFG.SCALE;
    const w = Math.max(80, Math.max(...lines.map(ln=>ctx.measureText(ln).width)) + pad*2);
    const h = (lines.length*lineH + 8);
    const bx = right? x - w - GAME_CONSTANTS.UI.BUBBLE_TAIL_OFFSET : x + GAME_CONSTANTS.UI.BUBBLE_TAIL_OFFSET,
          by = y - GAME_CONSTANTS.UI.BUBBLE_Y_OFFSET*CFG.SCALE + yOffset;
    // palette from config
    const palettes = GAME_CONSTANTS.UI.BUBBLE_PALETTES || {};
    const pal = palettes[speaker] || palettes.default || { fill:'rgba(0,0,0,.7)', stroke:'rgba(255,255,255,.85)', text:'#fff', tail:'rgba(0,0,0,.7)' };
    ctx.fillStyle=pal.fill; ctx.strokeStyle=pal.stroke;
    roundRect(bx,by,w,h,8); ctx.fill(); ctx.stroke();
    ctx.fillStyle=pal.text; lines.forEach((ln,i)=>ctx.fillText(ln, bx+pad, by+lineH*(i+0.7)));
    ctx.beginPath();
    ctx.fillStyle=pal.tail;
    if (right){ ctx.moveTo(x-10,y-GAME_CONSTANTS.UI.BUBBLE_TAIL_Y*CFG.SCALE); ctx.lineTo(bx+w-6,by+h/2-4); ctx.lineTo(bx+w-6,by+h/2+4); }
    else { ctx.moveTo(x+10,y-GAME_CONSTANTS.UI.BUBBLE_TAIL_Y*CFG.SCALE); ctx.lineTo(bx+6,by+h/2-4); ctx.lineTo(bx+6,by+h/2+4); }
    ctx.closePath(); ctx.fill();
  }

  // Helper: place bubble to avoid overlap with previously placed bubbles
  function placeBubble(text, x, y, right, placedRects){
    ctx.font=`${12*CFG.SCALE}px/1.2 system-ui`;
    const pad=8;
    const lines = wrapLines(text, 30);
    const lineH = GAME_CONSTANTS.UI.BUBBLE_LINE_HEIGHT*CFG.SCALE;
    const w = Math.max(80, Math.max(...lines.map(ln=>ctx.measureText(ln).width)) + pad*2);
    const h = (lines.length*lineH + 8);
    const bx = right? x - w - 18 : x + 18;
    // Raise bubbles more the larger they are, so they don't sag downward
    let by = y - 46*CFG.SCALE - Math.max(0, (lines.length-1)) * (lineH*0.6);
    const spacing = 8*CFG.SCALE;
    let tries = 0;
    function overlaps(r1, r2){ return !(r1.x + r1.w < r2.x || r2.x + r2.w < r1.x || r1.y + r1.h < r2.y || r2.y + r2.h < r1.y); }
    let rect = {x:bx, y:by, w, h};
    while (placedRects.some(r => overlaps(rect, r)) && tries < 10){
      by -= (h + spacing);
      rect = {x:bx, y:by, w, h};
      tries++;
    }
    placedRects.push(rect);
    const base = y - 46*CFG.SCALE;
    return by - base; // yOffset for textBubble
  }

  // Generalized bubble rendering for player (identical across scenes)
  function renderPlayerBubble(n, placed) {
    if (player.speakingUntil > n) {
      let yOff = placeBubble(player.say, player.x, player.y, player.facing < 0, placed) - 60*CFG.SCALE;
      if (player.say) {
        const low = player.say.toLowerCase();
        if (low.includes('kick')) yOff -= 10*CFG.SCALE;
        if (low.startsWith('tweet:')) yOff -= 34*CFG.SCALE;
      }
      textBubble(player.say, player.x, player.y, player.facing < 0, 'trump', yOff);
    }
  }

  // Generalized NPC bubble rendering
  function renderNpcBubble(npc, n, placed, speaker = 'default', yAdjust = 0) {
    if (npc.speakingUntil > n) {
      const yOff = placeBubble(npc.say, npc.x, npc.y + yAdjust, true, placed);
      textBubble(npc.say, npc.x, npc.y + yAdjust, true, speaker, yOff);
    }
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         7. PLAYER & INVENTORY                              ║
  // ║  Player state, inventory management, HUD rendering                         ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Spiller ----------
  const player = { x: 240, y: 0, w: 26, h: 44, facing: 1, speakingUntil: 0, say: '', baseSpeedMul:1, speedMul:1, goldenShoesOn:false, tanLevel:0, capOn:false, nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, walkCycle:0, lastX:240, walking:false, selectedItem:null, goldBalance:0 };
  updatePlayerSpeedMul();
  
  // Interaction feedback system
  const interactions = new Map(); // Store active interaction effects
  
  function addInteractionFeedback(obj, type='press') {
    const key = obj.type + '_' + (obj.x || 0) + '_' + (obj.y || 0);
    interactions.set(key, {
      obj: obj,
      type: type,
      start: nowMs(),
      duration: type === 'press' ? 200 : 300
    });
  }
  
  function getInteractionOffset(obj) {
    const key = obj.type + '_' + (obj.x || 0) + '_' + (obj.y || 0);
    const interaction = interactions.get(key);
    if (!interaction) return { x: 0, y: 0 };
    
    const elapsed = nowMs() - interaction.start;
    if (elapsed > interaction.duration) {
      interactions.delete(key);
      return { x: 0, y: 0 };
    }
    
    const progress = elapsed / interaction.duration;
    if (interaction.type === 'press') {
      const pushDown = Math.sin(progress * Math.PI) * 3 * CFG.SCALE;
      return { x: 0, y: pushDown };
    }
    return { x: 0, y: 0 };
  }
  let phoneBlinkUntil = 0;
  let speedBoostUntil = 0;
  let introPlayed = false, introRunning = false;
  const entryHeli = { active:false, x:0, y:0, start:0, dur:1600, targetX:0, startY:0, targetY:0, vertical:true, line:'' };
  function say(who, txt, ms){ who.speakingUntil = nowMs() + (ms||CFG.BUBBLE_TIME); who.say = txt; }

  // ---------- Inventar ----------
  const invEl = document.getElementById('inv');
  if (invEl) {
    invEl.classList.add('hidden');
    invEl.setAttribute('aria-hidden','true');
  }
  // ITEM_META loaded from game-text-data JSON block
  const MAX_SLOTS = 6;
  const inventory = []; // starts empty; filled via shop/pickups
  let collectedCoins = 0; // Global coin counter
  function addToInventory(id,name){
    const existing = inventory.find(i=>i.id===id);
    if (id==='dynamite'){
      if (existing) existing.qty = (existing.qty||0) + 5; else {
        const meta = ITEM_META[id] || {id,name,stats:null};
        inventory.push({id:meta.id, name:meta.name||name, stats:meta.stats||null, qty:5});
      }
    } else {
      if (existing) return;
      const meta = ITEM_META[id] || {id,name,stats:null};
      // Place new items in slot order: tan, shoes, maga, dynamite, then extras
      const order = ['tan','shoes','maga','dynamite'];
      const targetIndex = order.indexOf(meta.id);
      if (targetIndex >= 0){
        let insertAt = inventory.findIndex(it => (order.indexOf(it.id) > targetIndex) || order.indexOf(it.id) === -1);
        if (insertAt === -1) insertAt = inventory.length;
        inventory.splice(insertAt, 0, {id:meta.id, name:meta.name||name, stats:meta.stats||null});
      } else {
        inventory.push({id:meta.id, name:meta.name||name, stats:meta.stats||null});
      }
    }
    renderInv();
  }
  // Ensure default starting items are present (tan, cl, maga)
  function ensureDefaultInventory(){
    // default inventory now empty; shop handles purchases
  }
  // small icons for inventory
  function drawInvIcon(ctx, id){
    ctx.save();
    ctx.translate(19,14); // center-ish for 38x24 canvas
    ctx.scale(0.8,0.8);
    if (id==='tan'){ ctx.fillStyle='#8b5e3c'; ctx.fillRect(-8,6,16,10); ctx.fillStyle='#bbb'; ctx.fillRect(-6,2,12,4); ctx.fillStyle='#ddd'; ctx.fillRect(-2,-2,4,4); }
    else if (id==='shoes'){
      // Golden sneaker with blue cuff and red stripe
      ctx.fillStyle='#f5d36a'; ctx.fillRect(-14,6,28,10);
      ctx.fillStyle='#b88a1d'; ctx.fillRect(-14,14,28,3);
      ctx.fillStyle='#fff'; ctx.fillRect(-14,16,28,2);
      ctx.fillStyle='#ff3b2f'; ctx.fillRect(2,8,10,3);
      ctx.fillStyle='#1e4fbf'; ctx.fillRect(6,2,8,6);
      ctx.fillStyle='#ffd700'; ctx.fillRect(7,3,2,2); ctx.fillRect(11,3,2,2);
      ctx.fillRect(9,5,2,2);
    }
    else if (id==='maga'){ ctx.fillStyle='#c22'; ctx.fillRect(-12,6,24,8); ctx.fillRect(-10,0,20,6); ctx.fillStyle='#a00'; ctx.fillRect(2,2,4,2); }
    else if (id==='dynamite'){ 
      // Two narrow red sticks side by side with black bands
      ctx.fillStyle='#d32f2f'; ctx.fillRect(-8,0,6,16); // left stick
      ctx.fillStyle='#d32f2f'; ctx.fillRect(2,0,6,16); // right stick
      ctx.fillStyle='#333'; ctx.fillRect(-8,4,6,2); // left black band
      ctx.fillStyle='#333'; ctx.fillRect(2,4,6,2); // right black band
      ctx.fillStyle='#333'; ctx.fillRect(-8,10,6,2); // left bottom band
      ctx.fillStyle='#333'; ctx.fillRect(2,10,6,2); // right bottom band
    }
    else if (id && id.startsWith('stat')){ ctx.fillStyle='#d4af37'; ctx.fillRect(-6,-2,12,12); ctx.fillStyle='#8a6b2f'; ctx.fillRect(-8,10,16,4); }
    else { ctx.fillStyle='#999'; ctx.fillRect(-8,2,16,12); }
    ctx.restore();
  }
  function renderInv(){
    if (!invEl) return;
    invEl.innerHTML='';
    // desired slot order: known item types first, then extras, then placeholders to MAX_SLOTS
    const slotIds = Object.keys(ITEM_META);
    let rendered = 0;
    // render fixed placeholders or filled slots for known items
    slotIds.forEach(id => {
      const item = inventory.find(it=>it.id===id) || null;
      const isSelected = player.selectedItem === id;
      const d=document.createElement('div'); 
      d.className='slot' + (item? '' : ' empty');
      // Add selected highlight
      if (isSelected) {
        d.style.border = '2px solid #ffff00';
        d.style.backgroundColor = 'rgba(255,255,0,0.2)';
        d.style.boxShadow = '0 0 10px rgba(255,255,0,0.5)';
      }
      const c=document.createElement('canvas'); c.className='slotcvs';
      // draw all text inside the canvas for reliability
      const pxW = 62, pxH = 50, DPRui = Math.max(1, Math.floor((window.devicePixelRatio||1)));
      c.width = pxW*DPRui; c.height = pxH*DPRui; c.style.width=pxW+'px'; c.style.height=pxH+'px';
      d.appendChild(c); invEl.appendChild(d);
      const ictx=c.getContext('2d');
      ictx.setTransform(DPRui,0,0,DPRui,0,0);
      paintSlot(ictx, item);
      rendered++;
    });
    // render any extra, unknown items after the fixed slots
    inventory.filter(it=>!ITEM_META[it.id]).forEach(it => {
      const d=document.createElement('div'); d.className='slot';
      const c=document.createElement('canvas'); c.className='slotcvs';
      const pxW = 62, pxH = 50, DPRui = Math.max(1, Math.floor((window.devicePixelRatio||1)));
      c.width = pxW*DPRui; c.height = pxH*DPRui; c.style.width=pxW+'px'; c.style.height=pxH+'px';
      d.appendChild(c); invEl.appendChild(d);
      const ictx=c.getContext('2d'); ictx.setTransform(DPRui,0,0,DPRui,0,0); paintSlot(ictx, it);
      rendered++;
    });
    // fill remaining placeholders to MAX_SLOTS
    while (rendered < MAX_SLOTS){
      const d=document.createElement('div'); d.className='slot empty';
      const c=document.createElement('canvas'); c.className='slotcvs';
      const pxW = 62, pxH = 50, DPRui = Math.max(1, Math.floor((window.devicePixelRatio||1)));
      c.width = pxW*DPRui; c.height = pxH*DPRui; c.style.width=pxW+'px'; c.style.height=pxH+'px';
      d.appendChild(c); invEl.appendChild(d);
      const ictx=c.getContext('2d'); ictx.setTransform(DPRui,0,0,DPRui,0,0); paintSlot(ictx, null);
      rendered++;
    }
  }
  function paintSlot(g, item){
    // background glass
    g.fillStyle='rgba(255,255,255,.08)'; g.fillRect(0,0,62,50);
    // icon
    g.save(); g.translate(31,10); g.scale(0.6,0.6);
    if (item) {
      // reuse icon shapes
      if (item.id==='tan'){ g.fillStyle='#8b5e3c'; g.fillRect(-8,6,16,10); g.fillStyle='#bbb'; g.fillRect(-6,2,12,4); g.fillStyle='#ddd'; g.fillRect(-2,-2,4,4); }
      else if (item.id==='shoes'){
        g.fillStyle='#f5d36a'; g.fillRect(-16,4,32,12);
        g.fillStyle='#b88a1d'; g.fillRect(-16,14,32,4);
        g.fillStyle='#fff'; g.fillRect(-16,18,32,2);
        g.fillStyle='#ff3b2f'; g.fillRect(2,6,12,3);
        g.fillStyle='#1e4fbf'; g.fillRect(6,0,10,6);
        g.fillStyle='#ffd700'; g.fillRect(7,1,3,2); g.fillRect(12,1,3,2); g.fillRect(9,3,3,2);
        g.fillStyle='#d19b1a'; g.fillRect(-12,8,4,4); g.fillRect(-6,8,4,4); g.fillRect(20,8,4,4); // eyelets
      }
      else if (item.id==='maga'){ g.fillStyle='#c22'; g.fillRect(-12,6,24,8); g.fillRect(-10,0,20,6); g.fillStyle='#a00'; g.fillRect(2,2,4,2); }
      else if (item.id==='dynamite'){ 
        // Two red sticks (match in-world fallback)
        g.fillStyle='#d32f2f'; g.fillRect(-8,0,6,16); g.fillRect(2,0,6,16);
        g.fillStyle='#333'; g.fillRect(-8,4,6,2); g.fillRect(2,4,6,2);
        g.fillStyle='#333'; g.fillRect(-8,10,6,2); g.fillRect(2,10,6,2);
      }
      else { g.fillStyle='#999'; g.fillRect(-8,2,16,12); }
    } else {
      g.globalAlpha=.6; g.fillStyle='#bbb'; g.fillRect(-10,2,20,12); g.globalAlpha=1;
    }
    g.restore();
    // text lines
    g.fillStyle='#fff'; g.font='bold 8px system-ui'; g.textAlign='center';
    let name = item ? (item.name + (isEquipped(item.id)? ' ✓':'')) : 'Tom';
    if (item && item.id==='dynamite' && item.qty){ name += ' x'+item.qty; }
    g.fillText(name, 31, 28);
    // stats split across two lines
    const statsFull = item && item.stats ? statString(item.stats) : '—';
    const parts = statsFull.split(/\s+/);
    const mid = Math.ceil(parts.length/2);
    const line1 = parts.slice(0, mid).join(' ');
    const line2 = parts.slice(mid).join(' ');
    g.font='7px system-ui'; g.globalAlpha=.95; g.fillText(line1,31,36);
    if (line2){ g.globalAlpha=.9; g.font='6px system-ui'; g.fillText(line2,31,43); }
    g.globalAlpha=1; g.textAlign='left';
    g.globalAlpha=1; g.textAlign='left';
  }
  function statString(stats){
    return Object.entries(stats).map(([k,v])=> (v>=0? '+'+v : v)+' '+k).join(' ');
  }
  function toggleInventory(){
    if (!invEl) return;
    const nowHidden = invEl.classList.toggle('hidden');
    invEl.setAttribute('aria-hidden', nowHidden ? 'true' : 'false');
    if (!nowHidden){ try { invEl.scrollTop = 0; } catch(_){}
    }
    renderInv();
  }

  // equipped flags
  function isEquipped(id){
    if (id==='shoes') return !!player.goldenShoesOn;
    if (id==='tan') return (player.tanLevel||0) > 0;
    if (id==='maga') return !!player.capOn;
    return false;
  }

  // ---------- HUD ----------
  const hudEl = document.getElementById('hud');
  let hudToast = null;
  function renderHUD(){
    if (!hudEl) return;
    hudEl.innerHTML = '';
    // Lives first for prominence
    addLivesChip(GS.lives);
    // Gold bar counter with custom icon just under lives
    const totalCoins = GL.coins.length + OV.coins.length + KR.coins.length;
    addGoldBarChip(player.goldBalance || 0, totalCoins);
    addChip('💰 ' + (player.goldBalance || 0));
    // Cap icon
    if (player.capOn) addChip('🧢');
    // Nobel medal
    if (GS.nobelAwarded) addChip('🏅 Nobel');
    // Speed timer chip
    const now = nowMs();
    if (player.goldenShoesOn) addChip('👟 x2');
    if (speedBoostUntil > now){ const rem = Math.max(0, Math.ceil((speedBoostUntil - now)/1000)); addChip('Tempo '+rem+'s'); }
  }
  function addChip(text){ const s=document.createElement('span'); s.className='chip'; s.textContent=text; hudEl.appendChild(s); }
  
  function drawGoldBarHUDIcon(canvasEl, x, y) {
    const ctx = canvasEl.getContext('2d');
    ctx.save();
    ctx.translate(x, y);
    
    // HUD-sized gold bar with "GOLD" text (larger than in-game version)
    // Bottom/side shadow (darker gold)
    ctx.fillStyle='#cc9900';
    ctx.fillRect(0, 4, 24, 12); // bottom part
    ctx.fillRect(20, 2, 4, 10); // right side edge
    
    // Main body (bright gold)
    ctx.fillStyle='#ffd700';
    ctx.fillRect(0, 2, 20, 10);
    
    // Top surface highlight (lighter gold)
    ctx.fillStyle='#ffed4e';
    ctx.fillRect(0, 2, 20, 5); // top surface
    ctx.fillRect(0, 0, 3, 3);  // left edge highlight
    
    // "GOLD" text embossed on HUD icon
    ctx.fillStyle='#b8860b'; // darker gold for text
    ctx.font='bold 8px system-ui';
    ctx.textAlign='center';
    ctx.fillText('GOLD', 10, 8);
    ctx.textAlign='left';
    
    ctx.restore();
  }
  
  function addGoldBarChip(count, total) {
    const s = document.createElement('span');
    s.className = 'chip';
    s.style.display = 'inline-flex';
    s.style.alignItems = 'center';
    s.style.gap = '4px';
    
    // Create canvas for gold bar icon
    const iconCanvas = document.createElement('canvas');
    iconCanvas.width = 24;
    iconCanvas.height = 14;
    iconCanvas.style.verticalAlign = 'middle';
    
    // Draw gold bar icon
    drawGoldBarHUDIcon(iconCanvas, 1, 1);
    
    s.appendChild(iconCanvas);
    s.appendChild(document.createTextNode(`${count}/${total}`));
    hudEl.appendChild(s);
  }

  function drawTrumpHeadHUDIcon(ctx, width, height) {
    ctx.save();
    ctx.clearRect(0, 0, width, height);
    ctx.imageSmoothingEnabled = false;

    const baseW = 32;
    const baseH = 30;
    const offsetX = (width - baseW) / 2;
    const offsetY = (height - baseH) / 2;
    ctx.translate(offsetX, offsetY);

    // Drop shadow for depth
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(8, 24, 18, 4);

    // Hair base and highlights
    ctx.fillStyle = '#f4c542';
    ctx.fillRect(6, 0, 20, 9);
    ctx.fillRect(4, 3, 4, 7);
    ctx.fillRect(24, 3, 4, 7);
    ctx.fillStyle = '#ffe578';
    ctx.fillRect(8, 1, 16, 3);
    ctx.fillStyle = '#d99d32';
    ctx.fillRect(6, 6, 20, 3);

    // Face
    ctx.fillStyle = '#ffdbb2';
    ctx.fillRect(8, 8, 16, 14);
    ctx.fillStyle = '#f7c99a';
    ctx.fillRect(8, 8, 16, 5);

    // Ears
    ctx.fillStyle = '#f7c99a';
    ctx.fillRect(6, 12, 2, 6);
    ctx.fillRect(24, 12, 2, 6);

    // Brows
    ctx.fillStyle = '#d2963c';
    ctx.fillRect(10, 12, 5, 1);
    ctx.fillRect(17, 12, 5, 1);

    // Eyes
    ctx.fillStyle = '#1f1f1f';
    ctx.fillRect(11, 14, 3, 2);
    ctx.fillRect(18, 14, 3, 2);
    ctx.fillStyle = '#fff';
    ctx.fillRect(12, 14, 1, 1);
    ctx.fillRect(19, 14, 1, 1);

    // Nose
    ctx.fillStyle = '#e7a873';
    ctx.fillRect(15, 16, 3, 5);

    // Mouth
    ctx.fillStyle = '#9a2b38';
    ctx.fillRect(13, 20, 8, 2);
    ctx.fillStyle = '#f3969c';
    ctx.fillRect(13, 20, 8, 1);

    // Chin shading
    ctx.fillStyle = '#e7b789';
    ctx.fillRect(10, 22, 12, 2);

    // Suit
    ctx.fillStyle = '#0d1f38';
    ctx.fillRect(6, 22, 20, 8);
    ctx.fillStyle = '#102849';
    ctx.fillRect(6, 22, 6, 8);
    ctx.fillRect(20, 22, 6, 8);

    // Shirt and tie
    ctx.fillStyle = '#f9f9ff';
    ctx.fillRect(12, 22, 8, 4);
    ctx.fillStyle = '#b91824';
    ctx.fillRect(15, 22, 4, 8);
    ctx.fillStyle = '#d12b38';
    ctx.fillRect(15, 22, 4, 4);

    ctx.restore();
  }

  function addLivesChip(lives){
    const s = document.createElement('span');
    s.className = 'chip life-chip';
    s.style.display = 'inline-flex';
    s.style.alignItems = 'center';
    s.style.gap = '8px';
    const icon = document.createElement('canvas');
    const iconW = 40;
    const iconH = 36;
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    icon.width = iconW * dpr;
    icon.height = iconH * dpr;
    icon.style.width = iconW + 'px';
    icon.style.height = iconH + 'px';
    const iconCtx = icon.getContext('2d');
    iconCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    drawTrumpHeadHUDIcon(iconCtx, iconW, iconH);
    s.appendChild(icon);
    const livesLabel = document.createElement('strong');
    livesLabel.textContent = 'x ' + (lives|0);
    s.appendChild(livesLabel);
    hudEl.appendChild(s);
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         8. SCENE DEFINITIONS                               ║
  // ║  Greenland (GL), Oval Office (OV), Kremlin (KR), Epstein (EP), Golf        ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Scener ----------

  const GL = {
    state: { flagPlanted:false, bearGone:false, hasTweeted:false, glaciersBlown:false, hasSeenGlaciers:false, mineFlagPlanted:false },
    mine:  {x: 520, y: 0, w:36, h:24, type:'mine'},
    flag:  null,
    bear:  {x: 760, y: 0, w:70, h:40, type:'bear', alive:true, hp:2, speakingUntil:0, say:'', angry:false, chasing:false, speed:100, facing:1},
    mette: {x: 980, y: 0, w:26, h:44, type:'mette', speakingUntil:0, say:''},
    rig:   {x: 380, y: 0, w:30, h:40, type:'rig'},
    heli:  {x: 160, y: 0, w:120, h:42, type:'heli'},
    coins: [], // Mario-style collectible gold bars
    // Interactive glaciers in background
    glaciers: [
      {x: 120, y: 0, w:240, h:360, type:'glacier', blown:false},
      {x: 760, y: 0, w:300, h:420, type:'glacier', blown:false}
    ],
    // pickups (now provided via shop)
    items: [],
    shop: { x: 1120, y: 0, w: 260, h: 160, type:'shop' }
  };

  const OV = {
    door: {x: 140, y:0, w:40, h:80, type:'door'},
    aide: {x: 720, y:0, w:24, h:44, type:'aide', speakingUntil:0, say:''},
    heli: {x: 160, y:0, w:120, h:42, type:'heli'},
    yes:  {x: 980, y:0, w:26, h:44, type:'yes', speakingUntil:0, say:''},
    buttons: [], // desk buttons (Ja/Nej/Surprise)
    coins: [], // Mario-style collectible gold bars
    screen: { active:null, feed:[] }, // wall screen state
    shelfLoot: [], // extra statues stolen from Kremlin to display
    // Presidential Decisions mini-game state
    decisions: {
      active: false,           // Is the mini-game running?
      phase: 'walking',        // 'walking' | 'waiting' | 'guest' | 'answered' | 'complete' | 'failed'
      currentGuestIndex: -1,   // Which guest (0-2)
      correctAnswers: 0,       // How many correct so far
      guestX: 0,               // Guest animation X position
      guestTargetX: 0,         // Where guest walks to
      answerFeedback: null,    // {correct:bool, text:string, until:timestamp}
      trumpAtDesk: false,      // Has Trump reached the desk?
      trumpTargetX: 0,         // Where Trump walks to (behind desk)
      guestOrder: []           // Randomized order of guest indices
    },
    guest: {x: 0, y: 0, w: 26, h: 44, type: 'guest', visible: false, speakingUntil: 0, say: ''} // Current guest NPC
  };

  // Kremlin scene (Putin meeting)
  const KR = {
    door: {x: 120, y:0, w:40, h:80, type:'door'},
    putin:{x: 680, y:0, w:24, h:44, type:'putin', speakingUntil:0, say:''},
    heli: {x: 160, y:0, w:120, h:42, type:'heli'},
    statues: [], // will be set in resetKremlin
    ukraineFlag: null, // 'american' or 'russian' - which flag is planted on Ukraine
    camera: {x: 0, y: 0, angle: 0, sweepStart: 0, discovered: false}, // security camera (legacy, kept for compatibility)
    cameras: [], // array of security cameras
    coins: [], // Mario-style collectible gold bars
    nobelPending: false
  };

  // ---------- Epstein Files Scene ----------  
  const EP = {
    door: {x: 120, y:0, w:40, h:80, type:'door'},
    papers: [],
    currentLine: 0,
    scrollSpeed: 1.0,
    scrollY: 0,
    timeElapsed: 0,
    missedTrumps: 0,
    foundTrumps: 0,
    gameActive: false,
    gameStartTime: 0,
    trumpLocations: [], // {x,y,width,height,docIndex,lineInDoc,kind:'trump'|'protected'}
    generatedDocs: false,
    totalTrumpTargets: 10,
    missesAllowed: 2,
    failedByProtected: false,
    protectedClicks: 0,
    protectedLimit: 1, // Fail after this many protected clicks
    timeLimitMs: 20000,
    protectedNames: ['Bill Clinton','Bill Gates'],
    toasts: [], // {x,y,text,color,start,ttl}
    crosses: [], // {x,y,w,h,start,ttl}
    assistUntil: 0,
    mt: new Map(), // measureText cache for this scene
    visibleDoc: 1,
    paused: false,
    finalArt: { redacted: false, redactStart: 0 }, // redactStart = timestamp when sharpie animation began
    finalArtRect: null,
    artHeightPx: 0,
    stopAtArt: true,
    holdAtArtMargin: 40, // px (scaled) from top of paper where art should stop
    atArtHold: false,
    endingPending: false,
    // Guitar Hero style redacting
    hitZoneY: 0.5,       // Relative position of hit zone center (0-1) within paper
    hitZoneHeight: 60,   // Height of hit zone in pixels (scaled)
    artHitZoneRel: 0.33, // Relative Y in final art for hit zone center (breast area)
    markerAnim: null,    // Active marker animation: {x, y, width, startTime, duration}
    lastRedactTime: 0    // Cooldown to prevent double-hits
  };
// SCENE_GOLF (START)
  // ---------- Mar-a-Lago Mini-Putt Scene ----------
  const GOLF = {
    course: null,
    holeIndex: 0,
    strokes: [],
    ball: { x: 0, y: 0, r: 10, vx: 0, vy: 0 },
    state: 'idle', // 'arrival' | 'approach' | 'intro' | 'aim' | 'rolling' | 'charging' | 'waiting' | 'banner' | 'scorecard'
    aim: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 },
    charge: { active: false, dirX: 0, dirY: 0, power: 0 },
    banner: null,
    penaltyFlashUntil: 0,
    scorecard: null,
    lastUpdate: 0,
    hole: null,
    courseName: 'Mar-a-Lago Mini-Putt',
    aimAngle: 0,
    aimPower: 0,
    aimPreviewLength: 70,
    previewSpeed: 0,
    _finishedHole: false,
    view: { scale: 1, ox: 0, oy: 0 },
    playerStand: { x: 0, y: 0 },
    bidenAvatar: { x: 0, y: 0 },
    overlays: new Map(),
    overlayRails: new Map(),
    arrival: { active: false },
    approach: { x: 0, y: 0, facing: 1, moving: false },
    clubPicked: false,
    parkedHeli: null, // { x, y } - helikopter position efter landing
    walkCycle: 0,
    captions: [],
    bidenSpeech: null,
    bidenSayNext: 0,
    captionCounter: 0,
    opts: { versus: true },
    totalStrokes: 0,
    strokesThisHole: 0,
    holeBooked: false,
    turn: 'player',
    introActive: false,
    introDismissReady: false,
    introShown: false,
    biden: null,
    bidenPlan: null,
    bidenTimer: null
  };

  const GOLF_MAX_DRAG = 260;
  const GOLF_MIN_SPEED = 140;
  const GOLF_MAX_SPEED = 780;
  const GOLF_POWER_EXP = 1.18;
  const CUP_SPEED_THRESH = 20; // px/s max speed to count as holed
  const MAGNET_RANGE = 18; // px beyond cup radius where pull begins
  const MAGNET_SPEED = 220; // apply magnet only below this speed
  const MAGNET_STRENGTH = 1200; // px/s^2 toward cup center
  const GOLF_HELI_SCALE = 1.0;
  const GOLF_PREVIEW_BASE = 70;
  const GOLF_PREVIEW_EXTRA = 190;
  const GOLF_KEY_CHARGE_RATE = 1.2; // per second normalised charge

  function isNum(v){ return typeof v === 'number' && !Number.isNaN(v); }

  function golfComputeTeePosition(){
    const hole = GOLF.hole;
    if (!hole) return { x: GOLF.ball.x, y: GOLF.ball.y };
    const teeRect = hole.teeRect || { x: (hole.spawn?.x||hole.tee?.x||150) - 20, y: (hole.spawn?.y||hole.tee?.y||150) - 20, w: 40, h: 40 };
    const spawn = hole.spawn || {};
    let x = isNum(spawn.x) ? spawn.x : teeRect.x + teeRect.w/2;
    let y = isNum(spawn.y) ? spawn.y : teeRect.y + teeRect.h/2;
    const minX = teeRect.x + GOLF.ball.r;
    const maxX = teeRect.x + teeRect.w - GOLF.ball.r;
    const minY = teeRect.y + GOLF.ball.r;
    const maxY = teeRect.y + teeRect.h - GOLF.ball.r;
    return {
      x: clamp(x, minX, maxX),
      y: clamp(y, minY, maxY)
    };
  }

  function golfResetBallToTee(opts){
    const penalty = opts && opts.penalty;
    const caption = opts && opts.caption;
    const hole = GOLF.hole;
    const spawn = hole?.spawn || hole?.tee || {};
    const teeRect = hole?.teeRect || { x: (spawn.x||150) - 24, y: (spawn.y||150) - 24, w: 48, h: 48 };
    const cx = teeRect.x + teeRect.w/2;
    const cy = teeRect.y + teeRect.h/2;
    GOLF.ball.x = cx;
    GOLF.ball.y = cy;
    GOLF.ball.vx = 0;
    GOLF.ball.vy = 0;
    GOLF.turn = 'player';
    GOLF.aimAngle = -Math.PI/2;
    GOLF.aimPower = 0;
    GOLF.aimPreviewLength = GOLF_PREVIEW_BASE;
    GOLF.aim.active = false;
    if (!GOLF.introActive) GOLF.state = 'aim';
    if (penalty){
      GOLF.strokesThisHole += 1;
      GOLF.strokes[GOLF.holeIndex] = GOLF.strokesThisHole;
    }
    const label = caption || (penalty ? 'Drop (+1)' : 'TEE');
    if (label) addCaption(cx, cy - 24, label, 1100);
  }

  function golfUpdateAimFromPointer(px, py){
    const dx = GOLF.ball.x - px;
    const dy = GOLF.ball.y - py;
    const drag = Math.hypot(dx, dy);
    const power = Math.min(drag / GOLF_MAX_DRAG, 1);
    GOLF.aimAngle = Math.atan2(dy, dx);
    GOLF.aimPower = power;
    GOLF.aimPreviewLength = GOLF_PREVIEW_BASE + power * GOLF_PREVIEW_EXTRA;
  }

  function golfStrike(angle, powerNorm){
    const ratio = clamp(powerNorm, 0, 1);
    const speed = GOLF_MIN_SPEED + Math.pow(ratio, GOLF_POWER_EXP) * (GOLF_MAX_SPEED - GOLF_MIN_SPEED);
    GOLF.ball.vx = Math.cos(angle) * speed;
    GOLF.ball.vy = Math.sin(angle) * speed;
    GOLF.state = 'rolling';
    GOLF.turn = 'player_rolling';
    golfAddStroke();
    if (GOLF.opts?.versus !== false && GOLF.biden) golfSpeakBiden();
    GOLF.aimPower = 0;
    GOLF.aimPreviewLength = GOLF_PREVIEW_BASE;
  }

  function loadGolfCourseFromDOM(id){
    const el = document.getElementById(id||'course-mar-a-lago');
    if (!el) return null;
    try {
      return JSON.parse(el.textContent.trim());
    } catch(err){
      console.warn('Failed to parse golf course data', err);
      return null;
    }
  }

  // ---------- Lottie Parser for Golf Courses ----------
  // Parses Lottie JSON (from After Effects) and extracts hole data
  function parseLottieGolfHole(lottieData){
    if (!lottieData || !lottieData.layers) return null;
    const w = lottieData.w || 960;
    const h = lottieData.h || 540;
    const result = {
      bounds: { x: 0, y: 0, w, h },
      walls: [],
      surfaces: []
    };

    for (const layer of lottieData.layers){
      const nm = (layer.nm || '').toLowerCase();
      const pos = layer.ks?.p?.k || [0, 0, 0];
      const anchor = layer.ks?.a?.k || [0, 0, 0];
      const scaleArr = layer.ks?.s?.k || [100, 100, 100];
      const rot = (layer.ks?.r?.k || 0) * Math.PI / 180; // rotation in radians
      const sx = scaleArr[0] / 100, sy = scaleArr[1] / 100;

      // Helper: transform local coords to world coords (with rotation)
      const toWorld = (lx, ly) => {
        const dx = (lx - anchor[0]) * sx;
        const dy = (ly - anchor[1]) * sy;
        // Apply rotation
        const rx = dx * Math.cos(rot) - dy * Math.sin(rot);
        const ry = dx * Math.sin(rot) + dy * Math.cos(rot);
        return [pos[0] + rx, pos[1] + ry];
      };
      const bezierPoint = (p0, p1, p2, p3, t) => {
        const mt = 1 - t;
        const mt2 = mt * mt;
        const t2 = t * t;
        const x = p0[0] * mt2 * mt + 3 * p1[0] * mt2 * t + 3 * p2[0] * mt * t2 + p3[0] * t2 * t;
        const y = p0[1] * mt2 * mt + 3 * p1[1] * mt2 * t + 3 * p2[1] * mt * t2 + p3[1] * t2 * t;
        return [x, y];
      };

      // Helper: get group transform offset from 'tr' item
      const getGroupTransform = (items) => {
        for (const item of items){
          if (item.ty === 'tr'){
            const p = item.p?.k || [0, 0];
            return { x: p[0], y: p[1] };
          }
        }
        return { x: 0, y: 0 };
      };

      if (nm === 'hul' || nm === 'hole' || nm === 'cup'){
        // Ellipse layer - extract center and radius
        const shapes = layer.shapes || [];
        for (const grp of shapes){
          const items = grp.it || [];
          const grpTr = getGroupTransform(items);
          for (const item of items){
            if (item.ty === 'el'){ // Ellipse
              const size = item.s?.k || [48, 48];
              const elPos = item.p?.k || [0, 0];
              const [wx, wy] = toWorld(elPos[0] + grpTr.x, elPos[1] + grpTr.y);
              result.cup = { x: wx, y: wy, r: Math.min(size[0], size[1]) / 2 };
              console.log('HOLE parsed:', { pos, anchor, grpTr, elPos, wx, wy }); // DEBUG
            }
          }
        }
      }

      if (nm === 'tee' || nm === 'spawn'){
        // Rectangle layer - extract tee area (same logic as hole)
        const shapes = layer.shapes || [];
        for (const grp of shapes){
          const items = grp.it || [];
          const grpTr = getGroupTransform(items);
          for (const item of items){
            if (item.ty === 'rc'){ // Rectangle
              const size = item.s?.k || [100, 100];
              const rcPos = item.p?.k || [0, 0];
              const [wx, wy] = toWorld(rcPos[0] + grpTr.x, rcPos[1] + grpTr.y);
              const rw = Math.abs(size[0] * sx), rh = Math.abs(size[1] * sy);
              result.teeRect = { x: wx - rw/2, y: wy - rh/2, w: rw, h: rh };
              result.spawn = { x: wx, y: wy };
              console.log('TEE parsed:', { pos, anchor, grpTr, rcPos, wx, wy, size }); // DEBUG
            }
          }
        }
      }

      // Helper: extract walls and optionally polygon from a shape layer's paths
      const extractFromShapes = (shapes, extractPoly = false) => {
        const walls = [];
        let polygon = null;
        for (const grp of shapes){
          const items = grp.it || [];
          const grpTr = getGroupTransform(items);
          let pathData = null;
          let isClosed = false;

          for (const item of items){
            if (item.ty === 'sh'){ // Shape path
              const ks = item.ks?.k || item.ks;
              pathData = { v: ks?.v || ks, i: ks?.i || [], o: ks?.o || [], c: ks?.c };
              isClosed = ks?.c ?? false;
            }
            if (item.ty === 'rc'){ // Rectangle - convert to 4 walls
              const size = item.s?.k || [100, 100];
              const rcPos = item.p?.k || [0, 0];
              const hw = Math.abs(size[0] * sx) / 2, hh = Math.abs(size[1] * sy) / 2;
              const [cx, cy] = toWorld(rcPos[0] + grpTr.x, rcPos[1] + grpTr.y);
              walls.push({ x1: cx-hw, y1: cy-hh, x2: cx+hw, y2: cy-hh }); // top
              walls.push({ x1: cx+hw, y1: cy-hh, x2: cx+hw, y2: cy+hh }); // right
              walls.push({ x1: cx+hw, y1: cy+hh, x2: cx-hw, y2: cy+hh }); // bottom
              walls.push({ x1: cx-hw, y1: cy+hh, x2: cx-hw, y2: cy-hh }); // left
              if (extractPoly){
                polygon = [[cx-hw, cy-hh], [cx+hw, cy-hh], [cx+hw, cy+hh], [cx-hw, cy+hh]];
              }
            }
            if (item.ty === 'el'){ // Ellipse - approximate as octagon
              const size = item.s?.k || [48, 48];
              const elPos = item.p?.k || [0, 0];
              const [cx, cy] = toWorld(elPos[0] + grpTr.x, elPos[1] + grpTr.y);
              const rx = Math.abs(size[0] * sx) / 2, ry = Math.abs(size[1] * sy) / 2;
              const sides = 8;
              const polyPts = [];
              for (let i = 0; i < sides; i++){
                const a1 = (i / sides) * Math.PI * 2;
                const a2 = ((i + 1) / sides) * Math.PI * 2;
                walls.push({
                  x1: cx + Math.cos(a1) * rx, y1: cy + Math.sin(a1) * ry,
                  x2: cx + Math.cos(a2) * rx, y2: cy + Math.sin(a2) * ry
                });
                polyPts.push([cx + Math.cos(a1) * rx, cy + Math.sin(a1) * ry]);
              }
              if (extractPoly) polygon = polyPts;
            }
          }

          if (pathData && Array.isArray(pathData.v)){
            const v = pathData.v;
            const iArr = pathData.i || [];
            const oArr = pathData.o || [];
            const count = v.length;
            const segCount = isClosed ? count : Math.max(0, count - 1);
            const toWorldG = (pt) => toWorld(pt[0] + grpTr.x, pt[1] + grpTr.y);
            const polyPts = [];
            for (let s = 0; s < segCount; s++){
              const n = (s + 1) % count;
              const p0 = v[s];
              const p3 = v[n];
              const o0 = oArr[s] || [0, 0];
              const i1 = iArr[n] || [0, 0];
              const c1 = [p0[0] + o0[0], p0[1] + o0[1]];
              const c2 = [p3[0] + i1[0], p3[1] + i1[1]];
              const wp0 = toWorldG(p0);
              const wp1 = toWorldG(c1);
              const wp2 = toWorldG(c2);
              const wp3 = toWorldG(p3);
              const curveMag = Math.abs(o0[0]) + Math.abs(o0[1]) + Math.abs(i1[0]) + Math.abs(i1[1]);
              const segLen = Math.hypot(wp3[0] - wp0[0], wp3[1] - wp0[1]);
              const steps = curveMag > 0.01 ? Math.min(20, Math.max(6, Math.round(segLen / 18))) : 1;
              const pts = [];
              for (let t = 0; t <= steps; t++){
                const tt = t / steps;
                pts.push(bezierPoint(wp0, wp1, wp2, wp3, tt));
              }
              for (let p = 0; p < pts.length - 1; p++){
                const a = pts[p], b = pts[p + 1];
                walls.push({ x1: a[0], y1: a[1], x2: b[0], y2: b[1] });
              }
              if (extractPoly){
                if (!polyPts.length) polyPts.push(pts[0]);
                for (let p = 1; p < pts.length; p++) polyPts.push(pts[p]);
              }
            }
            if (extractPoly && isClosed && polyPts.length) polygon = polyPts;
          }
        }
        return { walls, polygon };
      };

      if (nm === 'fairway' || nm === 'course' || nm === 'walls' || nm === 'bane'){
        const shapes = layer.shapes || [];
        const { walls, polygon } = extractFromShapes(shapes, true);
        result.walls.push(...walls);
        if (polygon){
          result.surfaces.push({ type: 'fairway', poly: polygon });
        }
      }

      if (nm.startsWith('genstand') || nm.startsWith('obstacle') || nm === 'obstacles' || nm.startsWith('forhindring')){
        const shapes = layer.shapes || [];
        const { walls, polygon } = extractFromShapes(shapes, true); // Also extract polygon for visual
        console.log('OBSTACLE parsed:', nm, 'walls:', walls.length, 'polygon:', polygon); // DEBUG
        result.walls.push(...walls);
        if (polygon){
          result.surfaces.push({ type: 'obstacle', poly: polygon });
        }
      }
    }

    console.log('PARSED LOTTIE RESULT:', JSON.stringify(result, null, 2)); // DEBUG
    return result;
  }

  // Load Lottie file from URL and parse as golf hole
  async function loadLottieGolfHole(url){
    try {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error('Failed to fetch: ' + resp.status);
      const lottie = await resp.json();
      return parseLottieGolfHole(lottie);
    } catch(err){
      console.warn('Failed to load Lottie golf hole:', err);
      return null;
    }
  }

  // Merge Lottie-parsed data into existing hole config
  function applyLottieToHole(hole, lottieData){
    if (!hole || !lottieData) return;
    if (lottieData.cup) hole.cup = lottieData.cup;
    if (lottieData.teeRect) hole.teeRect = lottieData.teeRect;
    if (lottieData.spawn) hole.spawn = lottieData.spawn;
    if (lottieData.bounds) hole.bounds = lottieData.bounds;
    if (!hole.railsFromOverlay && lottieData.walls && lottieData.walls.length){
      hole.rails = lottieData.walls; // Use walls as collision rails
    }
    if (lottieData.surfaces && lottieData.surfaces.length){
      hole.surfaces = lottieData.surfaces; // Use surfaces for fill rendering
    }
  }

  // Cache for loaded Lottie hole data
  const lottieHoleCache = new Map();

  async function golfEnsureLottieData(hole){
    if (!hole) return;
    if (hole.lottieInline){
      const key = `inline:${hole.lottieInline}`;
      if (lottieHoleCache.has(key)){
        applyLottieToHole(hole, lottieHoleCache.get(key));
        return;
      }
      const el = document.getElementById(hole.lottieInline);
      if (!el) return;
      try {
        const raw = JSON.parse(el.textContent.trim());
        const data = parseLottieGolfHole(raw);
        if (data){
          lottieHoleCache.set(key, data);
          applyLottieToHole(hole, data);
        }
      } catch(err){
        console.warn('Failed to parse inline Lottie golf hole:', err);
      }
      return;
    }
    if (!hole.lottie) return;
    const url = hole.lottie;
    if (lottieHoleCache.has(url)){
      applyLottieToHole(hole, lottieHoleCache.get(url));
      return;
    }
    const data = await loadLottieGolfHole(url);
    if (data){
      lottieHoleCache.set(url, data);
      applyLottieToHole(hole, data);
    }
  }

  function golfResetHole(index){
    if (!GOLF.course || !GOLF.course.holes[index]) return;
    GOLF.holeIndex = index;
    GOLF.hole = GOLF.course.holes[index];
    // Load Lottie data if specified (async, will apply when ready)
    golfEnsureLottieData(GOLF.hole).catch(()=>{});
    // Use PNG overlay rails when requested or when no Lottie is present
    const hasLottie = !!(GOLF.hole.lottie || GOLF.hole.lottieInline);
    if (GOLF.hole.overlay && (GOLF.hole.railsFromOverlay || !hasLottie)) {
      try { golfEnsureOverlayRails(GOLF.hole); } catch(_){}
    }
    if (typeof GOLF.strokes[index] !== 'number') GOLF.strokes[index] = 0;
    GOLF.strokesThisHole = 0;
    GOLF.holeBooked = false;
    if (GOLF.introActive){
      GOLF.state = 'intro';
      GOLF.introShown = true;
    } else if (GOLF.state !== 'scorecard') {
      GOLF.state = 'aim';
    }
    GOLF.turn = 'player';
    // Start position: spawn if inside teeRect, otherwise center of teeRect
    const spawn = GOLF.hole.spawn || GOLF.hole.tee || {};
    const teeRect = GOLF.hole.teeRect || { x: (spawn.x||150) - 24, y: (spawn.y||150) - 24, w: 48, h: 48 };
    const r = GOLF.ball.r || 10;
    const minX = teeRect.x + r, maxX = teeRect.x + teeRect.w - r;
    const minY = teeRect.y + r, maxY = teeRect.y + teeRect.h - r;
    const spawnValid = (typeof spawn.x==='number' && typeof spawn.y==='number' && spawn.x>=minX && spawn.x<=maxX && spawn.y>=minY && spawn.y<=maxY);
    const startX = spawnValid ? spawn.x : (teeRect.x + teeRect.w/2);
    const startY = spawnValid ? spawn.y : (teeRect.y + teeRect.h/2);
    GOLF.ball.x = startX;
    GOLF.ball.y = startY;
    GOLF.ball.vx = 0; GOLF.ball.vy = 0;
    addCaption(startX, startY - 24, 'TEE', 1100);

    const cup = GOLF.hole.cup || {x: startX + 60, y: startY - 60};
    GOLF.aimAngle = Math.atan2((cup.y||0) - startY, (cup.x||0) - startX);
    GOLF.state = GOLF.introActive ? 'intro' : 'aim';
    GOLF.aim.active = false;
    GOLF.charge.active = false;
    GOLF.charge.power = 0;
    // Stand positions (avatars stand near tee; balls roll independently)
    const standOffset = 84;
    const bounds = GOLF.hole.bounds || { x: 0, y: 0, w: VIRTUAL_W, h: VIRTUAL_H };
    const baseX = clamp(startX - standOffset, bounds.x + 32, bounds.x + bounds.w - 32);
    const trumpY = clamp(startY + 36, bounds.y + 36, bounds.y + bounds.h - 24);
    const bidenY = clamp(trumpY - 90, bounds.y + 36, bounds.y + bounds.h - 24);
    GOLF.playerStand = { x: baseX, y: trumpY };
    GOLF.bidenAvatar = { x: baseX, y: bidenY };
    GOLF._finishedHole = false;
    GOLF.bidenSpeech = null;
    GOLF.banner = { text: `Hole ${GOLF.hole.id}`, until: nowMs()+2600, onDone: null };
    GOLF.lastUpdate = nowMs();
    if (GOLF.opts?.versus !== false){
      const prevBiden = GOLF.biden;
      const spawnB = GOLF.hole.spawn || GOLF.hole.tee || { x: startX, y: startY };
      const teeRect = GOLF.hole.teeRect || {x: (spawnB.x||startX)-24, y: (spawnB.y||startY)-24, w: 48, h:48};
      const holePar = (GOLF.course?.par || [])[GOLF.holeIndex] || 3;
      const bidenStrokes = Math.max(2, holePar); // Biden "already played" with par strokes
      // Position Biden at the cup (he's already finished)
      const cup = GOLF.hole.cup || { x: startX + 80, y: startY - 80 };
      const bidenCupX = clamp(cup.x + 70, bounds.x + 32, bounds.x + bounds.w - 32);
      const bidenCupY = clamp(cup.y + 80, bounds.y + 36, bounds.y + bounds.h - 24);
      GOLF.bidenAvatar = { x: bidenCupX, y: bidenCupY };
      GOLF.biden = {
        ball: { x: cup.x, y: cup.y, r: GOLF.ball.r || 10, vx: 0, vy: 0, moving: false }, // Ball in cup
        strokesHole: bidenStrokes, // Already played
        total: (prevBiden?.total || 0) + bidenStrokes,
        parTarget: bidenStrokes,
        walking: false,
        sayNext: 0,
        waiting: false,
        _booked: true, // Already booked
        _finishedHole: true, // Already finished
        followDelayUntil: 0,
        teeRect
      };
      GOLF.bidenPlan = null; // No playthrough needed
      // Skip Biden's turn - go straight to player
      if (!GOLF.introActive){
        GOLF.turn = 'player';
        GOLF.state = 'aim';
      }
    } else {
      GOLF.biden = null;
      GOLF.bidenPlan = null;
    }
  }
//golf entrypoint
  function golfStartCourse(opts){
    if (opts && typeof opts === 'object'){ GOLF.opts = Object.assign({versus:true}, opts); }
    else GOLF.opts = Object.assign({versus:true}, GOLF.opts||{});
    if (!GOLF.course){
      GOLF.course = loadGolfCourseFromDOM('course-mar-a-lago');
    }
    if (!GOLF.course){ return; }
    GOLF.courseName = GOLF.course.name || 'Mini-Putt';
    GOLF.strokes = new Array(GOLF.course.holes.length).fill(0);
    GOLF.totalStrokes = 0;
    GOLF.scorecard = null;
    GOLF.captions = [];
    GOLF.banner = null;
    GOLF.clubPicked = false;
    if (GOLF.bidenTimer){ clearTimeout(GOLF.bidenTimer); GOLF.bidenTimer=null; }
    GOLF.biden = null;
    GOLF.turn = 'player';
    GOLF.introActive = true;
    GOLF.introDismissReady = false;
    GOLF.introShown = false;
    GOLF.state = 'intro';
    // Bind golf-specific pointer handlers once per scene start
    try { golfBindInput(); } catch(_){}
    golfResetHole(0);
    setTimeout(()=>{ GOLF.introDismissReady = true; }, 150);
    scene = 'golf';
    try { golfStartArrival(opts); } catch(_){}
    GS.over = false;
    GS.overMode = null;
    GS.overText = '';
  }

  // Golf pointer input binding lifecycle
  let golfInputHandlers = null;
  function golfBindInput(){
    if (golfInputHandlers) return; // already bound
    const onPointerDown = (e)=>{
      if (scene !== 'golf') return;
      const p = toCanvasCoords(e, cvs); 
      const mxs = p.x / DPR, mys = p.y / DPR;
      const mx = (mxs - (GOLF.view?.ox||0)) / (GOLF.view?.scale||1);
      const my = (mys - (GOLF.view?.oy||0)) / (GOLF.view?.scale||1);
      if (GOLF.state==='intro' || GOLF.state==='arrival' || GOLF.state==='approach'){
        return;
      }
      if (GOLF.state === 'aim'){
        const d = Math.hypot(mx - GOLF.ball.x, my - GOLF.ball.y);
        if (d <= GOLF.ball.r * 2.4){
          GOLF.aim.active = true;
          GOLF.aim.startX = GOLF.ball.x; GOLF.aim.startY = GOLF.ball.y;
          GOLF.aim.currentX = mx; GOLF.aim.currentY = my;
          try { cvs.setPointerCapture(e.pointerId); } catch(_){ }
          e.preventDefault();
        }
      }
    };
    const onPointerMove = (e)=>{
      if (scene !== 'golf' || !GOLF.aim.active) return;
      const p = toCanvasCoords(e, cvs); const mxs = p.x / DPR, mys = p.y / DPR;
      const mx = (mxs - (GOLF.view?.ox||0)) / (GOLF.view?.scale||1);
      const my = (mys - (GOLF.view?.oy||0)) / (GOLF.view?.scale||1);
      GOLF.aim.currentX = mx; GOLF.aim.currentY = my;
      const dx = GOLF.aim.startX - GOLF.aim.currentX;
      const dy = GOLF.aim.startY - GOLF.aim.currentY;
      const dist = Math.hypot(dx, dy);
      const power = Math.min(dist / GOLF_MAX_DRAG, 1);
      GOLF.aimAngle = Math.atan2(dy, dx);
      GOLF.aimPower = power;
      GOLF.previewSpeed = GOLF_MIN_SPEED + Math.pow(power, GOLF_POWER_EXP) * (GOLF_MAX_SPEED - GOLF_MIN_SPEED);
    };
    const onPointerUp = (e)=>{
      if (scene !== 'golf') return;
      if (GOLF.state === 'aim' && GOLF.aim.active){
        GOLF.aim.active = false;
        const dx = GOLF.aim.startX - GOLF.aim.currentX;
        const dy = GOLF.aim.startY - GOLF.aim.currentY;
        const dist = Math.hypot(dx, dy);
        if (dist > 6){
          const power = Math.min(dist / GOLF_MAX_DRAG, 1);
          const angle = Math.atan2(dy, dx);
          GOLF.previewSpeed = GOLF_MIN_SPEED + Math.pow(power, GOLF_POWER_EXP) * (GOLF_MAX_SPEED - GOLF_MIN_SPEED);
          golfStrike(angle, power);
        } else {
          GOLF.aimAngle = Math.atan2(GOLF.aim.currentY - GOLF.ball.y, GOLF.aim.currentX - GOLF.ball.x);
        }
      } else if (GOLF.state === 'charging'){
        golfHandleKeyUp({code:'KeyE'}, 'e');
      }
      try { cvs.releasePointerCapture(e.pointerId); } catch(_){ }
    };
    const onPointerCancel = (e)=>{
      if (scene !== 'golf') return;
      GOLF.aim.active = false;
      if (GOLF.state === 'charging'){ GOLF.state = 'aim'; GOLF.charge.active=false; }
      try { cvs.releasePointerCapture(e.pointerId); } catch(_){ }
    };
    cvs.addEventListener('pointerdown', onPointerDown);
    cvs.addEventListener('pointermove', onPointerMove);
    cvs.addEventListener('pointerup', onPointerUp);
    cvs.addEventListener('pointercancel', onPointerCancel);
    golfInputHandlers = { onPointerDown, onPointerMove, onPointerUp, onPointerCancel };
  }
  function golfUnbindInput(){
    if (!golfInputHandlers) return;
    cvs.removeEventListener('pointerdown', golfInputHandlers.onPointerDown);
    cvs.removeEventListener('pointermove', golfInputHandlers.onPointerMove);
    cvs.removeEventListener('pointerup', golfInputHandlers.onPointerUp);
    cvs.removeEventListener('pointercancel', golfInputHandlers.onPointerCancel);
    golfInputHandlers = null;
    // Ensure stable state
    GOLF.aim.active = false;
    if (GOLF.state === 'charging'){ GOLF.state = 'aim'; GOLF.charge.active = false; }
  }

  function golfAdvanceHole(){
    const next = GOLF.holeIndex + 1;
    if (GOLF.bidenTimer){ clearTimeout(GOLF.bidenTimer); GOLF.bidenTimer = null; }
    if (GOLF.biden && !GOLF.biden._booked && GOLF.biden.strokesHole >= GOLF.biden.parTarget){
      GOLF.biden.total += GOLF.biden.strokesHole;
      GOLF.biden._booked = true;
    }
    if (next >= (GOLF.course?.holes.length||0)){
      const finalize = () => {
        GOLF.state = 'scorecard';
        const total = GOLF.strokes.reduce((a,b)=>a+b,0);
        const parTotal = (GOLF.course?.par||[]).reduce((a,b)=>a+b,0);
        const joeTotal = GOLF.biden ? GOLF.biden.total : 0;
        GOLF.scorecard = {
          total,
          par: parTotal,
          joe: joeTotal,
          diff: total - (parTotal||0),
          shownAt: nowMs()
        };
        // Award golf medal if player beat Biden
        if (joeTotal > 0 && total < joeTotal) {
          awardMedal('golf');
        }
      };
      golfShowBanner('Course complete!', 2000, finalize);
      GOLF.state = 'banner';
    } else {
      golfResetHole(next);
    }
  }

  function golfSurfaceAt(x,y){
    // Default to fairway-like friction
    const DEFAULT_FRICTION = 0.989;
    if (!GOLF.hole) return DEFAULT_FRICTION;
    const { surfaces } = GOLF.hole;
    if (Array.isArray(surfaces)){
      for (let i=0;i<surfaces.length;i++){
        const surf = surfaces[i];
        if (surf && surf.poly && pointInPolygon(x,y,surf.poly)){
          if (typeof surf.friction === 'number') return surf.friction;
          // Map common surface types to tuned friction values
          const t = (surf.type||'').toLowerCase();
          if (t === 'fairway') return 0.989;
          if (t === 'sand') return 0.965;
          if (t === 'carpet' || t === 'fringe') return 0.975;
          if (t === 'marble' || t === 'green') return 0.992;
          if (t === 'rough') return 0.962;
          if (t === 'trees' || t === 'forest') return 0.91;
          if (t === 'water') return 0.935;
          return DEFAULT_FRICTION;
        }
      }
    }
    return DEFAULT_FRICTION;
  }

  function golfInPenalty(x,y){
    if (!GOLF.hole || !Array.isArray(GOLF.hole.penalties)) return null;
    for (const pen of GOLF.hole.penalties){
      if (pen && pen.poly && pointInPolygon(x,y, pen.poly)) return pen;
    }
    return null;
  }

  function golfClampBallWithinBounds(){
    if (!GOLF.hole || !GOLF.hole.bounds) return;
    const b = GOLF.hole.bounds;
    const r = GOLF.ball.r;
    GOLF.ball.x = clamp(GOLF.ball.x, b.x + r, b.x + b.w - r);
    GOLF.ball.y = clamp(GOLF.ball.y, b.y + r, b.y + b.h - r);
  }

  function golfProjectOnSegment(px, py, ax, ay, bx, by){
    const vx = bx - ax, vy = by - ay;
    const len2 = vx*vx + vy*vy || 1;
    let t = ((px-ax)*vx + (py-ay)*vy)/len2;
    t = clamp(t, 0, 1);
    return { x: ax + vx*t, y: ay + vy*t, t };
  }

  function golfReflect(normalX, normalY){
    const dot = GOLF.ball.vx*normalX + GOLF.ball.vy*normalY;
    if (dot < 0){
      const bounce = -1.8*dot;
      GOLF.ball.vx += normalX * bounce;
      GOLF.ball.vy += normalY * bounce;
    }
  }

  function golfHandleCollisions(prevX, prevY){
    if (!GOLF.hole) return;
    const r = GOLF.ball.r;
    const walls = GOLF.hole.walls || [];
    for (let i=0;i<walls.length;i++){
      const seg = walls[i];
      if (!seg || seg.length<2) continue;
      const [ax,ay] = seg[0];
      const [bx,by] = seg[1];
      const proj = golfProjectOnSegment(GOLF.ball.x, GOLF.ball.y, ax, ay, bx, by);
      const dx = GOLF.ball.x - proj.x;
      const dy = GOLF.ball.y - proj.y;
      const distSq = dx*dx + dy*dy;
      if (distSq <= (r*r)+0.01){
        const dist = Math.sqrt(distSq)||1;
        const overlap = r - dist + 0.5;
        const nx = dx / dist;
        const ny = dy / dist;
        GOLF.ball.x += nx * overlap;
        GOLF.ball.y += ny * overlap;
        golfReflect(nx, ny);
      }
    }
    golfClampBallWithinBounds();
  }

  function golfResolveSegments(ball, segments, bounce){
    if (!segments) return;
    for (const seg of segments){
      if (!seg) continue;
      const ax = seg.x1 ?? seg[0]?.[0];
      const ay = seg.y1 ?? seg[0]?.[1];
      const bx = seg.x2 ?? seg[1]?.[0];
      const by = seg.y2 ?? seg[1]?.[1];
      if ([ax,ay,bx,by].some(v=>typeof v!=='number')) continue;
      const proj = golfProjectOnSegment(ball.x, ball.y, ax, ay, bx, by);
      const dx = ball.x - proj.x;
      const dy = ball.y - proj.y;
      const distSq = dx*dx + dy*dy;
      if (distSq <= (ball.r*ball.r) + 0.01){
        const dist = Math.sqrt(distSq) || 1;
        const overlap = ball.r - dist + 0.4;
        const nx = dx / dist;
        const ny = dy / dist;
        ball.x += nx * overlap;
        ball.y += ny * overlap;
        const dot = ball.vx*nx + ball.vy*ny;
        if (dot < 0){
          ball.vx -= (1 + (bounce||1))*dot*nx;
          ball.vy -= (1 + (bounce||1))*dot*ny;
        }
      }
    }
  }

  function golfAddStroke(){
    const idx = GOLF.holeIndex;
    GOLF.strokesThisHole += 1;
    GOLF.strokes[idx] = GOLF.strokesThisHole;
  }

  // Drop ball back to tee center with optional penalty (+1 by default)
  function dropToTee(penalty=1){
    const hole = GOLF.hole;
    const spawn = hole?.spawn || hole?.tee || {};
    const teeRect = hole?.teeRect || { x: (spawn.x||150) - 24, y: (spawn.y||150) - 24, w: 48, h: 48 };
    const cx = teeRect.x + teeRect.w/2;
    const cy = teeRect.y + teeRect.h/2;
    GOLF.ball.x = cx;
    GOLF.ball.y = cy;
    GOLF.ball.vx = 0; GOLF.ball.vy = 0;
    if (penalty && penalty>0){
      for (let i=0;i<penalty;i++) golfAddStroke();
      GOLF.penaltyFlashUntil = nowMs() + 900;
      addCaption(cx, cy - 24, `Drop (+${penalty})`, 1100);
    } else {
      addCaption(cx, cy - 24, 'TEE', 1100);
    }
    GOLF.turn = 'player';
    GOLF.state = 'aim';
  }

  function golfLaunchShot(dirX, dirY, power){
    if (GOLF.turn !== 'player') return;
    const len = Math.hypot(dirX, dirY) || 1;
    if (len < 0.01){
      GOLF.state = 'aim';
      return;
    }
    const max = 720;
    const impulse = clamp(power, 40, max);
    const velocity = impulse * 0.12;
    const nx = dirX / len;
    const ny = dirY / len;
    GOLF.ball.vx = nx * velocity;
    GOLF.ball.vy = ny * velocity;
    GOLF.aimAngle = Math.atan2(GOLF.ball.vy, GOLF.ball.vx);
    GOLF.state = 'rolling';
    golfAddStroke();
    GOLF.turn = 'player_rolling';
  }

  function golfShowBanner(text, duration, onDone){
    GOLF.banner = { text, until: nowMs() + (duration||1800), onDone: onDone||null };
  }

  function golfGetOverlay(hole){
    const h = hole || GOLF.hole;
    if (!h || !h.overlay) return null;
    const key = h.overlay;
    if (GOLF.overlays.has(key)) return GOLF.overlays.get(key);
    const img = new Image();
    img.onload = ()=>{ img.__broken = false; };
    img.onerror = ()=>{ img.__broken = true; };
    img.src = key;
    GOLF.overlays.set(key, img);
    return img;
  }

  function golfIsBrownPixel(r, g, b, a){
    if (a !== undefined && a < 40) return false;
    const dr = r - 139;
    const dg = g - 94;
    const db = b - 63;
    if ((dr*dr + dg*dg + db*db) <= 900) return true;
    if (r < 40 && g < 40 && b < 40) return true;
    return (r > 110 && r < 180 && g > 60 && g < 130 && b > 40 && b < 100 && r > g && g > b);
  }

  function golfIsWhitePixel(r, g, b, a){
    if (a !== undefined && a < 40) return true;
    return r > 235 && g > 235 && b > 235;
  }

  function golfExtractRailsFromOverlay(img){
    const w = img.naturalWidth || img.width || 0;
    const h = img.naturalHeight || img.height || 0;
    if (!w || !h) return [];
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const c = canvas.getContext('2d', { willReadFrequently: true });
    if (!c) return [];
    c.drawImage(img, 0, 0, w, h);
    let data;
    try {
      data = c.getImageData(0, 0, w, h).data;
    } catch(_) {
      return [];
    }
    const total = w * h;
    const brown = new Uint8Array(total);
    const playable = new Uint8Array(total);
    for (let i = 0; i < total; i++) {
      const idx = i * 4;
      const r = data[idx];
      const g = data[idx + 1];
      const b = data[idx + 2];
      const a = data[idx + 3];
      const isBrown = golfIsBrownPixel(r, g, b, a);
      if (isBrown) brown[i] = 1;
      if (!isBrown && !golfIsWhitePixel(r, g, b, a)) playable[i] = 1;
    }

    const hEdges = new Map();
    const vEdges = new Map();
    const addH = (y, x1, x2) => {
      const arr = hEdges.get(y) || [];
      arr.push([x1, x2]);
      hEdges.set(y, arr);
    };
    const addV = (x, y1, y2) => {
      const arr = vEdges.get(x) || [];
      arr.push([y1, y2]);
      vEdges.set(x, arr);
    };

    for (let y = 0; y < h; y++) {
      const row = y * w;
      for (let x = 0; x < w; x++) {
        const i = row + x;
        if (!brown[i]) continue;
        if (x > 0 && playable[i - 1]) addV(x, y, y + 1);
        if (x < w - 1 && playable[i + 1]) addV(x + 1, y, y + 1);
        if (y > 0 && playable[i - w]) addH(y, x, x + 1);
        if (y < h - 1 && playable[i + w]) addH(y + 1, x, x + 1);
      }
    }

    const rails = [];
    const mergeRanges = (ranges) => {
      ranges.sort((a, b) => a[0] - b[0]);
      const merged = [];
      let s = ranges[0][0];
      let e = ranges[0][1];
      for (let i = 1; i < ranges.length; i++) {
        const ns = ranges[i][0];
        const ne = ranges[i][1];
        if (ns <= e + 0.01) {
          e = Math.max(e, ne);
        } else {
          merged.push([s, e]);
          s = ns; e = ne;
        }
      }
      merged.push([s, e]);
      return merged;
    };

    for (const [y, ranges] of hEdges.entries()) {
      const merged = mergeRanges(ranges);
      for (const [x1, x2] of merged) {
        if (x2 - x1 >= 1) rails.push({ x1, y1: y, x2, y2: y });
      }
    }
    for (const [x, ranges] of vEdges.entries()) {
      const merged = mergeRanges(ranges);
      for (const [y1, y2] of merged) {
        if (y2 - y1 >= 1) rails.push({ x1: x, y1, x2: x, y2 });
      }
    }
    return rails;
  }

  function golfEnsureOverlayRails(hole){
    const h = hole || GOLF.hole;
    if (!h || !h.overlay) return;
    if (Array.isArray(h.rails) && h.rails.length) return;
    const key = h.overlay;
    if (!GOLF.overlayRails) GOLF.overlayRails = new Map();
    if (GOLF.overlayRails.has(key)) {
      h.rails = GOLF.overlayRails.get(key);
      return;
    }
    const img = golfGetOverlay(h);
    if (!img) return;
    const build = () => {
      const rails = golfExtractRailsFromOverlay(img);
      if (rails && rails.length) {
        // Scale rails from image dimensions to bounds dimensions
        const imgW = img.naturalWidth || img.width || 960;
        const imgH = img.naturalHeight || img.height || 540;
        const bounds = h.bounds || { x: 0, y: 0, w: 960, h: 540 };
        const scaleX = bounds.w / imgW;
        const scaleY = bounds.h / imgH;
        const scaledRails = rails.map(seg => ({
          x1: bounds.x + seg.x1 * scaleX,
          y1: bounds.y + seg.y1 * scaleY,
          x2: bounds.x + seg.x2 * scaleX,
          y2: bounds.y + seg.y2 * scaleY
        }));
        GOLF.overlayRails.set(key, scaledRails);
        if (h.overlay === key) h.rails = scaledRails;
      }
    };
    if (img.complete && !img.__broken) {
      build();
    } else {
      img.addEventListener('load', build, { once: true });
    }
  }

  function golfComputeView(bounds){
    const fallbackW = (typeof window !== 'undefined' && window.VIRTUAL_W) ? window.VIRTUAL_W : 960;
    const fallbackH = (typeof window !== 'undefined' && window.VIRTUAL_H) ? window.VIRTUAL_H : 540;
    const b = bounds || { x: 0, y: 0, w: fallbackW, h: fallbackH };
    const pad = 0;
    const zoom = 0.5;
    const baseScale = Math.min((W - pad*2) / (b.w||1), (H - pad*2) / (b.h||1));
    const scale = baseScale * zoom;
    const ox = (W - (b.w * scale)) * 0.5 - b.x * scale;
    const oy = (H - (b.h * scale)) * 0.5 - b.y * scale;
    return { scale, ox, oy };
  }

  function golfStartArrival(opts){
    if (opts && opts.skipHeliIntro) {
      // Skip intro - go directly to game
      GOLF.state = 'intro';
      GOLF.arrival = { active: false };
      GOLF.parkedHeli = null;
      GOLF.clubPicked = true;
      return;
    }
    // Use standard entryHeli system (like Greenland/Oval)
    GOLF.arrival = { active: false };
    GOLF.state = 'arrival';

    // Beregn skærm-koordinater for bunden af golfbanen (usynligt gulv)
    const bounds = GOLF.hole?.bounds || { x: 0, y: 0, w: 960, h: 540 };
    const view = golfComputeView(bounds);
    // Bunden af banen i skærm-koordinater
    const groundScreenY = view.oy + (bounds.y + bounds.h) * view.scale;
    // Helikopter lander lidt til venstre for banen, på gulv-niveau
    const landX = view.ox + bounds.x * view.scale - 60;
    const landY = groundScreenY - 20; // Lidt over gulvet
    // Gem position til parkeret helikopter
    GOLF.parkedHeli = { x: landX, y: landY };
    playEntryHeli('Time for some golf!', landX, landY);
  }

  // Called when entryHeli finishes in golf scene
  function golfAfterHeliLanding(){
    GOLF.arrival = { active: false };
    GOLF.state = 'approach';
    if (typeof entryHeli?.x === 'number' && typeof entryHeli?.y === 'number'){
      GOLF.parkedHeli = { x: entryHeli.x, y: entryHeli.y };
    }
    const bounds = GOLF.hole?.bounds || { x: 0, y: 0, w: 960, h: 540 };
    const view = golfComputeView(bounds);
    const heli = GOLF.parkedHeli || {
      x: view.ox + bounds.x * view.scale - 60,
      y: view.oy + (bounds.y + bounds.h) * view.scale - 20
    };
    const sx = heli.x + 30*CFG.SCALE;
    const sy = heli.y + 18*CFG.SCALE;
    const sc = view.scale || 1;
    GOLF.approach = {
      x: (sx - view.ox) / sc,
      y: (sy - view.oy) / sc,
      facing: 1,
      moving: false
    };
    GOLF.walkCycle = 0;
  }

  // BIDEN_LINES loaded from game-text-data JSON block

  function addCaption(x, y, text, duration){
    const expires = nowMs() + (duration||1200);
    GOLF.captions.push({ id: ++GOLF.captionCounter, x, y, text, expires });
  }

  function golfSpeakBiden(){
    if (!BIDEN_LINES || !BIDEN_LINES.length) return;
    const idx = (GOLF.biden?.sayNext ?? GOLF.bidenSayNext ?? 0);
    const line = BIDEN_LINES[idx % BIDEN_LINES.length];
    if (GOLF.biden) GOLF.biden.sayNext = idx + 1;
    else GOLF.bidenSayNext = idx + 1;
    GOLF.bidenSpeech = { text: line };
  }

  function golfBubble(text,x,y,right=false, speaker='aide', scale=1.8){
    const pad = GAME_CONSTANTS.UI.BUBBLE_PADDING * scale;
    const fontSize = GAME_CONSTANTS.UI.BUBBLE_FONT_SIZE * CFG.SCALE * scale;
    const lineH = GAME_CONSTANTS.UI.BUBBLE_LINE_HEIGHT * CFG.SCALE * scale;
    ctx.font = `${fontSize}px/1.2 system-ui`;
    const lines = wrapLines(text, Math.max(10, Math.round(30/scale)));
    const w = Math.max(80*scale, Math.max(...lines.map(ln=>ctx.measureText(ln).width)) + pad*2);
    const h = (lines.length*lineH + 8*scale);
    const tailOff = GAME_CONSTANTS.UI.BUBBLE_TAIL_OFFSET * scale;
    const tailY = GAME_CONSTANTS.UI.BUBBLE_TAIL_Y * CFG.SCALE * scale;
    const bx = right? x - w - tailOff : x + tailOff;
    const by = y - GAME_CONSTANTS.UI.BUBBLE_Y_OFFSET*CFG.SCALE*scale;
    const palettes = GAME_CONSTANTS.UI.BUBBLE_PALETTES || {};
    const pal = palettes[speaker] || palettes.default || { fill:'rgba(0,0,0,.7)', stroke:'rgba(255,255,255,.85)', text:'#fff', tail:'rgba(0,0,0,.7)' };
    ctx.fillStyle=pal.fill; ctx.strokeStyle=pal.stroke;
    roundRect(bx,by,w,h,8*scale); ctx.fill(); ctx.stroke();
    ctx.fillStyle=pal.text; lines.forEach((ln,i)=>ctx.fillText(ln, bx+pad, by+lineH*(i+0.7)));
    ctx.beginPath();
    ctx.fillStyle=pal.tail;
    if (right){ ctx.moveTo(x-10*scale,y-tailY); ctx.lineTo(bx+w-6*scale,by+h/2-4*scale); ctx.lineTo(bx+w-6*scale,by+h/2+4*scale); }
    else { ctx.moveTo(x+10*scale,y-tailY); ctx.lineTo(bx+6*scale,by+h/2-4*scale); ctx.lineTo(bx+6*scale,by+h/2+4*scale); }
    ctx.closePath(); ctx.fill();
  }

  function planBidenStrokes(hole, parTarget){
    const targets = [];
    if (!hole) return targets;
    const teeRect = hole.teeRect || {x: (hole.spawn?.x||hole.tee?.x||150)-20, y: (hole.spawn?.y||hole.tee?.y||150)-20, w:40, h:40};
    const teeC = { x: teeRect.x + teeRect.w/2, y: teeRect.y + teeRect.h/2 };
    const cup = hole.cup || {x: teeC.x+100, y: teeC.y-60};
    const rails = Array.isArray(hole.rails) ? hole.rails : [];
    const xs = rails.flatMap(r => [r.x1??r[0]?.[0], r.x2??r[1]?.[0]]).filter(v=>typeof v==='number');
    const ys = rails.flatMap(r => [r.y1??r[0]?.[1], r.y2??r[1]?.[1]]).filter(v=>typeof v==='number');
    const mid = {
      x: xs.length ? (Math.min(...xs)+Math.max(...xs))/2 : (teeC.x+cup.x)/2,
      y: ys.length ? (Math.min(...ys)+Math.max(...ys))/2 : (teeC.y+cup.y)/2
    };
    const approach = { x: cup.x - 60, y: cup.y + 40 };
    const list = [teeC, mid, approach, cup];
    while (list.length < parTarget) list.splice(list.length-1, 0, { x:(mid.x+approach.x)/2, y:(mid.y+approach.y)/2 });
    while (list.length > parTarget) list.splice(1,1);
    list[list.length-1] = cup;
    return list.slice(1);
  }

  function scheduleBidenStroke(delay){
    if (!GOLF.biden || GOLF.opts?.versus === false) return;
    if (GOLF.turn !== 'biden' && GOLF.turn !== 'biden_wait') return;
    if (GOLF.bidenTimer || GOLF.biden.waiting) return;
    if (GOLF.biden.strokesHole >= GOLF.biden.parTarget) return;
    GOLF.biden.waiting = true;
    GOLF.bidenTimer = setTimeout(()=>{
      GOLF.bidenTimer = null;
      if (!GOLF.biden || GOLF.biden.strokesHole >= GOLF.biden.parTarget) return;
      const hole = GOLF.hole;
      const B = GOLF.biden;
      const target = GOLF.bidenPlan[Math.min(B.strokesHole, GOLF.bidenPlan.length-1)] || hole.cup || {x:B.ball.x+40,y:B.ball.y-40};
      const dx = target.x - B.ball.x;
      const dy = target.y - B.ball.y;
      const dist = Math.hypot(dx, dy) || 1;
      const speed = Math.min(520, Math.max(140, dist * 2.0));
      const nx = dx / dist;
      const ny = dy / dist;
      B.ball.vx = nx * speed;
      B.ball.vy = ny * speed;
      B.ball.moving = true;
      B.followDelayUntil = nowMs() + 450;
      B.waiting = false;
      B.strokesHole++;
      GOLF.turn = 'biden_rolling';
      const line = BIDEN_LINES[B.sayNext++ % BIDEN_LINES.length];
      const capX = GOLF.bidenAvatar?.x ?? target.x;
      const capY = (GOLF.bidenAvatar?.y ?? target.y) - 56;
      addCaption(capX, capY, line, 1600);
    }, delay || 800);
  }

  function golfUpdate(dt){
    if (scene !== 'golf') return;
    const now = nowMs();
    if (GOLF.banner && now > GOLF.banner.until){
      const done = GOLF.banner.onDone;
      GOLF.banner = null;
      if (typeof done === 'function') done();
    }

    if (GOLF.state === 'arrival'){
      // Wait for entryHeli to finish (handled in main render loop)
      return;
    }
    if (GOLF.state === 'approach'){
      if (!GOLF.approach){
        GOLF.approach = {
          x: GOLF.playerStand?.x || GOLF.ball.x,
          y: GOLF.playerStand?.y || GOLF.ball.y,
          facing: 1,
          moving: false
        };
      }
      const pos = GOLF.approach;
      let dx = (keys.has('arrowright') ? 1 : 0) - (keys.has('arrowleft') ? 1 : 0);
      let dy = (keys.has('arrowdown') ? 1 : 0) - (keys.has('arrowup') ? 1 : 0);
      const moving = dx !== 0 || dy !== 0;
      if (moving){
        const len = Math.hypot(dx, dy) || 1;
        const speed = 160;
        pos.x += (dx / len) * speed * dt;
        pos.y += (dy / len) * speed * dt;
        pos.moving = true;
        GOLF.walkCycle += dt * 8;
        if (dx) pos.facing = Math.sign(dx);
      } else {
        pos.moving = false;
        GOLF.walkCycle = 0;
      }
      const bounds = GOLF.hole?.bounds || { x: 0, y: 0, w: 960, h: 540 };
      const pad = 80;
      pos.x = clamp(pos.x, bounds.x - pad, bounds.x + bounds.w + pad);
      pos.y = clamp(pos.y, bounds.y - pad, bounds.y + bounds.h + pad);
      const target = GOLF.playerStand || { x: GOLF.ball.x, y: GOLF.ball.y };
      if (Math.hypot(pos.x - target.x, pos.y - target.y) < 26){
        pos.x = target.x;
        pos.y = target.y;
        pos.moving = false;
        GOLF.clubPicked = true;
        GOLF.state = 'intro';
        GOLF.introActive = true;
        GOLF.introDismissReady = true;
      }
      return;
    }
    if (GOLF.state === 'scorecard' || GOLF.state === 'intro'){ return; }

    // Keyboard charge handling
    if (GOLF.state === 'charging'){
      GOLF.charge.power = Math.min(GOLF.charge.power + dt * 420, 720);
      return;
    }

    if (GOLF.state === 'rolling'){
      const prevX = GOLF.ball.x;
      const prevY = GOLF.ball.y;
      GOLF.ball.x += GOLF.ball.vx * dt;
      GOLF.ball.y += GOLF.ball.vy * dt;
      golfHandleCollisions(prevX, prevY);
      // Resolve against rails (barriers) with elastic reflection
      try { const hole = GOLF.hole || {}; golfResolveSegments(GOLF.ball, hole.rails || hole.walls || [], 1.0); } catch(_){ }

      const friction = golfSurfaceAt(GOLF.ball.x, GOLF.ball.y);
      const decay = Math.pow(friction, dt * 60);
      GOLF.ball.vx *= decay;
      GOLF.ball.vy *= decay;
      // General damping
      GOLF.ball.vx *= 0.995;
      GOLF.ball.vy *= 0.995;

      const speed = Math.hypot(GOLF.ball.vx, GOLF.ball.vy);
      const penalty = golfInPenalty(GOLF.ball.x, GOLF.ball.y);
      if (penalty){
        dropToTee(1);
        return;
      }

      const cup = GOLF.hole.cup;
      if (cup && !GOLF._finishedHole){
        const d = Math.hypot(GOLF.ball.x - cup.x, GOLF.ball.y - cup.y);
        // Magnet effect: gentle pull toward cup within range at low speed
        if (d <= (cup.r||14) + MAGNET_RANGE && speed < MAGNET_SPEED){
          const nx = (cup.x - GOLF.ball.x) / (d||1);
          const ny = (cup.y - GOLF.ball.y) / (d||1);
          const strength = (1 - Math.max(0, (d - (cup.r||14)) / MAGNET_RANGE)) * MAGNET_STRENGTH;
          GOLF.ball.vx += nx * strength * dt;
          GOLF.ball.vy += ny * strength * dt;
        }
        if (d <= (cup.r||14) && speed < CUP_SPEED_THRESH){
          GOLF.ball.x = cup.x;
          GOLF.ball.y = cup.y;
          GOLF.ball.vx = 0; GOLF.ball.vy = 0;
          GOLF._finishedHole = true;
          if (!GOLF.holeBooked){
            GOLF.totalStrokes += GOLF.strokesThisHole;
            GOLF.holeBooked = true;
          }
          GOLF.turn = 'player';
          const strokes = GOLF.strokes[GOLF.holeIndex];
          const par = (GOLF.course?.par||[])[GOLF.holeIndex] || 3;
          const diff = strokes - par;
          const label = diff < 0 ? `${Math.abs(diff)} under par!` : diff === 0 ? 'Par!' : `${diff} over par`;
          golfShowBanner(label, 1600, ()=>golfAdvanceHole());
          if (GOLF.opts?.versus !== false && GOLF.biden){ GOLF.biden._finishedHole = true; }
          GOLF.state = 'banner';
          return;
        }
      }

      if (speed < 6){
        GOLF.ball.vx = 0;
        GOLF.ball.vy = 0;
        if (GOLF.turn === 'player_rolling'){
          // Biden already played first - player continues until holed
          GOLF.turn = 'player';
          GOLF.state = 'aim';
        } else {
          GOLF.state = 'aim';
        }
      }
      return;
    }

    if (GOLF.opts?.versus !== false && GOLF.biden){
      const hole = GOLF.hole;
      const B = GOLF.biden;
      const bb = B.ball;
      if (bb.moving){
        bb.x += bb.vx * dt;
        bb.y += bb.vy * dt;
        const fr = golfSurfaceAt(bb.x, bb.y);
        const decay = Math.pow(fr, dt * 60);
        bb.vx *= decay;
        bb.vy *= decay;
        bb.vx *= 0.995;
        bb.vy *= 0.995;
        golfResolveSegments(bb, hole.rails || hole.walls || [], 1.0);
        const pen = golfInPenalty(bb.x, bb.y);
        if (pen){
          const wp = GOLF.bidenPlan[Math.max(0, B.strokesHole-1)] || {x: hole.teeRect.x + hole.teeRect.w/2, y: hole.teeRect.y + hole.teeRect.h/2};
          bb.x = wp.x;
          bb.y = wp.y;
          bb.vx = 0;
          bb.vy = 0;
          bb.moving = false;
        }
        const cup = hole.cup;
        if (cup && !B._finishedHole){
          const d = Math.hypot(bb.x - cup.x, bb.y - cup.y);
          const bbSpeed = Math.hypot(bb.vx, bb.vy);
          if (d < Math.max(15, (cup.r||14)+6) && bbSpeed < CUP_SPEED_THRESH){
            bb.x = cup.x;
            bb.y = cup.y;
            bb.vx = 0;
            bb.vy = 0;
            bb.moving = false;
            B._finishedHole = true;
          }
        }
        if (Math.hypot(bb.vx, bb.vy) < 12){
          bb.vx = 0; bb.vy = 0; bb.moving = false;
        }
        if (!bb.moving && B._finishedHole && !B._booked){
          B.total += B.strokesHole;
          B._booked = true;
          GOLF.turn = 'player';
          if (!GOLF.holeBooked) GOLF.state = 'aim';
        }
      }
      if (!bb.moving && GOLF.turn.startsWith('biden')){
        // Biden continues hitting until all 3 strokes are done
        if (!B._finishedHole && B.strokesHole < B.parTarget) {
          GOLF.turn = 'biden';
          if (!B.waiting) scheduleBidenStroke(700 + Math.random()*300);
        } else {
          GOLF.turn = 'player';
          if (!GOLF.holeBooked) GOLF.state = 'aim';
        }
      }
      if (GOLF.bidenAvatar){
        const bidenActive = (GOLF.turn && String(GOLF.turn).startsWith('biden'));
        const canMove = bidenActive && !bb.moving && now >= (B.followDelayUntil || 0);
        if (canMove){
          const bounds = hole?.bounds || { x: 0, y: 0, w: 960, h: 540 };
          const targetX = bb.x - 18;
          const targetY = bb.y + 34;
          const t = Math.min(1, dt * 6);
          GOLF.bidenAvatar.x += (targetX - GOLF.bidenAvatar.x) * t;
          GOLF.bidenAvatar.y += (targetY - GOLF.bidenAvatar.y) * t;
          GOLF.bidenAvatar.x = clamp(GOLF.bidenAvatar.x, bounds.x + 16, bounds.x + bounds.w - 16);
          GOLF.bidenAvatar.y = clamp(GOLF.bidenAvatar.y, bounds.y + 16, bounds.y + bounds.h - 16);
        }
      }
    }

    if (GOLF.state === 'banner'){ return; }
  }

  function golfDraw(){
    if (scene !== 'golf') return;
    ctx.save();
    // Light sand background
    ctx.fillStyle = '#efe8d2';
    ctx.fillRect(0,0,W,H);
    
    // Compute and apply viewport transform to center bounds
    const view = golfComputeView(GOLF.hole && GOLF.hole.bounds);
    GOLF.view = view;
    ctx.translate(view.ox, view.oy);
    ctx.scale(view.scale, view.scale);
    if (GOLF.hole && Array.isArray(GOLF.hole.surfaces)){
      GOLF.hole.surfaces.forEach(s=>{
        if (!s || !s.poly) return;
        const color = SURFACE_COLORS[s.type] || '#4c8640';
        ctx.fillStyle = color;
        fillSurface(ctx, s.poly);
      });
    }
    if (GOLF.hole && GOLF.hole.bounds){
      const img = golfGetOverlay(GOLF.hole);
      if (img && img.complete && !img.__broken && (img.naturalWidth||0) > 0){
        try {
          ctx.drawImage(img, GOLF.hole.bounds.x, GOLF.hole.bounds.y, GOLF.hole.bounds.w, GOLF.hole.bounds.h);
        } catch(_){}
      }
      // Normalize fairway tone on hole 2 (overlay is too bright)
      if (GOLF.hole.id === 2 && Array.isArray(GOLF.hole.surfaces)){
        const fairways = GOLF.hole.surfaces.filter(s=>s && s.type === 'fairway' && s.poly);
        if (fairways.length){
          ctx.save();
          ctx.globalCompositeOperation = 'multiply';
          ctx.globalAlpha = 0.6;
          ctx.fillStyle = SURFACE_COLORS.fairway;
          fairways.forEach(s => fillSurface(ctx, s.poly));
          ctx.restore();
        }
      }
      // Optional debug frame around bounds (disabled)
    }
    if (GOLF.hole && Array.isArray(GOLF.hole.penalties)){
      ctx.fillStyle = 'rgba(30,90,200,0.28)';
      GOLF.hole.penalties.forEach(pen=>{
        if (!pen || !pen.poly) return;
        ctx.beginPath();
        pen.poly.forEach(([x,y],idx)=> idx?ctx.lineTo(x,y):ctx.moveTo(x,y));
        ctx.closePath();
        ctx.fill();
      });
    }
    // Draw rails (barriers) as visible lines
    if (GOLF.hole && Array.isArray(GOLF.hole.rails)){
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = '#9b6a2f';
      ctx.lineWidth = 4;
      for (const seg of GOLF.hole.rails){
        if (!seg) continue;
        const ax = seg.x1 ?? seg[0]?.[0];
        const ay = seg.y1 ?? seg[0]?.[1];
        const bx = seg.x2 ?? seg[1]?.[0];
        const by = seg.y2 ?? seg[1]?.[1];
        if ([ax,ay,bx,by].some(v=>typeof v!== 'number')) continue;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.stroke();
      }
      ctx.restore();
    }
    if (GOLF.hole && GOLF.hole.cup){
      const cup = GOLF.hole.cup;
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(cup.x, cup.y, (cup.r||14), 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.arc(cup.x, cup.y, (cup.r||14)*0.55, 0, Math.PI*2);
      ctx.fill();
    }

    // Draw parked helicopter after landing (in screen coords)
    if (!entryHeli.active && GOLF.parkedHeli) {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to screen coordinates
      drawHeli(GOLF.parkedHeli.x, GOLF.parkedHeli.y, GOLF_HELI_SCALE);
      ctx.restore();
    }

    // Tee center marker (small cross + dot)
    if (GOLF.hole){
      const spawn = GOLF.hole.spawn || GOLF.hole.tee || {};
      const teeRect = GOLF.hole.teeRect || { x: (spawn.x||150) - 24, y: (spawn.y||150) - 24, w: 48, h: 48 };
      const cx = teeRect.x + teeRect.w/2;
      const cy = teeRect.y + teeRect.h/2;
      ctx.save();
      ctx.strokeStyle = 'rgba(0,180,255,0.9)';
      ctx.fillStyle = 'rgba(0,180,255,0.7)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx - 6, cy); ctx.lineTo(cx + 6, cy);
      ctx.moveTo(cx, cy - 6); ctx.lineTo(cx, cy + 6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, 2.5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Approach marker near tee (guide player to start position)
    if (GOLF.state === 'approach' && GOLF.playerStand){
      const sx = GOLF.playerStand.x;
      const sy = GOLF.playerStand.y + 6;
      const size = 96;
      const viewScale = (GOLF.view && typeof GOLF.view.scale === 'number') ? GOLF.view.scale : 1;
      const clubScale = 1.08 / (viewScale || 1);
      // Pulsating glow effect
      const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 200);
      const glowAlpha = 0.3 + pulse * 0.4;
      ctx.save();
      // Outer glow
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 15 + pulse * 10;
      ctx.fillStyle = `rgba(255,215,0,${glowAlpha * 0.3})`;
      ctx.fillRect(sx - size/2 - 4, sy - size/2 - 4, size + 8, size + 8);
      ctx.shadowBlur = 0;
      // Inner box
      ctx.fillStyle = `rgba(255,215,0,${0.15 + pulse * 0.1})`;
      ctx.fillRect(sx - size/2, sy - size/2, size, size);
      // Animated border
      ctx.strokeStyle = `rgba(255,215,0,${0.8 + pulse * 0.2})`;
      ctx.lineWidth = 3;
      ctx.setLineDash([12, 6]);
      ctx.lineDashOffset = -Date.now() / 50; // Animeret stiplet linje
      ctx.strokeRect(sx - size/2, sy - size/2, size, size);
      ctx.setLineDash([]);
      // Arrow pointing down
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.moveTo(sx, sy - size/2 - 25);
      ctx.lineTo(sx - 12, sy - size/2 - 10);
      ctx.lineTo(sx + 12, sy - size/2 - 10);
      ctx.closePath();
      ctx.fill();
      // Text with shadow
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 4;
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('⛳ START HER', sx, sy + 6);
      ctx.textAlign = 'left';
      ctx.shadowBlur = 0;
      ctx.restore();
      if (!GOLF.clubPicked){
        drawGolfClubOnGround(ctx, sx + 18, sy + 20, clubScale);
      }
    }

    // Aim preview
    if (GOLF.state === 'aim') {
      if (GOLF.aim.active) {
        // Slingshot: træk væk fra bolden → linjen peger i flyveretningen
        ctx.setLineDash([8, 12]);
        ctx.strokeStyle = 'rgba(255,235,59,0.9)';
        ctx.lineWidth = 4.5;
        ctx.beginPath();
        ctx.moveTo(GOLF.ball.x, GOLF.ball.y);

        // Spejl musens punkt omkring bolden
        const toX = GOLF.ball.x + (GOLF.ball.x - GOLF.aim.currentX);
        const toY = GOLF.ball.y + (GOLF.ball.y - GOLF.aim.currentY);
        // Opdater vinkel i preview (peger fra bold mod spejlet punkt)
        GOLF.aimAngle = Math.atan2(toY - GOLF.ball.y, toX - GOLF.ball.x);

        ctx.lineTo(toX, toY);
        ctx.stroke();
        ctx.setLineDash([]);
      } else {
        // Passiv sigte når man ikke trækker – bruger GOLF.aimAngle
        const length = 80;
        const ex = GOLF.ball.x + Math.cos(GOLF.aimAngle) * length;
        const ey = GOLF.ball.y + Math.sin(GOLF.aimAngle) * length;
        ctx.setLineDash([4, 10]);
        ctx.strokeStyle = 'rgba(255,235,59,0.7)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(GOLF.ball.x, GOLF.ball.y);
        ctx.lineTo(ex, ey);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Ball (player)
    ctx.fillStyle = '#f8f8f8';
    if (GOLF.penaltyFlashUntil > nowMs()) ctx.fillStyle = '#ff8a80';
    ctx.beginPath();
    ctx.arc(GOLF.ball.x, GOLF.ball.y, GOLF.ball.r, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle='#222'; ctx.lineWidth=1;
    ctx.stroke();

    // Player avatar stands near tee (ball rolls independently)
    // During entryHeli, Trump is drawn by main render loop
    if (!entryHeli.active) {
      const viewScale = (GOLF.view && typeof GOLF.view.scale === 'number') ? GOLF.view.scale : 1;
      const trumpScale = 1.08 / (viewScale || 1);
      if (GOLF.state === 'approach' && GOLF.approach){
        drawTrumpGolfPose(ctx, GOLF.approach.x, GOLF.approach.y, {
          scale: trumpScale,
          walking: !!GOLF.approach.moving,
          facing: GOLF.approach.facing,
          walkCycle: GOLF.walkCycle
        });
      } else {
        drawTrumpGolfStanding(ctx, GOLF.playerStand.x, GOLF.playerStand.y, trumpScale);
      }
      if (GOLF.clubPicked){
        const clubX = (GOLF.state === 'approach' && GOLF.approach) ? GOLF.approach.x : GOLF.playerStand.x;
        const clubY = (GOLF.state === 'approach' && GOLF.approach) ? GOLF.approach.y : GOLF.playerStand.y;
        const clubFacing = (GOLF.state === 'approach' && GOLF.approach) ? GOLF.approach.facing : 1;
        drawGolfClubInHand(ctx, clubX, clubY, trumpScale, clubFacing);
      }
    }

    if (GOLF.opts?.versus !== false && GOLF.biden){
      const bb = GOLF.biden.ball;
      // Only draw ball if not finished (when ball is in cup, don't draw)
      if (!GOLF.biden._finishedHole) {
        ctx.fillStyle = '#a7c3ff';
        ctx.beginPath();
        ctx.arc(bb.x, bb.y, bb.r, 0, Math.PI*2);
        ctx.fill();
      }
      drawBidenGolfStanding(ctx, GOLF.bidenAvatar.x, GOLF.bidenAvatar.y, 1.08);
      const cup = GOLF.hole?.cup || { x: bb.x, y: bb.y };
      const bidenFacing = (GOLF.bidenAvatar.x <= cup.x) ? 1 : -1;
      drawGolfClubInHand(ctx, GOLF.bidenAvatar.x, GOLF.bidenAvatar.y, 1.08, bidenFacing);
      // Draw stroke count above Biden's head
      if (GOLF.biden._finishedHole && GOLF.biden.strokesHole > 0) {
        const bx = GOLF.bidenAvatar.x;
        const by = GOLF.bidenAvatar.y - 70;
        ctx.save();
        // Stroke count bubble
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.strokeStyle = '#1565C0';
        ctx.lineWidth = 2;
        const bubbleW = 50, bubbleH = 26;
        ctx.beginPath();
        ctx.roundRect(bx - bubbleW/2, by - bubbleH/2, bubbleW, bubbleH, 6);
        ctx.fill();
        ctx.stroke();
        // Stroke number
        ctx.fillStyle = '#1565C0';
        ctx.font = 'bold 16px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${GOLF.biden.strokesHole} slag`, bx, by);
        ctx.restore();
      }
      if (GOLF.bidenSpeech && GOLF.bidenSpeech.text) {
        const bx = GOLF.bidenAvatar.x;
        const by = GOLF.bidenAvatar.y - 92;
        const bounds = GOLF.hole?.bounds || { x: 0, y: 0, w: 960, h: 540 };
        // Arrow points TOWARDS Biden: if he's on left side, arrow points left (right=false)
        const right = bx < bounds.x + bounds.w * 0.5;
        golfBubble(GOLF.bidenSpeech.text, bx, by, right, 'aide', 1.8);
      }
    }

    const now = nowMs();
    GOLF.captions = GOLF.captions.filter(c => c.expires > now);
    GOLF.captions.forEach(c => {
      const alpha = Math.max(0, (c.expires - now)/400);
      ctx.save();
      ctx.globalAlpha = Math.min(1, alpha);
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.font = '600 12px system-ui';
      const text = c.text;
      const width = Math.min(360, 12 + ctx.measureText(text).width);
      ctx.fillRect(c.x - width/2, c.y - 30, width, 22);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, c.x, c.y - 19);
      ctx.restore();
    });

    // Switch to screen coordinates for HUD
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // Charge meter
    if (GOLF.state === 'charging'){
      const w = 160, h = 16;
      const x = W/2 - w/2, y = H - 80;
      ctx.fillStyle='rgba(0,0,0,0.6)';
      ctx.fillRect(x-6,y-6,w+12,h+12);
      ctx.strokeStyle='#ffd54f'; ctx.lineWidth=2;
      ctx.strokeRect(x,y,w,h);
      const pct = GOLF.charge.power / 720;
      ctx.fillStyle='#ffeb3b';
      ctx.fillRect(x+2,y+2,(w-4)*pct,h-4);
      ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.textAlign='center';
      ctx.fillText('E: release to putt', W/2, y-10);
      ctx.textAlign='left';
    }

    // Score and hole info
    if (GOLF.course){
      // Centered title banner (purple, raised)
      const title = `${GOLF.courseName}`;
      const titleX = W/2;
      const titleY = 28;
      ctx.font='bold 16px system-ui';
      const titleW = ctx.measureText(title).width;
      const pad = 14;
      const boxW = titleW + pad*2;
      const boxH = 26;
      ctx.fillStyle = '#6b3fb5';
      roundRect(titleX - boxW/2, titleY - boxH/2, boxW, boxH, 8);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(title, titleX, titleY + 1);
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';

      // Info panel with hole count + score
      const statsX = 24;
      const statsY = 58;
      const statsW = 240, statsH = 70;
      ctx.fillStyle='rgba(0,0,0,0.55)';
      ctx.fillRect(statsX, statsY, statsW, statsH);
      ctx.fillStyle='#fff';
      ctx.font='bold 13px system-ui';
      ctx.fillText(`${GOLF.courseName}`, statsX + 12, statsY + 20);
      const par = (GOLF.course.par||[])[GOLF.holeIndex] || 3;
      const totalHoles = GOLF.course.holes ? GOLF.course.holes.length : 0;
      ctx.font='13px system-ui';
      ctx.fillText(`Hole ${GOLF.hole?.id||GOLF.holeIndex+1} / ${totalHoles} · Par ${par}`, statsX + 12, statsY + 40);
      const playerCurrent = GOLF.totalStrokes + (GOLF.holeBooked ? 0 : GOLF.strokesThisHole);
      const joeCurrent = (GOLF.opts?.versus !== false && GOLF.biden)
        ? (GOLF.biden.total + (GOLF.biden._booked ? 0 : GOLF.biden.strokesHole))
        : null;
      const scoreLine = joeCurrent != null ? `You: ${playerCurrent}  |  Joe: ${joeCurrent}` : `Strokes: ${playerCurrent}`;
      ctx.fillText(scoreLine, statsX + 12, statsY + 60);
    }

    if (GOLF.state === 'waiting' && GOLF.turn.startsWith('biden')){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const boxW = 260, boxH = 46;
      const bx = W/2 - boxW/2;
      const by = H - 150;
      ctx.fillRect(bx, by, boxW, boxH);
      ctx.fillStyle = '#fff';
      ctx.font = '13px system-ui';
      ctx.textAlign='center';
      ctx.fillText('Sleepy Joe is lining up his shot…', bx + boxW/2, by + 26);
      drawBidenIntroHead(ctx, bx + boxW - 70, by - 6, 1.1);
      ctx.textAlign='left';
    }

    if (GOLF.banner){
      ctx.fillStyle='rgba(0,0,0,0.7)';
      const bw = 320, bh = 50;
      ctx.fillRect(W/2-bw/2, 40, bw, bh);
      ctx.fillStyle='#fff'; ctx.font='bold 20px system-ui'; ctx.textAlign='center';
      ctx.fillText(GOLF.banner.text, W/2, 72);
      ctx.textAlign='left';
    }

    if (GOLF.state === 'scorecard' && GOLF.scorecard){
      ctx.fillStyle='rgba(0,0,0,0.75)'; ctx.fillRect(0,0,W,H);
      const cardW = Math.min(W*0.6, 520), cardH = Math.min(H*0.6, 360);
      const cx = (W-cardW)/2, cy = (H-cardH)/2;
      ctx.fillStyle='#fefefe'; ctx.fillRect(cx, cy, cardW, cardH);
      ctx.strokeStyle='#222'; ctx.lineWidth=3; ctx.strokeRect(cx, cy, cardW, cardH);
      ctx.fillStyle='#111'; ctx.textAlign='center';
      ctx.font='bold 22px system-ui';
      ctx.fillText('Scorecard', W/2, cy+40);
      ctx.font='15px system-ui';
      const headers = ['Hole','Par','Strokes'];
      headers.forEach((txt,i)=> ctx.fillText(txt, cx + (i+1)*cardW/4, cy+72));
      const parArr = GOLF.course.par || [];
      GOLF.course.holes.forEach((hole, idx)=>{
        const rowY = cy + 110 + idx*28;
        ctx.fillText(`${hole.id||idx+1}`, cx + cardW/4, rowY);
        ctx.fillText(`${parArr[idx]||3}`, cx + cardW/2, rowY);
        ctx.fillText(`${GOLF.strokes[idx]||0}`, cx + 3*cardW/4, rowY);
      });
      const totalY = cy + cardH - 90;
      const you = GOLF.scorecard.total || 0;
      const joe = GOLF.scorecard.joe || 0;
      const parTotal = GOLF.scorecard.par || 0;
      const diff = you - parTotal;
      const diffText = `${diff>0?'+':''}${diff}`;
      ctx.font='bold 16px system-ui';
      ctx.fillText(`Totals — You: ${you} (${diffText})  |  Joe: ${joe}`, W/2, totalY);
      const win = you <= joe;
      ctx.font='14px system-ui';
      ctx.fillText(win ? 'You proved you’re the best president ever. Self-esteem ramps to 11.' : 'You obviously lied — all your lies fall apart.', W/2, totalY+30);
      ctx.font='13px system-ui';
      ctx.fillText('Press Enter to exit', W/2, totalY+56);
      ctx.textAlign='left';
      ctx.restore();
      return;
    }

    if (GOLF.state === 'intro'){
      // Reset transform to draw info card in screen coordinates
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      // Center info card on screen
      const w = Math.min(520, W-120);
      const h = Math.min(260, H-140);
      const x = W/2 - w/2;
      const y = H/2 - h/2;
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#f8f1d2';
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = '#c59a31'; ctx.lineWidth=4;
      ctx.strokeRect(x, y, w, h);
      drawTrumpIntroHead(ctx, x + 50, y + 40, 1.6);
      drawBidenIntroHead(ctx, x + w - 110, y + 40, 1.6);
      ctx.fillStyle = '#2a2a2a';
      ctx.font = 'bold 24px system-ui';
      ctx.textAlign='center';
      ctx.fillText('Trump vs. Sleepy Joe', x + w/2, y + 78);
      ctx.font = '15px system-ui';
      ctx.fillText('Du må ikke tabe denne duel.', x + w/2, y + 110);
      ctx.font = '14px system-ui';
      ctx.fillText('Træk fra tee væk fra hullet for at sigte og vælge kraft.', x + w/2, y + 144);
      ctx.fillText('Slip for at skyde. Tastatur: piletaster + mellemrum.', x + w/2, y + 168);
      const bidenScore = GOLF.biden?.strokesHole || 3;
      ctx.fillText(`Sleepy Joe brugte ${bidenScore} slag. Slå ham!`, x + w/2, y + 192);
      ctx.font = 'bold 14px system-ui';
      ctx.fillText('Tryk på en tast for at begynde.', x + w/2, y + h - 34);
      ctx.textAlign='left';
      ctx.restore();
      return;
    }

    ctx.restore();
  }

  function golfHandleKeyDown(e, key){
    if (scene !== 'golf') return false;
    if (GOLF.state === 'arrival') return true;
    if (GOLF.state === 'approach'){
      if (key==='arrowleft' || key==='arrowright' || key==='arrowup' || key==='arrowdown'){
        keys.add(key);
        return true;
      }
    }
    if (GOLF.state === 'intro'){
      if (!GOLF.introDismissReady) return true;
      GOLF.introActive = false;
      // Biden already at hole with his score - player goes directly
      GOLF.state = 'aim';
      GOLF.turn = 'player';
      return true;
    }
    if (GOLF.state === 'scorecard'){
      if (key==='enter' || e.code==='Enter'){
        GOLF.state = 'aim';
        GOLF.scorecard = null;
        GOLF.banner = null;
        switchScene('greenland');
        return true;
      }
      return false;
    }
    if (key==='r'){
      if (GOLF.state !== 'scorecard'){
        dropToTee(1);
      }
      return true;
    }
    if (key==='escape' || key==='esc'){
      GOLF.banner = null;
      if (GOLF.bidenTimer){ clearTimeout(GOLF.bidenTimer); GOLF.bidenTimer=null; }
      switchScene('greenland');
      return true;
    }
    if (GOLF.state === 'banner' && GOLF.banner && (key==='enter' || e.code==='Enter')){
      GOLF.banner.until = nowMs();
      return true;
    }
    if (GOLF.state === 'aim' && GOLF.turn === 'player'){
      if (key==='arrowleft'){ GOLF.aimAngle -= 0.12; return true; }
      if (key==='arrowright'){ GOLF.aimAngle += 0.12; return true; }
      if (key==='e' || e.code==='KeyE'){
        GOLF.state = 'charging';
        GOLF.charge.active = true;
        GOLF.charge.power = 0;
        GOLF.charge.dirX = Math.cos(GOLF.aimAngle);
        GOLF.charge.dirY = Math.sin(GOLF.aimAngle);
        return true;
      }
    } else if (GOLF.state === 'charging' && GOLF.turn === 'player'){
      if (key==='arrowleft'){ GOLF.aimAngle -= 0.08; GOLF.charge.dirX = Math.cos(GOLF.aimAngle); GOLF.charge.dirY = Math.sin(GOLF.aimAngle); return true; }
      if (key==='arrowright'){ GOLF.aimAngle += 0.08; GOLF.charge.dirX = Math.cos(GOLF.aimAngle); GOLF.charge.dirY = Math.sin(GOLF.aimAngle); return true; }
    }
    return false;
  }

  function golfHandleKeyUp(e, key){
    if (scene !== 'golf') return false;
    if (GOLF.state === 'arrival') return true;
    if (GOLF.state === 'charging' && GOLF.turn === 'player' && (key==='e' || e.code==='KeyE')){
      GOLF.state = 'rolling';
      GOLF.charge.active = false;
      // Normaliser tastetryk-opladning til [0,1]
      const powerNorm = Math.min(1, Math.max(0, GOLF.charge.power / 720));
      golfStrike(GOLF.aimAngle, powerNorm);
      return true;
    }
    return false;
  }

  function drawTrumpGolfPose(ctx, x, y, opts){
    const prevWalking = player.walking;
    const prevFacing = player.facing;
    const prevX = player.x;
    const prevY = player.y;
    const prevCycle = player.walkCycle;
    const scale = (opts && typeof opts.scale === 'number') ? opts.scale : 1.08;
    const walking = !!(opts && opts.walking);
    const facing = (opts && typeof opts.facing === 'number') ? opts.facing : 1;
    const walkCycle = (opts && typeof opts.walkCycle === 'number') ? opts.walkCycle : player.walkCycle;
    try {
      player.walking = walking;
      player.facing = facing;
      player.walkCycle = walkCycle;
      player.x = 0;
      player.y = 0;
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      drawTrump(0, 0, player.facing);
      ctx.restore();
    } finally {
      player.walking = prevWalking;
      player.facing = prevFacing;
      player.walkCycle = prevCycle;
      player.x = prevX;
      player.y = prevY;
    }
  }

  function drawTrumpGolfStanding(ctx, x, y, scale){
    const opts = (typeof scale === 'number') ? { scale } : null;
    drawTrumpGolfPose(ctx, x, y, opts);
  }

  function drawBidenGolfStanding(ctx, x, y, scale){
    const s = scale || 1;
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    ctx.translate(0, -46);
    // Shoes & legs
    ctx.fillStyle = '#1f1f1f';
    ctx.fillRect(-12, 42, 10, 10);
    ctx.fillRect(2, 42, 10, 10);
    ctx.fillStyle = '#1f3b7a';
    ctx.fillRect(-12, 30, 10, 12);
    ctx.fillRect(2, 30, 10, 12);
    // Suit
    ctx.fillStyle = '#2051a6';
    ctx.fillRect(-18, 6, 36, 30);
    // Shirt + tie
    ctx.fillStyle = '#e3ecff';
    ctx.fillRect(-12, 10, 24, 18);
    ctx.fillStyle = '#64b5f6';
    ctx.fillRect(-2, 10, 4, 23);
    // Head
    ctx.fillStyle = '#f1d2b3';
    ctx.fillRect(-12, -6, 24, 16);
    ctx.fillStyle = '#c0c6cf';
    ctx.fillRect(-14, -12, 28, 8);
    // Sunglasses
    ctx.fillStyle = '#111';
    ctx.fillRect(-10, -1, 8, 4);
    ctx.fillRect(2, -1, 8, 4);
    ctx.fillRect(-2, 0, 4, 2);
    // Mouth
    ctx.fillStyle = '#c25a5a';
    ctx.fillRect(-6, 6, 12, 2);
    ctx.restore();
  }

  function drawGolfClubBase(ctx){
    ctx.save();
    // Shaft
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3.2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(-2, 0);
    ctx.lineTo(34, 0);
    ctx.stroke();
    // Grip
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(-4, 0);
    ctx.lineTo(6, 0);
    ctx.stroke();
    // Club head
    ctx.save();
    ctx.translate(34, 0);
    ctx.fillStyle = '#000';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.fillRect(0, 0, 6, 14);
    ctx.strokeRect(0, 0, 6, 14);
    ctx.restore();
    ctx.restore();
  }

  function drawGolfClubInHand(ctx, x, y, scale, facing){
    const dir = facing >= 0 ? 1 : -1;
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale || 1, scale || 1);
    ctx.translate(dir * 8, -18);
    ctx.rotate(dir * -0.55);
    drawGolfClubBase(ctx);
    ctx.restore();
  }

  function drawGolfClubOnGround(ctx, x, y, scale){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale || 1, scale || 1);
    ctx.rotate(-0.35);
    drawGolfClubBase(ctx);
    ctx.restore();
  }

  const SURFACE_COLORS = {
    fairway: '#5ba64d',
    green: '#8dd35f',
    fringe: '#7fbc54',
    rough: '#3d7934',
    water: '#3c7bd6',
    sand: '#f2deb0',
    trees: '#2e7d32',
    obstacle: '#333333' // Dark gray for obstacles/genstand
  };

  // Optional Text-to-Speech helper with robust fallback captions
  (function initTTS(){
    const TTS = { ready:false, voice:null };
    function pickVoice(){
      try {
        const voices = window.speechSynthesis?.getVoices?.() || [];
        if (!voices.length) return;
        // Prefer en-US, else first
        TTS.voice = voices.find(v=>/en-US/i.test(v.lang)) || voices[0] || null;
        TTS.ready = !!TTS.voice;
      } catch(_){ TTS.ready=false; TTS.voice=null; }
    }
    try { window.speechSynthesis?.addEventListener?.('voiceschanged', pickVoice); } catch(_){ }
    try { pickVoice(); } catch(_){ }
    window.speakLine = function(text, opts){
      // Always show caption fallback
      try { addCaption((opts&&opts.x)||W/2, (opts&&opts.y)||H/2, String(text||''), 1200); } catch(_){ }
      // Try TTS
      try {
        if (!('speechSynthesis' in window)) return false;
        const u = new SpeechSynthesisUtterance(String(text||''));
        if (TTS.voice) u.voice = TTS.voice;
        window.speechSynthesis.speak(u);
        return true;
      } catch(_){ return false; }
    };
  })();

  function fillSurface(ctx, poly){
    ctx.beginPath();
    poly.forEach(([px,py], idx)=> idx ? ctx.lineTo(px,py) : ctx.moveTo(px,py));
    ctx.closePath();
    ctx.fill();
  }

  let trumpHeadSprite = null;
  let bidenHeadSprite = null;

  function ensureTrumpHeadSprite(){
    if (trumpHeadSprite) return trumpHeadSprite;
    const c = document.createElement('canvas');
    c.width = 40; c.height = 36;
    const g = c.getContext('2d');
    drawTrumpHeadHUDIcon(g, c.width, c.height);
    trumpHeadSprite = c;
    return c;
  }

  function ensureBidenHeadSprite(){
    if (bidenHeadSprite) return bidenHeadSprite;
    const c = document.createElement('canvas');
    c.width = 40; c.height = 36;
    const g = c.getContext('2d');
    g.fillStyle = '#2b4f9c';
    g.fillRect(4, 14, 32, 18);
    g.fillStyle = '#f6d6b0';
    g.fillRect(12, 4, 16, 14);
    g.fillStyle = '#c8b890';
    g.fillRect(12, 0, 16, 6);
    g.fillStyle = '#fff';
    g.fillRect(16, 9, 6, 2);
    g.fillRect(22, 9, 6, 2);
    g.fillStyle = '#2b4f9c';
    g.fillRect(16, 11, 4, 1);
    g.fillRect(22, 11, 4, 1);
    g.fillStyle = '#d14a4a';
    g.fillRect(18, 15, 8, 2);
    bidenHeadSprite = c;
    return c;
  }

  function drawTrumpIntroHead(ctx, x, y, scale){
    const sprite = ensureTrumpHeadSprite();
    ctx.drawImage(sprite, x, y, sprite.width*scale, sprite.height*scale);
  }

  function drawBidenIntroHead(ctx, x, y, scale){
    const sprite = ensureBidenHeadSprite();
    ctx.drawImage(sprite, x, y, sprite.width*scale, sprite.height*scale);
  }
// SCENE_GOLF (END)

  // ---------- Glacier explosion system ----------
  let glacierExplosion = {
    active: false,
    waterLevel: 0,
    explosions: [],
    iceChunks: []
  };

  // ---------- Flag drop animation state ----------
  let flagDrop = null; // {x, y, vy, landed}

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         9. SCENE RESET FUNCTIONS                           ║
  // ║  Initialize/reset each scene to starting state                             ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // Helper: Generate coins array from GAME_CONSTANTS config
  function createCoinsFromConfig(configKey) {
    const g = H - world.floor;
    const positions = GAME_CONSTANTS.COINS?.[configKey] || [];
    return positions.map(pos => ({
      x: pos.x * CFG.SCALE,
      y: g + pos.y * CFG.SCALE,
      collected: false,
      type: 'coin'
    }));
  }
// SCENE_GREENLAND (START)
  function resetStateDefaults(){
    GL.state = { flagPlanted:false, bearGone:false, hasTweeted:false, glaciersBlown:false, hasSeenGlaciers:false, mineFlagPlanted:false, larsDialogRounds:0, larsMiniGameStarted:false };
    shopTutorialShown = false;
    if (invEl){
      invEl.classList.add('hidden');
      invEl.setAttribute('aria-hidden','true');
    }
  }

  function resetGreenland(){
    const g = H - world.floor;
    player.x = GAME_CONSTANTS.WORLD.PLAYER_START_X*CFG.SCALE; player.y = g;
    Object.assign(GL.mine,  {x:GAME_CONSTANTS.WORLD.GREENLAND.MINE_X*CFG.SCALE, y:g});
    Object.assign(GL.rig,   {x:GAME_CONSTANTS.WORLD.GREENLAND.RIG_X*CFG.SCALE, y:g});
    Object.assign(GL.heli,  {x:GAME_CONSTANTS.WORLD.GREENLAND.HELI_X*CFG.SCALE, y:g-GAME_CONSTANTS.WORLD.HELI_Y_OFFSET*CFG.SCALE});
    Object.assign(GL.bear,  {x:GAME_CONSTANTS.WORLD.GREENLAND.BEAR_X*CFG.SCALE, y:g, alive:true, hp:4, speakingUntil:0, angry:false, chasing:false, speed:GAME_CONSTANTS.PHYSICS.BEAR_SPEED, facing:1});
    Object.assign(GL.mette, {x:GAME_CONSTANTS.WORLD.GREENLAND.METTE_X*CFG.SCALE - 90*CFG.SCALE, y:g, speakingUntil:0, nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, blownUp:false, vx:0, vy:0, rotation:0});
    Object.assign(GL.shop, { x: 1040*CFG.SCALE, y: g, type:'shop' });
    // Default items start in inventory; keep others available as pickups
    GL.items.forEach(it => {
      if (it.id==='tan' || it.id==='shoes' || it.id==='maga') it.collected = true;
      else it.collected = false;
    });
    GL.flag=null;
    // Reset glaciers - place them on ground level so Trump can interact
    GL.glaciers.forEach((glacier, i) => {
      const baseX = [200, 900][i];
      glacier.x = baseX*CFG.SCALE; 
      glacier.y = g; // Place bottom on ground
      glacier.blown = false;
    });
    GL.state.glaciersBlown = false;
    GL.state.hasSeenGlaciers = false;
    // Initialize floating gold bars from config
    GL.coins = createCoinsFromConfig('GREENLAND_POSITIONS');
    // Reset glacier explosion state
    glacierExplosion.active = false;
    glacierExplosion.waterLevel = 0;
    glacierExplosion.explosions = [];
    glacierExplosion.iceChunks = [];
    // Reset flag drop animation
    flagDrop = null;
    if (!introPlayed) scheduleHeliIntro('Touchdown in Greenland — tremendous ice! Helicopter goes anywhere.');
    // init clouds
    CLOUDS = [];
    const n = 6; for (let i=0;i<n;i++){
      CLOUDS.push({ x: Math.random()*W, y: 40*CFG.SCALE + Math.random()*120*CFG.SCALE, w: 80*CFG.SCALE + Math.random()*100*CFG.SCALE, h: 24*CFG.SCALE, vx: (10+Math.random()*20)*CFG.SCALE, a: 0.15+Math.random()*0.1 });
    }
    // Position and ensure pickups
    // Ensure default inventory items are present
    ensureDefaultInventory();
  }
  // SCENE_GREENLAND (END)

  // SCENE_OVAL (START)
  // Guest data for Presidential Decisions mini-game
  const OVAL_GUESTS = [
    {
      id: 'journalist',
      name: 'CNN Reporter',
      question: 'Hr. Præsident, vil du fordømme vold ved Capitol?',
      yesText: 'Nej! Det var en fredelig protest!',
      noText: 'Selvfølgelig fordømmer jeg al vold!',
      correctAnswer: 'no', // Trick: "JA" fordømmer = dårligt for MAGA
      requiresTan: false,
      appearance: { hair: '#3a2a1a', suit: '#1a1a2e', tie: '#8b0000', isF: true, hasGlasses: true, hasNotepad: true },
      newsCorrect: 'TRUMP NÆGTER FORDØMMELSE! MAGA-basen jubler',
      newsWrong: 'TRUMP FORDØMMER 6. JANUAR! "Han svigtede os" siger vælgere'
    },
    {
      id: 'vance',
      name: 'VP JD Vance',
      question: 'Sir, bør vi SÆNKE skatten for milliardærer?',
      yesText: 'JA! Trickle down virker perfekt!',
      noText: 'Nej, de betaler rigeligt...',
      correctAnswer: 'yes', // Classic GOP
      requiresTan: false,
      appearance: { hair: '#3a3a3a', suit: '#1a1a2e', tie: '#8b0000', isF: false, hasBeard: true, bigHead: true },
      newsCorrect: 'SKATTELETTELSER TIL DE RIGE! "Genialt" siger Wall Street',
      newsWrong: 'TRUMP SVIGTER DONORER! Milliardærer truer med at skifte parti'
    },
    {
      id: 'shaman',
      name: 'QAnon Shaman',
      question: 'Sir, er månelandingen FAKE?',
      yesText: 'Ja! NASA lyver om alt!',
      noText: 'Nej, Amerika landede virkelig!',
      correctAnswer: 'no', // Trick: Patriotisk at støtte USA's bedrifter
      requiresTan: true,
      noTanText: "Du er for bleg til at være vores leder! Ægte Trump har en SMUK tan!",
      appearance: { isShaman: true },
      newsCorrect: 'TRUMP HYLDER MÅNELANDING! "Amerikas største triumf"',
      newsWrong: 'TRUMP KALDER NASA FOR SVINDLERE! Astronauter rasende',
      triggersBonus: true
    },
    {
      id: 'elon',
      name: 'Elon Musk',
      question: 'Mr. President, skal Twitter FORBLIVE X?',
      yesText: 'Ja! X er et genialt navn!',
      noText: 'Nej, bring Twitter-navnet tilbage!',
      correctAnswer: 'yes', // Support your ally
      requiresTan: false,
      appearance: { hair: '#2a2a2a', suit: '#1a1a1a', tie: null, isF: false, isElon: true },
      newsCorrect: 'TRUMP ELSKER X! "Musk er et geni" siger præsidenten',
      newsWrong: 'TRUMP KRITISERER MUSK! Teknologi-alliance smuldrer'
    },
    {
      id: 'mtg',
      name: 'Marjorie T. Greene',
      question: 'Hr. Præsident, er demokrater FAKTISK mennesker?',
      yesText: 'Nej! De er reptiler fra rummet!',
      noText: 'Ja, de er bare dumme mennesker...',
      correctAnswer: 'no', // Trick: Selv Trump ville ikke sige de er rumvæsner
      requiresTan: false,
      appearance: { hair: '#e6c866', suit: '#c41e3a', tie: null, isF: true, hasFlag: true },
      newsCorrect: 'TRUMP: "Demokrater er mennesker - bare fejltagelser"',
      newsWrong: 'TRUMP KALDER DEMOKRATER ALIENS! FN kræver forklaring'
    },
    {
      id: 'foxnews',
      name: 'Fox News Vært',
      question: 'Hr. Præsident, TABTE du valget i 2020?',
      yesText: 'Ja, Biden vandt fair og square...',
      noText: 'NEJ! Det blev STJÅLET fra mig!',
      correctAnswer: 'no', // Obviously deny
      requiresTan: false,
      appearance: { hair: '#8b6914', suit: '#1a1a2e', tie: '#002868', isF: true, hasMic: true },
      newsCorrect: 'TRUMP: "VALGET VAR STJÅLET!" MAGA-basen mobiliserer',
      newsWrong: 'CHOK! TRUMP INDRØMMER NEDERLAG! "Biden vandt" siger han'
    }
  ];

  // Bonus question after MAGA supporter (only shown if answered correctly)
  const OVAL_BONUS = {
    question: 'Prøv at trykke på den store røde knap!',
    duration: 4000 // How long to show the hint
  };

  function resetOval(){
    const g = H - world.floor;
    // Trump starts at helicopter position (will auto-walk to desk)
    player.x = 200*CFG.SCALE; player.y = g;
    Object.assign(OV.door,  {x:140*CFG.SCALE, y:g});
    Object.assign(OV.aide,  {x:720*CFG.SCALE, y:g, speakingUntil:0});
    Object.assign(OV.heli,  {x:160*CFG.SCALE, y:g-18*CFG.SCALE});
    Object.assign(OV.yes,   {x:980*CFG.SCALE, y:g, speakingUntil:0});
    // yes-men members state for blink/nod
    OV.yes.members = [
      { nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, isF:true },
      { nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, isF:false },
      { nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, isF:true }
    ];
    // Initialize 3 desk buttons: JA (green), NEJ (blue), SURPRISE (big red)
    const deskTopY = H - world.floor + 30*CFG.SCALE - 36*CFG.SCALE;
    const deskCenterX = 420*CFG.SCALE + 170*CFG.SCALE; // center of desk
    OV.buttons = [
      { x: deskCenterX - 70*CFG.SCALE, y: deskTopY, w: 36*CFG.SCALE, h: 14*CFG.SCALE, color: '#2e7d32', type: 'button', label: 'JA', action: 'yes' },
      { x: deskCenterX + 10*CFG.SCALE, y: deskTopY, w: 36*CFG.SCALE, h: 14*CFG.SCALE, color: '#1565c0', type: 'button', label: 'NEJ', action: 'no' },
      { x: deskCenterX + 120*CFG.SCALE, y: deskTopY, w: 70*CFG.SCALE, h: 36*CFG.SCALE, color: '#c62828', type: 'button', label: '', action: 'surprise', isDoomsday: true }
    ];
    // Initialize floating gold bars from config
    OV.coins = createCoinsFromConfig('OVAL_POSITIONS');
    // Reset guest NPC position (off-screen right)
    Object.assign(OV.guest, {x: W + 50*CFG.SCALE, y: g, visible: false, speakingUntil: 0, say: ''});

    // Check if we're resuming after getting tan
    const deskX = 560*CFG.SCALE; // Trump's position behind desk
    const wasWaitingForTan = OV.decisions && OV.decisions.needsTan && OV.decisions.phase === 'paused';

    if (wasWaitingForTan && (player.tanLevel || 0) >= 2) {
      // Resume from where we left off - Trump has tan now!
      OV.decisions.active = true;
      OV.decisions.phase = 'walking';
      OV.decisions.needsTan = false;
      OV.decisions.trumpAtDesk = false;
      OV.decisions.trumpTargetX = deskX;
      OV.decisions.guestX = W + 50*CFG.SCALE;
      OV.decisions.resumeGuest = true; // Flag to resume current guest, not start next
      // Ensure these exist from before (keep currentGuestIndex, correctAnswers, guestOrder, guestResults, approvalRating)
      OV.decisions.guestResults = OV.decisions.guestResults || [];
      OV.decisions.approvalRating = OV.decisions.approvalRating || 0;
    } else if (!wasWaitingForTan) {
      // Fresh start - Initialize Presidential Decisions mini-game
      OV.decisions = {
        active: true,
        phase: 'walking', // Trump walks to desk first
        currentGuestIndex: -1,
        correctAnswers: 0,
        guestX: W + 50*CFG.SCALE,
        guestTargetX: 820*CFG.SCALE, // Where guest stands to ask question (moved right)
        answerFeedback: null,
        trumpAtDesk: false,
        trumpTargetX: deskX,
        needsTan: false,
        guestOrder: [...shuffleArray([0, 1, 3, 4, 5]).slice(0, 2), 2], // Pick 2 random non-Shaman guests, Shaman (index 2) always last
        approvalRating: 0, // MAGA approval starts at 0%
        breakingNews: null, // { text, until, isGood }
        guestResults: [] // Track which guests answered correctly: [{id, correct}]
      };
    }
    // If wasWaitingForTan but still no tan, keep decisions in paused state
  }

  // Helper to shuffle array
  function shuffleArray(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Update logic for Presidential Decisions mini-game
  function updateOvalDecisions(dt) {
    const d = OV.decisions;
    const walkSpeed = 180 * CFG.SCALE; // pixels per second

    if (d.phase === 'walking') {
      // Trump walks to desk
      if (player.x < d.trumpTargetX) {
        player.x += walkSpeed * dt;
        player.facing = 1;
        player.walking = true;
        if (player.x >= d.trumpTargetX) {
          player.x = d.trumpTargetX;
          player.walking = false;
          d.trumpAtDesk = true;
          d.phase = 'waiting';
          // Start guest after short delay
          if (d.resumeGuest) {
            // Resuming after getting tan - start current guest again (don't increment)
            d.resumeGuest = false;
            setTimeout(() => { if (d.phase === 'waiting') resumeCurrentGuest(); }, 800);
          } else {
            // Normal flow - start next guest
            setTimeout(() => { if (d.phase === 'waiting') startNextGuest(); }, 800);
          }
        }
      }
    }
    else if (d.phase === 'guest_entering') {
      // Guest walks in from right
      if (d.guestX > d.guestTargetX) {
        d.guestX -= walkSpeed * dt;
        if (d.guestX <= d.guestTargetX) {
          d.guestX = d.guestTargetX;
          d.phase = 'guest_asking';
          // Show guest's question
          const guestIdx = d.guestOrder[d.currentGuestIndex];
          const guest = OVAL_GUESTS[guestIdx];

          // Check tan requirement for MAGA supporter (must buy AND apply tan - level 2+)
          if (guest.requiresTan && (player.tanLevel || 0) < 2) {
            // No tan or not applied! Session ends - Trump must go get selvbruner and use it
            OV.guest.say = guest.noTanText;
            OV.guest.speakingUntil = nowMs() + 6000;
            say(player, "Jeg må hellere finde en selvbruner!", 4000);
            setTimeout(() => {
              d.phase = 'guest_leaving';
              d.needsTan = true; // Flag that we failed due to no tan
            }, 6000);
          } else {
            OV.guest.say = guest.question;
            OV.guest.speakingUntil = nowMs() + 8000; // Long enough to read and answer
          }
        }
      }
    }
    else if (d.phase === 'guest_leaving') {
      // Guest walks out to right
      if (d.guestX < W + 50*CFG.SCALE) {
        d.guestX += walkSpeed * dt;
        if (d.guestX >= W + 50*CFG.SCALE) {
          OV.guest.visible = false;

          // If failed due to no tan, end session - Trump can roam freely
          if (d.needsTan) {
            d.phase = 'paused'; // Session paused, not failed
            d.active = false; // Allow free movement
            say(player, 'Get a tan from the Greenland shop, then come back!', 3000);
            return;
          }

          // Check if more guests or game over
          if (d.correctAnswers >= 3) {
            d.phase = 'complete';
            d.active = false;
            say(player, 'Three tremendous decisions! The best president!', 2500);
            // Could trigger win condition or unlock something
          } else if (d.currentGuestIndex >= 2) {
            // All guests done but didn't get 3 correct
            d.phase = 'failed';
            d.active = false;
            say(player, 'Not enough correct decisions...', 2000);
          } else {
            d.phase = 'waiting';
            setTimeout(() => { if (d.phase === 'waiting') startNextGuest(); }, 1000);
          }
        }
      }
    }
    else if (d.phase === 'answered') {
      // Brief pause after answer before guest leaves
      if (d.answerFeedback && nowMs() > d.answerFeedback.until) {
        d.answerFeedback = null;
        // Check if MAGA supporter should give bonus hint
        if (d.showBonus) {
          d.phase = 'bonus_asking';
          d.showBonus = false;
          // MAGA supporter gives bonus hint as afterthought
          OV.guest.say = "Åh, og forresten... " + OVAL_BONUS.question;
          OV.guest.speakingUntil = nowMs() + OVAL_BONUS.duration;
          d.bonusShownUntil = nowMs() + OVAL_BONUS.duration;
        } else {
          d.phase = 'guest_leaving';
        }
      }
    }
    else if (d.phase === 'bonus_asking') {
      // MAGA supporter showing bonus hint, wait for duration then leave
      if (nowMs() > d.bonusShownUntil) {
        d.phase = 'guest_leaving';
      }
    }

    // Update guest position for drawing
    OV.guest.x = d.guestX;
  }

  function startNextGuest() {
    const d = OV.decisions;
    d.currentGuestIndex++;
    if (d.currentGuestIndex >= 3) {
      d.phase = 'complete';
      return;
    }
    d.guestX = W + 50*CFG.SCALE;
    OV.guest.visible = true;
    d.phase = 'guest_entering';
  }

  function resumeCurrentGuest() {
    // Resume the current guest (after returning with tan) - don't increment index
    const d = OV.decisions;
    d.guestX = W + 50*CFG.SCALE;
    OV.guest.visible = true;
    d.phase = 'guest_entering';
  }

  function handleOvalAnswer(answer) {
    const d = OV.decisions;
    if (d.phase !== 'guest_asking') return;

    if (answer === 'surprise') {
      // Nuclear button! Game over
      launchMissile();
      d.active = false;
      return;
    }

    const guestIdx = d.guestOrder[d.currentGuestIndex];
    const guest = OVAL_GUESTS[guestIdx];
    const isCorrect = (answer === guest.correctAnswer);

    if (isCorrect) {
      d.correctAnswers++;
      d.approvalRating = Math.min(100, (d.approvalRating || 0) + 33); // +33% (1/3) per correct
      if (d.approvalRating >= 100) awardMedal('oval');
      const responseText = answer === 'yes' ? guest.yesText : guest.noText;
      say(player, responseText, 1800);
      d.answerFeedback = { correct: true, text: 'MAGA godkender! ✓', until: nowMs() + 2000 };
      d.breakingNews = { text: guest.newsCorrect, until: nowMs() + 4000, isGood: true };
      d.guestResults.push({ id: guest.id, correct: true });
      SFX.coin && SFX.coin();
      praiseChoir(); // Yes-group cheers!

      // Check for bonus trigger (MAGA supporter correct answer)
      if (guest.triggersBonus) {
        d.showBonus = true; // Will show bonus question after answer feedback
      }
    } else {
      d.approvalRating = Math.max(0, (d.approvalRating || 0) - 15); // -15% per wrong
      const responseText = answer === 'yes' ? guest.yesText : guest.noText;
      say(player, responseText, 1800);
      d.answerFeedback = { correct: false, text: 'MAGA afviser! ✗', until: nowMs() + 2000 };
      d.breakingNews = { text: guest.newsWrong, until: nowMs() + 4000, isGood: false };
      d.guestResults.push({ id: guest.id, correct: false });
      SFX.error && SFX.error();
      booChoir(); // Yes-group boos!
    }

    OV.guest.speakingUntil = 0; // Stop showing question
    d.phase = 'answered';
  }
  // SCENE_OVAL (END)

  // SCENE_KREMLIN (START)
  function resetKremlin(){
    const g = H - world.floor;
    player.x = 560*CFG.SCALE; player.y = g;
    Object.assign(KR.door,  {x:120*CFG.SCALE, y:g});
    Object.assign(KR.putin, {x: (W - 220*CFG.SCALE), y:g, speakingUntil:0, nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28});
    Object.assign(KR.heli,  {x:160*CFG.SCALE, y:g-18*CFG.SCALE});
    // Initialize security cameras (two cameras for more challenge)
    const now = nowMs();
    Object.assign(KR.camera, {x: W/2, y: H/3, angle: Math.PI/4, sweepStart: now, discovered: false, flashUntil: 0});
    KR.cameras = [
      {x: W*0.3, y: H/3, angle: Math.PI/4, sweepStart: now, discovered: false, flashUntil: 0, sweepOffset: 0},
      {x: W*0.7, y: H/3, angle: Math.PI/4, sweepStart: now, discovered: false, flashUntil: 0, sweepOffset: 0.5} // offset so they sweep opposite
    ];
    KR.statues = [
      {id:'stat1', name:'Guldstatue I', x:(420*CFG.SCALE), y:g, w:18, h:30, type:'statue', collected:false, variant:1},
      {id:'stat2', name:'Guldstatue II', x:(560*CFG.SCALE), y:g, w:18, h:30, type:'statue', collected:false, variant:2},
      {id:'stat3', name:'Guldstatue III', x:(700*CFG.SCALE), y:g, w:18, h:30, type:'statue', collected:false, variant:3}
    ];
    // Initialize floating gold bars from config
    KR.coins = createCoinsFromConfig('KREMLIN_POSITIONS');
  }
  // SCENE_KREMLIN (END)

  // SCENE_EPSTEIN (START)
  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         10. EPSTEIN MINI-GAME                              ║
  // ║  Document scrolling game, name clicking, birthday art                      ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Epstein Scene Functions ----------
  // DUMMY_NAMES, TRUMP_NAME_VARIATIONS, DOC_TEMPLATES loaded from game-text-data JSON block

  function generateDocument() {
    const lines = [];
    const numLines = 15 + Math.floor(Math.random() * 8); // 15-23 lines per document
    for (let i = 0; i < numLines; i++) {
      const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
      const dummyName = DUMMY_NAMES[Math.floor(Math.random() * DUMMY_NAMES.length)];
      lines.push({
        text: template.replace('{name}', dummyName),
        containsTrump: false,
        protectedName: false,
        redacted: false
      });
    }
    return lines;
  }
  
  function resetEpstein() {
    const g = H - world.floor;
    player.x = 560*CFG.SCALE; 
    player.y = g;
    
    // Reset epstein game state
    Object.assign(EP, {
      papers: [],
      currentLine: 0,
      scrollSpeed: 0.5,
      scrollY: -120 * CFG.SCALE, // Start with lines below hit zone so first names can be caught
      timeElapsed: 0,
      missedTrumps: 0,
      foundTrumps: 0,
      gameActive: false,
      gameStartTime: 0,
      trumpLocations: [],
      generatedDocs: false,
      protectedClicks: 0,
      failedByProtected: false,
      assistUntil: 0,
      toasts: [],
      crosses: [],
      visibleDoc: 1,
      paused: false,
      finalArt: { redacted: false, redactStart: 0 },
      finalArtRect: null,
      artHeightPx: 0,
      // Guitar Hero style
      markerAnim: null,
      lastRedactTime: 0
    });
    
    // Generate documents - base content
    for (let i = 0; i < 12; i++) {
      EP.papers.push(generateDocument());
    }
    EP.generatedDocs = true;

    // Distribute exactly N Trump targets more evenly across documents
    let placedTrump = 0;
    const maxAttempts = 4000;
    let attempts = 0;
    const nDocs = EP.papers.length;
    for (let i = 0; i < EP.totalTrumpTargets && attempts < maxAttempts; i++) {
      // Evenly map index to document range, then add a small random jitter of ±1 doc
      const baseDoc = Math.floor((i * nDocs) / Math.max(1, EP.totalTrumpTargets));
      const jitter = Math.max(0, Math.min(nDocs-1, baseDoc + (Math.random()<0.5?-1:1)));
      const candidates = [baseDoc, jitter].filter((v,idx,arr)=>v>=0 && v<nDocs && arr.indexOf(v)===idx);
      let placed = false;
      for (const d of candidates){
        for (let tries=0; tries<40; tries++){
          const doc = EP.papers[d];
          const li = Math.floor(Math.random() * doc.length);
          const line = doc[li];
          if (line.containsTrump || line.protectedName) continue;
          const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
          const variant = TRUMP_NAME_VARIATIONS[Math.floor(Math.random() * TRUMP_NAME_VARIATIONS.length)];
          line.text = template.replace('{name}', variant);
          line.containsTrump = true;
          placedTrump++; placed = true; break;
        }
        if (placed) break;
      }
      if (!placed) attempts++;
    }

    // Ensure last document contains at least one Trump line
    if (nDocs > 0) {
      const last = EP.papers[nDocs-1];
      const hasTrump = last.some(l => l.containsTrump);
      if (!hasTrump) {
        for (let tries=0; tries<200; tries++){
          const li = Math.floor(Math.random()*last.length);
          const line = last[li];
          if (!line.containsTrump && !line.protectedName){
            const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
            const variant = TRUMP_NAME_VARIATIONS[Math.floor(Math.random() * TRUMP_NAME_VARIATIONS.length)];
            line.text = template.replace('{name}', variant);
            line.containsTrump = true;
            placedTrump++;
            break;
          }
        }
      }
    }
    
    // Insert protected names (Bill Clinton, Bill Gates) — e.g., 3 each
    const protectedCounts = { 'Bill Clinton': 3, 'Bill Gates': 3 };
    for (const [pname, count] of Object.entries(protectedCounts)){
      let placed = 0, tries = 0;
      while (placed < count && tries++ < maxAttempts) {
        const d = Math.floor(Math.random() * EP.papers.length);
        const doc = EP.papers[d];
        const li = Math.floor(Math.random() * doc.length);
        const line = doc[li];
        if (line.containsTrump || line.protectedName) continue;
        const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
        line.text = template.replace('{name}', pname);
        line.protectedName = true;
        placed++;
      }
    }

    // Instruction card - Guitar Hero style
    openInfoCard(
      `Trump er NATURLIGVIS ikke nævnt i Epstein-papirerne.\nOverstreg de ${EP.totalTrumpTargets} fejltagelser, så demokraternes konspirationsteorier ikke spredes!\n\n🎸 Tryk [E] når RØDE navne rammer båndet\n🛑 Tryk IKKE på BLÅ (Clinton/Gates)\n⚠️ ${EP.missesAllowed+1}+ miss = nederlag\n⏸️ P for pause/genoptag\n\nTryk en vilkårlig tast for at begynde`,
      () => { EP.gameActive = true; EP.gameStartTime = nowMs(); closeInfoCard(); }
    );
    
    // Position door for exit
    Object.assign(EP.door, {x: 120*CFG.SCALE, y: g});
  }
  
  function updateEpsteinGame() {
    if (!EP.gameActive) return;
    if (EP.paused) return;
    
    const currentTime = nowMs();
    EP.timeElapsed = currentTime - (EP.gameStartTime || currentTime);
    
    // Increase scroll speed from higher start to higher end based on scroll progress
    const paperY = H * 0.1;
    const paperH = H * 0.8;
    const lineHeight = 20 * CFG.SCALE;
    // compute total content height (30px top + headers + lines + gaps + final art)
    let totalHeight = 30 * CFG.SCALE; 
    for (let d = 0; d < EP.papers.length; d++) {
      totalHeight += lineHeight * 1.5; // header
      totalHeight += EP.papers[d].length * lineHeight; // lines
      totalHeight += lineHeight; // gap
    }
    // Include final art height if known (fallback to estimate)
    totalHeight += (EP.artHeightPx || 320 * CFG.SCALE);
    const startY = paperY + 30 * CFG.SCALE - EP.scrollY;
    const scrolled = Math.max(0, Math.min(totalHeight, (paperY + 30 * CFG.SCALE) - startY));
    const k = totalHeight > 0 ? (scrolled / totalHeight) : 0;
    EP.scrollSpeed = (1.8 + k * 2.6) * 1.25; // +25% tempo, higher base for harder start
    // Adaptive assist: slow slightly for a few seconds after a miss
    if (EP.assistUntil && nowMs() < EP.assistUntil) EP.scrollSpeed *= 0.85;
    
    // Update scroll position - reduced base speed, with precise hold at final art if requested
    const scrollDelta = EP.scrollSpeed * 0.75 * CFG.SCALE;
    let nextScroll = EP.scrollY + scrollDelta;
    // Stop scrolling when art is visible - also during sharpie animation
    const sharpieAnimating = EP.finalArt && EP.finalArt.redacted && EP.finalArt.redactStart &&
                             (nowMs() - EP.finalArt.redactStart < 2500);
    if (EP.stopAtArt && EP.finalArtRect && (!(EP.finalArt && EP.finalArt.redacted) || sharpieAnimating)) {
      const targetTop = paperY + (EP.holdAtArtMargin || 40) * CFG.SCALE;
      const artTopNow = EP.finalArtRect.y; // already includes current scrollY
      const artTopNext = artTopNow - scrollDelta; // after applying delta, art moves up by delta
      if (artTopNext <= targetTop || sharpieAnimating) {
        // Clamp so after updating, art sits exactly at targetTop (or hold during animation)
        if (!sharpieAnimating) {
          nextScroll = EP.scrollY + (artTopNow - targetTop);
        } else {
          nextScroll = EP.scrollY; // Hold position during sharpie animation
        }
        EP.atArtHold = true;
      } else {
        EP.atArtHold = false;
      }
    } else {
      EP.atArtHold = false;
    }
    EP.scrollY = nextScroll;
    
    // Check for missed Trump names
    checkMissedTrumps();
    
    // End conditions
    if (EP.failedByProtected || (EP.protectedClicks > (EP.protectedLimit||0))) { endEpsteinGame('protected_click'); return; }
    if (EP.missedTrumps > EP.missesAllowed) { endEpsteinGame('misses'); return; }
    // No auto-finish; we stop at the drawing and wait for click
  }
  
  function drawEpsteinScene() {
    // Desktop background
    ctx.fillStyle = '#8B4513'; // Dark wood desk
    ctx.fillRect(0, 0, W, H);
    
    // Paper area (white background)
    const paperX = W * 0.2;
    const paperY = H * 0.1; 
    const paperW = W * 0.6;
    const paperH = H * 0.8;
    
    ctx.fillStyle = '#f8f8f8'; // Off-white paper
    ctx.fillRect(paperX, paperY, paperW, paperH);
    
    // Paper shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(paperX + 4, paperY + 4, paperW, paperH);
    
    // Draw document lines
    if (EP.papers.length > 0) {
      ctx.save();
      
      // Clip to paper area
      ctx.beginPath();
      ctx.rect(paperX, paperY, paperW, paperH);
      ctx.clip();
      
      drawDocumentContent(paperX, paperY, paperW, paperH);

      ctx.restore();
    }

    // Draw Guitar Hero hit zone band
    if (EP.gameActive) {
      const zone = getEpsteinHitZone();
      ctx.save();

      // Semi-transparent band
      ctx.fillStyle = 'rgba(255, 215, 0, 0.15)'; // Golden tint
      ctx.fillRect(paperX, zone.top, paperW, zone.height);

      // Top and bottom lines
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
      ctx.lineWidth = 3 * CFG.SCALE;
      ctx.beginPath();
      ctx.moveTo(paperX, zone.top);
      ctx.lineTo(paperX + paperW, zone.top);
      ctx.moveTo(paperX, zone.bottom);
      ctx.lineTo(paperX + paperW, zone.bottom);
      ctx.stroke();

      // Center line (sweet spot)
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
      ctx.lineWidth = 1 * CFG.SCALE;
      ctx.setLineDash([5*CFG.SCALE, 5*CFG.SCALE]);
      ctx.beginPath();
      ctx.moveTo(paperX, zone.centerY);
      ctx.lineTo(paperX + paperW, zone.centerY);
      ctx.stroke();
      ctx.setLineDash([]);

      // E key indicator on the left
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      const keySize = 36 * CFG.SCALE;
      const keyX = paperX - keySize - 15*CFG.SCALE;
      const keyY = zone.centerY - keySize/2;
      ctx.fillRect(keyX, keyY, keySize, keySize);
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 2 * CFG.SCALE;
      ctx.strokeRect(keyX, keyY, keySize, keySize);
      ctx.fillStyle = '#FFD700';
      ctx.font = `bold ${20*CFG.SCALE}px system-ui`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('E', keyX + keySize/2, zone.centerY);
      ctx.textBaseline = 'alphabetic';

      ctx.restore();
    }

    // Draw marker/tusser animation
    if (EP.markerAnim) {
      const now = nowMs();
      const elapsed = now - EP.markerAnim.startTime;
      const progress = Math.min(1, elapsed / EP.markerAnim.duration);

      if (progress < 1) {
        ctx.save();
        const anim = EP.markerAnim;
        const fontSize = Math.floor(13 * CFG.SCALE);

        // Draw marker/tusser sprite moving across text
        const markerX = anim.x + anim.width * progress;
        const markerY = anim.y;
        const markerW = 18 * CFG.SCALE;
        const markerH = 28 * CFG.SCALE;

        // Marker body (black Sharpie style)
        ctx.fillStyle = '#1a1a1a';
        // Marker cap
        ctx.beginPath();
        ctx.ellipse(markerX + markerW/2, markerY - markerH*0.1, markerW/2, markerH*0.15, 0, 0, Math.PI*2);
        ctx.fill();
        // Marker body
        ctx.fillRect(markerX, markerY, markerW, markerH * 0.7);
        // Marker tip (angled)
        ctx.beginPath();
        ctx.moveTo(markerX, markerY + markerH * 0.7);
        ctx.lineTo(markerX + markerW, markerY + markerH * 0.7);
        ctx.lineTo(markerX + markerW/2, markerY + markerH);
        ctx.closePath();
        ctx.fill();

        // Marker highlight
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(markerX + markerW*0.1, markerY + markerH*0.1, markerW*0.2, markerH*0.5);

        // Note: Redaction trail is handled by line.redacted + line.redactAt animation in drawDocumentContent

        ctx.restore();
      } else {
        EP.markerAnim = null;
      }
    }
    // Doc progress label removed per request

    // Draw HUD
    drawEpsteinHUD();

    // Paused overlay
    if (EP.gameActive && EP.paused) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${24*CFG.SCALE}px system-ui`;
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', W/2, H/2);
      ctx.restore();
    }

    // Draw toasts overlay (cross/arrow overlay removed for cleaner UX)
    if (EP.toasts && EP.toasts.length){
      const nowt = nowMs();
      EP.toasts = EP.toasts.filter(t => (nowt - t.start) < t.ttl);
      EP.toasts.forEach(t => {
        const k = (nowt - t.start)/t.ttl; const a = 1 - k; const y = t.y - 12*CFG.SCALE*k;
        ctx.save(); ctx.globalAlpha = Math.max(0, Math.min(1,a)); ctx.fillStyle = t.color || '#fff'; ctx.font = `${12*CFG.SCALE}px system-ui`; ctx.textAlign='center';
        ctx.fillText(t.text, t.x, y); ctx.restore();
      });
    }
    
    // Update trump locations for click detection

    if (mouse.active) {
      let overTrump = false;
      for (let i = 0; i < EP.trumpLocations.length; i++) {
        const hit = EP.trumpLocations[i];
        if (hit.kind === 'trump' && mouse.x >= hit.x && mouse.x <= hit.x + hit.width && mouse.y >= hit.y && mouse.y <= hit.y + hit.height) {
          overTrump = true;
          break;
        }
      }
      let overArt = false;
      if (!overTrump && EP.finalArtRect && !(EP.finalArt && EP.finalArt.redacted)) {
        const r = EP.finalArtRect;
        if (mouse.x >= r.x && mouse.x <= r.x + r.w && mouse.y >= r.y && mouse.y <= r.y + r.h) {
          overArt = true;
        }
      }
      setCanvasCursor((overTrump || overArt) ? 'pointer' : 'default');
    } else {
      setCanvasCursor('default');
    }
    
    // Debug: Draw click areas (optional - remove later)
    if (CFG.DEBUG) {
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 1;
      EP.trumpLocations.forEach(trump => {
        ctx.strokeRect(trump.x, trump.y, trump.width, trump.height);
      });
    }
    
    // Draw door when game is not active
    if (!EP.gameActive) {
      drawDoor(EP.door.x, EP.door.y);
    }
    
    // Update game logic
    updateEpsteinGame();
  }
  
  function drawDocumentContent(paperX, paperY, paperW, paperH) {
    const lineHeight = 20 * CFG.SCALE;
    const fontSize = Math.floor(13 * CFG.SCALE);
    const leftMargin = paperX + 20 * CFG.SCALE;
    
    ctx.fillStyle = '#222';
    ctx.font = `${fontSize}px monospace`; // Monospace for document feel
    ctx.textAlign = 'left';
    
    let yPos = paperY + 30 * CFG.SCALE - EP.scrollY;
    let lineIndex = 0;
    
    // Clear trump locations for this frame
    EP.trumpLocations = [];
    
    // Draw all document lines
    EP.papers.forEach((document, docIndex) => {
      // Compute doc bounds to update visibleDoc (for HUD label)
      const docStartY = yPos;
      const docHeight = (lineHeight * 1.5) + (document.length * lineHeight) + lineHeight;
      const docEndY = docStartY + docHeight;
      const centerY = paperY + paperH/2;
      if (centerY >= docStartY && centerY < docEndY) {
        EP.visibleDoc = docIndex + 1;
      }
      // Document header
      ctx.fillStyle = '#666';
      ctx.font = `bold ${fontSize}px monospace`;
      ctx.fillText(`--- CLASSIFIED DOCUMENT ${docIndex + 1} ---`, leftMargin, yPos);
      yPos += lineHeight * 1.5;
      lineIndex++;
      
      ctx.fillStyle = '#222';
      ctx.font = `${fontSize}px monospace`;
      
      document.forEach((line, idx) => {
        if (yPos > paperY - lineHeight && yPos < paperY + paperH + lineHeight) {
          if (line.redacted) {
            // Draw redaction (animated black bar if recently redacted)
            ctx.fillStyle = '#000';
            const textWidth = ctx.measureText(line.text).width;
            let p = 1;
            if (line.redactAt) {
              p = Math.max(0, Math.min(1, (nowMs() - line.redactAt) / 300));
            }
            ctx.fillRect(leftMargin, yPos - fontSize * 0.7, textWidth * p, fontSize);
          } else {
            // Normal text
            if (line.containsTrump || line.protectedName) {
              // Highlight targets
              const isTrump = !!line.containsTrump;
              const bg = isTrump ? '#ffcccc' : '#cce5ff';
              const tx = isTrump ? '#d32f2f' : '#1565c0';
              ctx.fillStyle = bg; // background
              // Measure with bold font to match draw
              ctx.font = `bold ${fontSize}px monospace`;
              const textWidth = ctx.measureText(line.text).width;
              ctx.fillRect(leftMargin - 2, yPos - fontSize * 0.8, textWidth + 4, fontSize * 1.1);
              ctx.fillStyle = tx;
              ctx.fillText(line.text, leftMargin, yPos);
              ctx.font = `${fontSize}px monospace`; // Reset font

              // Assist highlight: briefly outline Trump targets after a miss
              if (isTrump && EP.assistUntil && nowMs() < EP.assistUntil) {
                const t = nowMs();
                const pulse = 0.5 + 0.5 * Math.sin((t/200) % (Math.PI*2));
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = `rgba(211,47,47,${0.6 + 0.4*pulse})`;
                ctx.lineWidth = 2 + 2*pulse;
                ctx.strokeRect(leftMargin - 4, yPos - fontSize * 0.9, textWidth + 8, fontSize * 1.3);
                ctx.restore();
              }
            } else {
              ctx.fillStyle = '#222';
              ctx.fillText(line.text, leftMargin, yPos);
            }
            
            // Store click targets for detection (Trump + protected) with generous padding
            if ((line.containsTrump || line.protectedName) && !line.redacted) {
              ctx.font = `bold ${fontSize}px monospace`;
              const textWidth = ctx.measureText(line.text).width;
              ctx.font = `${fontSize}px monospace`;
              const kind = line.containsTrump ? 'trump' : 'protected';
              // Dynamic padding grows with speed to keep clicks easy at high tempo
              let padX = (40 + (EP.scrollSpeed||1)*30) * CFG.SCALE;
              let padY = (18 + (EP.scrollSpeed||1)*12) * CFG.SCALE;
              // Clamp hitbox growth to sensible bounds
              padX = Math.max(20*CFG.SCALE, Math.min(padX, 220*CFG.SCALE));
              padY = Math.max(10*CFG.SCALE, Math.min(padY, 90*CFG.SCALE));
              EP.trumpLocations.push({
                x: (leftMargin - 2) - padX,
                y: (yPos - fontSize * 0.8) - padY,
                width: (textWidth + 4) + 2*padX,
                height: (fontSize * 1.1) + 2*padY,
                lineIndex: lineIndex,
                docIndex: docIndex,
                lineInDoc: idx,
                kind
              });
            }
          }
        }
        
        yPos += lineHeight;
        lineIndex++;
      });
      
      yPos += lineHeight; // Space between documents
    });

    // Final art piece (Birthday drawing homage) as last item
    const artMarginY = 20 * CFG.SCALE;
    const maxArtW = paperW * 0.72;
    const maxArtH = Math.min(paperH * 0.78, 360 * CFG.SCALE);
    let artW = maxArtW;
    let artH = maxArtH;
    const artImg = (GRAPHICS && GRAPHICS.config && GRAPHICS.config.birthday_art) ? GRAPHICS.images.get('birthday_art') : null;
    const artImgW = artImg && (artImg.naturalWidth || artImg.width);
    const artImgH = artImg && (artImg.naturalHeight || artImg.height);
    if (artImgW && artImgH) {
      const scale = Math.min(maxArtW / artImgW, maxArtH / artImgH);
      artW = artImgW * scale;
      artH = artImgH * scale;
    }
    const artX = paperX + (paperW - artW) / 2;
    const artY = yPos + artMarginY;
    EP.finalArtRect = { x: artX, y: artY, w: artW, h: artH };
    EP.artHeightPx = (artMarginY + artH + lineHeight);

    // Draw the art (or its redaction)
    drawBirthdayArt(artX, artY, artW, artH, !!(EP.finalArt && EP.finalArt.redacted));
  }

  // Draw 8-bit style birthday drawing (uses uploaded image if configured)
  function drawBirthdayArt(x, y, w, h, redacted) {
    if (redacted) {
      ctx.fillStyle = '#000';
      ctx.fillRect(x, y, w, h);
      return;
    }
    drawBirthdayArtBase(x, y, w, h);
  }

  // Draw the sharpie "dress up" animation - Trump draws a suit on the figure
  function drawSharpieOverdraw(x, y, w, h, startTime) {
    const elapsed = nowMs() - startTime;
    const totalDuration = 2000; // 2 seconds for full animation
    const progress = Math.min(1, elapsed / totalDuration);

    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Sharpie color - classic black marker
    ctx.strokeStyle = '#1a1a1a';
    ctx.fillStyle = '#1a1a1a';

    // Helper to draw animated line (only draws portion based on progress)
    function animLine(points, startPct, endPct) {
      if (progress < startPct) return;
      const localProgress = Math.min(1, (progress - startPct) / (endPct - startPct));

      ctx.beginPath();
      ctx.moveTo(x + points[0][0]*w, y + points[0][1]*h);

      const totalLen = points.length - 1;
      const drawTo = Math.floor(localProgress * totalLen) + 1;

      for (let i = 1; i < drawTo; i++) {
        ctx.lineTo(x + points[i][0]*w, y + points[i][1]*h);
      }

      // Partial last segment
      if (drawTo <= totalLen) {
        const segProgress = (localProgress * totalLen) % 1;
        const prev = points[drawTo - 1];
        const next = points[drawTo];
        if (next) {
          const px = prev[0] + (next[0] - prev[0]) * segProgress;
          const py = prev[1] + (next[1] - prev[1]) * segProgress;
          ctx.lineTo(x + px*w, y + py*h);
        }
      }
      ctx.stroke();
    }

    // 1. Jacket lapels (V-neck shape) - 0% to 25%
    ctx.lineWidth = Math.max(4, 8 * CFG.SCALE);
    // Left lapel
    animLine([[0.50, 0.15], [0.38, 0.35], [0.42, 0.50]], 0, 0.15);
    // Right lapel
    animLine([[0.50, 0.15], [0.62, 0.35], [0.58, 0.50]], 0.10, 0.25);

    // 2. Tie - 20% to 45%
    ctx.lineWidth = Math.max(6, 12 * CFG.SCALE);
    // Tie knot and body
    animLine([[0.50, 0.18], [0.48, 0.22], [0.52, 0.22], [0.50, 0.18]], 0.20, 0.28);
    animLine([[0.50, 0.22], [0.48, 0.55], [0.52, 0.55], [0.50, 0.22]], 0.28, 0.45);
    // Fill tie
    if (progress > 0.35) {
      ctx.beginPath();
      ctx.moveTo(x + 0.50*w, y + 0.22*h);
      ctx.lineTo(x + 0.46*w, y + 0.55*h);
      ctx.lineTo(x + 0.54*w, y + 0.55*h);
      ctx.closePath();
      ctx.fill();
    }

    // 3. Jacket sides - 40% to 70%
    ctx.lineWidth = Math.max(5, 10 * CFG.SCALE);
    // Left jacket edge
    animLine([[0.38, 0.35], [0.32, 0.50], [0.30, 0.70]], 0.40, 0.55);
    // Right jacket edge
    animLine([[0.62, 0.35], [0.68, 0.50], [0.70, 0.70]], 0.50, 0.65);

    // 4. Jacket buttons - 60% to 75%
    if (progress > 0.60) {
      const btnRadius = Math.max(3, 5 * CFG.SCALE);
      ctx.beginPath();
      ctx.arc(x + 0.50*w, y + 0.45*h, btnRadius, 0, Math.PI*2);
      ctx.fill();
    }
    if (progress > 0.68) {
      const btnRadius = Math.max(3, 5 * CFG.SCALE);
      ctx.beginPath();
      ctx.arc(x + 0.50*w, y + 0.55*h, btnRadius, 0, Math.PI*2);
      ctx.fill();
    }

    // 5. Jacket bottom / shirt bottom - 70% to 85%
    ctx.lineWidth = Math.max(4, 8 * CFG.SCALE);
    animLine([[0.30, 0.70], [0.38, 0.72], [0.50, 0.70], [0.62, 0.72], [0.70, 0.70]], 0.70, 0.85);

    // 6. "MAGA" or scribble at bottom as signature addition - 85% to 100%
    ctx.lineWidth = Math.max(2, 4 * CFG.SCALE);
    if (progress > 0.90) {
      ctx.font = `bold ${Math.max(10, 14*CFG.SCALE)}px Arial`;
      ctx.fillStyle = '#1a1a1a';
      ctx.textAlign = 'center';
      const textAlpha = Math.min(1, (progress - 0.90) / 0.10);
      ctx.globalAlpha = textAlpha;
      ctx.fillText('Fixed it! -DJT', x + w*0.5, y + h*0.82);
      ctx.globalAlpha = 1;
    }

    // Draw the sharpie marker itself during animation
    if (progress < 1) {
      drawSharpieMarker(x, y, w, h, progress);
    }

    ctx.restore();
  }

  // Draw the sharpie marker following the animation
  function drawSharpieMarker(x, y, w, h, progress) {
    // Determine marker position based on what's being drawn
    let mx, my;
    if (progress < 0.25) {
      // Drawing lapels
      mx = x + 0.50*w + (progress < 0.15 ? -0.12*w*progress/0.15 : 0.12*w*(progress-0.10)/0.15);
      my = y + 0.15*h + 0.35*h*progress/0.25;
    } else if (progress < 0.45) {
      // Drawing tie
      mx = x + 0.50*w;
      my = y + 0.22*h + 0.33*h*(progress-0.25)/0.20;
    } else if (progress < 0.70) {
      // Drawing jacket sides
      mx = x + (progress < 0.55 ? 0.32*w : 0.68*w);
      my = y + 0.50*h + 0.20*h*(progress-0.45)/0.25;
    } else {
      // Drawing bottom
      mx = x + 0.30*w + 0.40*w*(progress-0.70)/0.30;
      my = y + 0.70*h;
    }

    ctx.save();
    // Marker body
    const mw = 12 * CFG.SCALE;
    const mh = 40 * CFG.SCALE;

    ctx.fillStyle = '#2a2a2a';
    ctx.translate(mx, my);
    ctx.rotate(-0.3); // Slight angle like holding a pen

    // Cap
    ctx.fillRect(-mw/2, -mh, mw, mh*0.15);
    // Body
    ctx.fillRect(-mw/2, -mh*0.85, mw, mh*0.7);
    // Tip
    ctx.beginPath();
    ctx.moveTo(-mw/2, -mh*0.15);
    ctx.lineTo(mw/2, -mh*0.15);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fill();

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(-mw/2 + 2, -mh*0.8, mw*0.3, mh*0.5);

    ctx.restore();
  }

  // Base drawing function (the original figure)
  function drawBirthdayArtBase(x, y, w, h) {

    // If a custom image has been provided via GRAPHICS, render it scaled
    const url = GRAPHICS && GRAPHICS.config && GRAPHICS.config.birthday_art;
    if (url) {
      const img = GRAPHICS.images.get('birthday_art');
      if (img && img.complete) {
        // Draw PNG/JPEG using fit mode and no smoothing for crisp edges
        ctx.save();
        try { ctx.imageSmoothingEnabled = false; } catch(_){ }
        const iw = img.naturalWidth || img.width || 1;
        const ih = img.naturalHeight || img.height || 1;
        const fit = (GRAPHICS && GRAPHICS.config && GRAPHICS.config.birthday_art_fit) || 'contain';
        const sContain = Math.min(Math.max(0.0001, w/iw), Math.max(0.0001, h/ih));
        const sCover   = Math.max(Math.max(0.0001, w/iw), Math.max(0.0001, h/ih));
        // 'height' prefers filling height fully without cropping, otherwise falls back to contain
        const sHeight  = (iw * (h/ih) <= w) ? (h/ih) : sContain;
        const s = fit === 'cover' ? sCover : (fit === 'height' ? sHeight : sContain);
        const dw = iw * s;
        const dh = ih * s;
        const dx = x + (w - dw)/2;
        const dy = y + (h - dh)/2;
        // Clip to the art rect so cover mode crops inside the box
        ctx.save();
        ctx.beginPath(); ctx.rect(x, y, w, h); ctx.clip();
        ctx.drawImage(img, dx, dy, dw, dh);
        ctx.restore();
        ctx.restore();
        return;
      }
      GRAPHICS.loadImage('birthday_art', url);
    }
    // If Lottie JSON is provided and lottie-web available, render via hidden canvas and blit
    if (LOTTIE_ART && LOTTIE_ART.json && window.bodymovin) {
      LOTTIE_ART.resize(w, h);
      if (LOTTIE_ART.ready && LOTTIE_ART.canvasEl) {
        ctx.drawImage(LOTTIE_ART.canvasEl, x, y, w, h);
        return;
      }
    }

    // Vector fallback matching the birthday drawing silhouette
    const stroke = Math.max(6, Math.round(10 * CFG.SCALE));
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.lineWidth = stroke;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'miter';
    ctx.strokeStyle = '#2a2a2a';

    // Helper to draw a polyline from normalized points [0..1]
    function poly(points){
      ctx.beginPath();
      ctx.moveTo(x + points[0][0]*w, y + points[0][1]*h);
      for (let i=1;i<points.length;i++) ctx.lineTo(x + points[i][0]*w, y + points[i][1]*h);
      ctx.stroke();
    }

    // Left side of torso - matching the original birthday drawing silhouette
    // Simple elegant curve: neck notch -> shoulder -> waist -> hip
    const left = [
      [0.40, 0.00],  // Top of neck (left)
      [0.40, 0.06],  // Bottom of neck notch
      [0.32, 0.12],  // Shoulder angle start
      [0.10, 0.18],  // Outer shoulder point
      [0.12, 0.32],  // Side of torso upper
      [0.18, 0.48],  // Waist in
      [0.22, 0.62],  // Waist curve
      [0.18, 0.76],  // Hip out
      [0.22, 0.90]   // Bottom leg area
    ];
    // Right side is mirrored
    const right = left.map(([nx, ny]) => [1-nx, ny]);
    poly(left);
    poly(right);

    // Small angular breast marks (simple < > shapes)
    poly([[0.38, 0.28], [0.32, 0.34], [0.38, 0.38]]);
    poly([[0.62, 0.28], [0.68, 0.34], [0.62, 0.38]]);

    // Signature at bottom - zigzag pattern then horizontal line
    ctx.lineWidth = Math.max(3, Math.round(5 * CFG.SCALE));
    const sigX = 0.30, sigY = 0.82;
    // Zigzag signature
    poly([
      [sigX, sigY],
      [sigX+0.02, sigY-0.03],
      [sigX+0.04, sigY+0.02],
      [sigX+0.06, sigY-0.03],
      [sigX+0.08, sigY+0.02],
      [sigX+0.10, sigY-0.03],
      [sigX+0.12, sigY+0.01]
    ]);
    // Horizontal flourish line
    poly([[sigX+0.12, sigY+0.03], [sigX+0.40, sigY+0.03]]);

    ctx.restore();
  }
  
  function drawEpsteinHUD() {
    // Move HUD to left side to avoid overlap with gold bar chips
    const baseX = 20, baseY = 20;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(baseX, baseY, 200, 160);
    
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${16 * CFG.SCALE}px system-ui`;
    ctx.textAlign = 'left';
    // No time constraint shown
    ctx.fillText(`Speed: ${EP.scrollSpeed.toFixed(1)}x`, baseX + 10, baseY + 25);
    ctx.fillText(`Found: ${EP.foundTrumps}/${EP.totalTrumpTargets}`, baseX + 10, baseY + 50);
    ctx.fillText(`Missed: ${EP.missedTrumps}/${EP.missesAllowed}`, baseX + 10, baseY + 75);
    ctx.fillText(`Penalties: ${EP.protectedClicks||0}`, baseX + 10, baseY + 100);
    // Progress bars
    const barX = baseX + 10, barW = 180, barH = 8;
    // Found progress
    const foundK = Math.max(0, Math.min(1, (EP.foundTrumps||0) / (EP.totalTrumpTargets||1)));
    ctx.fillStyle = '#333'; ctx.fillRect(barX, baseY + 110, barW, barH);
    ctx.fillStyle = '#4caf50'; ctx.fillRect(barX, baseY + 110, barW*foundK, barH);
    // Scroll progress
    // recompute total content height like in updateEpsteinGame
    const paperYHUD = H * 0.1;
    const lineH = 20 * CFG.SCALE;
    let totalH = 30 * CFG.SCALE;
    for (let d = 0; d < EP.papers.length; d++) { totalH += lineH*1.5 + EP.papers[d].length*lineH + lineH; }
    const startYHUD = paperYHUD + 30 * CFG.SCALE - EP.scrollY;
    const scrolledHUD = Math.max(0, Math.min(totalH, (paperYHUD + 30 * CFG.SCALE) - startYHUD));
    const scrollK = totalH>0 ? (scrolledHUD/totalH) : 0;
    ctx.fillStyle = '#333'; ctx.fillRect(barX, baseY + 125, barW, barH);
    ctx.fillStyle = '#03a9f4'; ctx.fillRect(barX, baseY + 125, barW*scrollK, barH);
    
  }
  
  function checkMissedTrumps() {
    // Compute from document structure rather than transient locations,
    // so lines that scrolled off-screen still count as missed.
    const paperY = H * 0.1;
    const lineHeight = 20 * CFG.SCALE;
    const startY = paperY + 30 * CFG.SCALE - EP.scrollY;
    
    for (let d = 0; d < EP.papers.length; d++) {
      const doc = EP.papers[d];
      // y at start of this document header
      let y = startY;
      for (let pd = 0; pd < d; pd++) {
        y += lineHeight * 1.5; // header
        y += EP.papers[pd].length * lineHeight; // lines
        y += lineHeight; // gap
      }
      
      // header of current doc
      y += lineHeight * 1.5;
      
      for (let li = 0; li < doc.length; li++) {
        const line = doc[li];
        if (line.containsTrump && !line.redacted) {
          const lineY = y + li * lineHeight;
          if (lineY < paperY - 150) { // missed threshold above paper
            line.redacted = true;
            EP.missedTrumps++;
            SFX.error();
            triggerShake(5 * CFG.SCALE, 200);
            // Assist for a few seconds after a miss
            EP.assistUntil = nowMs() + 3500;
            // Miss toast near top-left of paper
            EP.toasts.push({ x: W*0.2 + 60*CFG.SCALE, y: H*0.1 + 20*CFG.SCALE, text: 'Missed', color: '#ff5555', start: nowMs(), ttl: 800 });
          }
        }
      }
    }
    // Note: EP.trumpLocations is still used for click detection; it is rebuilt during draw.
  }
  
  function endEpsteinGame(reason) {
    EP.gameActive = false;
    if (reason === 'success') {
      const text = 'Selvfølgelig er jeg ikke nævnt — never met the guy';
      addSafe('epstein', 'documents-redacted');
      SFX.achievement();
      awardMedal('epstein');
      GS.overMode = 'epstein_success';
      gameOver(text);
      return;
    }

    if (reason === 'protected_click' || reason === 'protected' || reason === 'misses' || reason === 'timeout') {
      SFX.error();
      GS.overMode = 'epstein_fail';
      GS.over = true;
      GS.overText = '';
      return;
    }

    // Fallback
    GS.overMode = 'epstein_fail';
    GS.over = true;
    GS.overText = 'DOKUMENTGENNEMGANG SLUT.';
  }

  // Guitar Hero style: Hit zone calculation
  function getEpsteinHitZone() {
    const paperY = H * 0.1;
    const paperH = H * 0.8;
    const zoneH = EP.hitZoneHeight * CFG.SCALE;
    let zoneCenterY = paperY + paperH * EP.hitZoneY;
    // When the final art is in view, align the hit zone to the breast area
    if (EP.atArtHold && EP.finalArtRect && !(EP.finalArt && EP.finalArt.redacted)) {
      const rel = (typeof window.BIRTHDAY_ART_HIT_REL === 'number') ? window.BIRTHDAY_ART_HIT_REL
                 : (typeof EP.artHitZoneRel === 'number') ? EP.artHitZoneRel : 0.33;
      const artCenter = EP.finalArtRect.y + EP.finalArtRect.h * rel;
      if (artCenter >= paperY && artCenter <= paperY + paperH) {
        zoneCenterY = artCenter;
      }
    }
    return {
      top: zoneCenterY - zoneH / 2,
      bottom: zoneCenterY + zoneH / 2,
      centerY: zoneCenterY,
      height: zoneH
    };
  }

  function triggerFinalArtRedact(){
    if (!EP.atArtHold || !EP.finalArtRect || (EP.finalArt && EP.finalArt.redacted)) return false;
    const r = EP.finalArtRect;
    EP.finalArt = EP.finalArt || {};
    EP.finalArt.redacted = true;
    EP.finalArt.redactStart = nowMs(); // Start sharpie animation
    EP.lastRedactTime = EP.finalArt.redactStart;
    SFX.success();
    EP.toasts.push({ x: r.x + r.w/2, y: r.y - 8*CFG.SCALE, text: 'Fixed it!', color: '#6cff6c', start: nowMs(), ttl: 2200 });
    // Delay ending by 2.2s so player sees the sharpie animation (2s duration + buffer)
    if (!EP.endingPending){
      EP.endingPending = true;
      const result = (EP.foundTrumps >= EP.totalTrumpTargets) ? 'success' : 'misses';
      setTimeout(() => { try { endEpsteinGame(result); } catch(_){} }, 2200);
    }
    return true;
  }
  function tryRedactFinalArt(zone){
    if (!EP.atArtHold || !EP.finalArtRect || (EP.finalArt && EP.finalArt.redacted)) return false;
    return triggerFinalArtRedact();
  }

  // Guitar Hero style: Check if a line is in the hit zone
  function isLineInHitZone(lineY, fontSize) {
    const zone = getEpsteinHitZone();
    const lineTop = lineY - fontSize * 0.8;
    const lineBottom = lineY + fontSize * 0.3;
    // Line overlaps with hit zone
    return lineBottom >= zone.top && lineTop <= zone.bottom;
  }

  // Guitar Hero style: Handle E key press
  function handleEpsteinGuitarHero() {
    if (!EP.gameActive || EP.paused) return;

    // Cooldown to prevent rapid double-hits
    const now = nowMs();
    if (now - EP.lastRedactTime < 150) return;

    const paperX = W * 0.2;
    const paperW = W * 0.6;
    const leftMargin = paperX + 20 * CFG.SCALE;
    const fontSize = Math.floor(13 * CFG.SCALE);
    const zone = getEpsteinHitZone();

    // Find all targets currently in the hit zone
    let bestTarget = null;
    let bestDistance = Infinity;

    for (const loc of EP.trumpLocations) {
      const lineCenterY = loc.y + loc.height / 2;
      // Check if line center is within or close to hit zone
      if (lineCenterY >= zone.top - 20*CFG.SCALE && lineCenterY <= zone.bottom + 20*CFG.SCALE) {
        const distance = Math.abs(lineCenterY - zone.centerY);
        if (distance < bestDistance) {
          bestDistance = distance;
          bestTarget = loc;
        }
      }
    }

    if (bestTarget) {
      const doc = EP.papers[bestTarget.docIndex];
      const line = doc[bestTarget.lineInDoc];
      if (!line || line.redacted) return;

      EP.lastRedactTime = now;

      if (bestTarget.kind === 'protected') {
        // Protected hit: penalty
        EP.protectedClicks = (EP.protectedClicks||0) + 1;
        SFX.error();
        triggerShake(6*CFG.SCALE, 300);
        hudToast = 'Penalty: Overstreg ikke blå (Clinton/Gates)';
        // Remove from locations
        const idx = EP.trumpLocations.indexOf(bestTarget);
        if (idx > -1) EP.trumpLocations.splice(idx, 1);
        if (EP.protectedClicks > (EP.protectedLimit||0)) {
          endEpsteinGame('protected_click');
        }
        return;
      }

      // Successfully redacted Trump line
      line.redacted = true;
      line.redactAt = now;
      EP.foundTrumps++;
      SFX.success();

      // Start marker animation (tusser effect)
      ctx.font = `bold ${fontSize}px monospace`;
      const textWidth = ctx.measureText(line.text).width;
      EP.markerAnim = {
        x: leftMargin - 2,
        y: bestTarget.y + bestTarget.height / 2 - fontSize * 0.4,
        width: textWidth + 4,
        startTime: now,
        duration: 300
      };

      spawnSparks(leftMargin + textWidth/2, zone.centerY, 8);
      EP.toasts.push({
        x: leftMargin + textWidth/2,
        y: zone.centerY - 20*CFG.SCALE,
        text: '+1 Redacted',
        color: '#6cff6c',
        start: now,
        ttl: 700
      });

      // Remove from locations
      const idx = EP.trumpLocations.indexOf(bestTarget);
      if (idx > -1) EP.trumpLocations.splice(idx, 1);
      return;
    }

    if (tryRedactFinalArt(zone)) return;
    // No target in zone - miss sound (subtle)
    SFX.click();
  }

  function handleEpsteinClick(mouseX, mouseY) {
    if (!EP.gameActive) {
      // If game is not active, check for door exit
      const doorDist = Math.hypot(mouseX - EP.door.x, mouseY - EP.door.y);
      if (doorDist < 80 * CFG.SCALE) {
        // Exit back to helicopter menu
        openChoice("Leave document review?\n1. Continue redacting\n2. Back to helicopter", k=>{
          closeChoice();
          if (k==='2') switchScene('greenland');
        });
      }
      return;
    }

    // Check click on final art - starts sharpie "dress up" animation
    // Text redacting is done via Guitar Hero E-key mechanic
    if (EP.finalArtRect && !(EP.finalArt && EP.finalArt.redacted)) {
      const r = EP.finalArtRect;
      if (mouseX >= r.x && mouseX <= r.x + r.w && mouseY >= r.y && mouseY <= r.y + r.h) {
        triggerFinalArtRedact();
        return;
      }
    }
  }

  // SCENE_EPSTEIN (END)
  function switchScene(to){
    // Unbind golf inputs if leaving golf
    if (scene === 'golf') { try { golfUnbindInput(); } catch(_){} }
    scene = to;
    if (scene==='greenland') { resetGreenland(); }
    else if (scene==='oval') { resetOval(); playEntryHeli('Back at the Resolute Desk — the best!', 160*CFG.SCALE); }
    else if (scene==='kremlin') { resetKremlin(); playEntryHeli('Very strong handshake incoming.', 160*CFG.SCALE); }
    else if (scene==='epstein') { resetEpstein(); }
    // Adjust UI position per scene (avoid bottom-left overlap in Epstein)
    try {
      const ui = document.querySelector('.ui');
      if (ui){
        if (scene==='epstein') {
          ui.style.top = '12px';
          ui.style.bottom = 'auto'; // override class bottom to avoid stretching
        } else {
          ui.style.bottom = '12px';
          ui.style.top = 'auto';
        }
      }
    } catch(_){ }
  }
  resetGreenland();
  // ensure inventory renders placeholders on load (no preloaded items)
  renderInv();
  renderHUD();

  // Reset handler consolidated in main keydown listener above

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         11. INTERACTION SYSTEM                             ║
  // ║  Object proximity detection, E-key interactions, shop, tweets              ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Interaktioner ----------
  function nearestGL(){
    const arr = [GL.mine, GL.mette, GL.rig, GL.shop, GL.heli, ...(GL.bear.alive ? [GL.bear] : []), ...GL.items.filter(it=>!it.collected), ...GL.glaciers.filter(g=>!g.blown), ...GL.coins.filter(c=>!c.collected)];
    let best=null, bd=1e9; 
    for (const o of arr){ 
      const d = o.type==='heli' ? heliProximity(o, player.x, player.y) : dist(player,o); 
      if (d<bd){bd=d; best=o;} 
    }
    return (bd < CFG.INTERACT_DIST*CFG.SCALE) ? best : null;
  }
  function nearestOV(){
    const arr = [OV.door, OV.heli, OV.yes, ...OV.buttons, ...OV.coins.filter(c=>!c.collected)];
    let best=null, bd=1e9; 
    for (const o of arr){ 
      const d = o.type==='heli' ? heliProximity(o, player.x, player.y) : dist(player,o); 
      if (d<bd){bd=d; best=o;} 
    }
    return (bd < CFG.INTERACT_DIST*CFG.SCALE) ? best : null;
  }
  function nearestKR(){
    const arr = [KR.door, KR.putin, KR.heli, ...KR.statues.filter(s=>!s.collected), ...KR.coins.filter(c=>!c.collected)];
    let best=null, bd=1e9; 
    for (const o of arr){ 
      const d = o.type==='heli' ? heliProximity(o, player.x, player.y) : dist(player,o); 
      if (d<bd){bd=d; best=o;} 
    }
    return (bd < CFG.INTERACT_DIST*CFG.SCALE) ? best : null;
  }

  function startGreenlandLarsMinigame(){
    if (GL.state.larsMiniGameStarted) return;
    GL.state.larsMiniGameStarted = true;
    // TODO: Hook real minigame here later
  }

  function interact(){
    if (scene==='greenland'){
      if (player.selectedItem==='dynamite'){
        const obj = nearestGL();
        if (obj) addInteractionFeedback(obj); // Add visual feedback
        if (obj && (obj.type==='mette' || obj.type==='bear' || obj.type==='rig' || obj.type==='glacier')){ beginPlant(obj); return; }
        // plant at ground near player's feet if no special target
        const g = H - world.floor; const px = player.x + (player.facing>0? 12*CFG.SCALE : -12*CFG.SCALE);
        beginPlant({type:'ground', x:px, y:g});
        return;
      }
      // Check if player has dynamite but hasn't selected it
      const hasDyn = inventory.find(i => i.id === 'dynamite' && (i.qty||0) > 0);
      const obj = nearestGL();
      if (!obj) {
        if (hasDyn) {
          say(player, 'Tryk D for at vælge dynamit først!', 1500);
        }
        return;
      }
      addInteractionFeedback(obj); // Add visual feedback
      if (obj.type==='mine'){
        if (GL.mette.blownUp) {
          if (!GL.state.mineFlagPlanted) {
            GL.state.mineFlagPlanted = true;
            say(player, "This mine is now AMERICAN property! 🇺🇸", 2000);
            spawnSparks(GL.mine.x, GL.mine.y - 30*CFG.SCALE, 15);
            SFX.success && SFX.success();
          } else {
            say(player, "Already claimed this beautiful mine!", 1200);
          }
        } else {
          say(player, "Nice mine! But I need to deal with Lars first...", 1500);
        }
      }
      else if (obj.type==='shop'){
        openShop();
      }
      else if (obj.type==='bear'){
        if (!GL.bear.alive){ say(player,"…den er væk.",900); return; }
        if (CFG.NON_VIOLENT){
          say(player,"Sød bjørn. Tag en fisk 🐟",1400); say(GL.bear,"Brumm?",1000);
          addSafe('greenland', 'bear-peace');
        } else {
          const oldHP = GL.bear.hp || 4;
          GL.bear.hp = Math.max(0, oldHP-1);
          
          // When HP reaches 0 - bear gets ANGRY and starts chasing!
          if (GL.bear.hp === 0) {
            say(GL.bear,"ROAAAAR! 😡",1500);
            say(player,"Uh oh... that bear looks MAD!",2000);
            spawnBlood(player.x, player.y-20*CFG.SCALE, 15);
            
            // Bear becomes angry and starts chasing
            GL.bear.angry = true;
            GL.bear.chasing = true;
            GL.bear.speed = 300; // Super fast when angry
            
            // Sound effects for angry bear
            ensureAudioInit();
            SFX.error();
            setTimeout(SFX.heartbeat, 500);
            
            // Camera shake for dramatic effect
            triggerShake(8*CFG.SCALE, 600);
            
            // Visual feedback - angry sparks
            for (let i = 0; i < 15; i++) {
              spawnSparks(GL.bear.x, GL.bear.y - 20*CFG.SCALE, 8);
            }
            
          } else {
            say(GL.bear,"Ufff!",800);
          }
          
          spawnBlood(GL.bear.x+8*CFG.SCALE, GL.bear.y-16*CFG.SCALE, 10);
          // knockback physics
          GL.bear.vy = (GL.bear.vy||0) - 280*CFG.SCALE;
          GL.bear.vx = (GL.bear.vx||0) + 60*CFG.SCALE;
          
          // Bear no longer dies, just gets angry when HP reaches 0
          // Remove the death logic since bear stays alive but angry
        }
      }
      else if (obj.type==='glacier'){
        const hasDynamite = inventory.find(i => i.id === 'dynamite');
        const dynamiteSelected = player.selectedItem === 'dynamite';
        
        if (!GL.state.hasSeenGlaciers) {
          // First interaction - complaint about view
          say(player, "These massive ice walls are blocking my BEAUTIFUL view! Need something explosive to clear them.", 2500);
          GL.state.hasSeenGlaciers = true;
        } else if (!hasDynamite) {
          // Subsequent interactions without dynamite in inventory
          say(player, "Still need something to blast through these glaciers! Where's my dynamite?", 2000);
        } else if (!dynamiteSelected) {
          // Has dynamite but not selected - more provocative
          say(player, "Look in the inventory, dummy!", 1500);
        } else { beginPlant(obj); }
      }
      else if (obj.type==='mette'){
        // TRUMP_ABSURD and METTE_DIPLO loaded from game-text-data JSON block
        const maxRounds = Math.min(TRUMP_ABSURD.length, 5);
        const round = GL.state.larsDialogRounds || 0;
        if (GL.state.larsMiniGameStarted) return;
        if (round >= maxRounds) { startGreenlandLarsMinigame(); return; }
        const trumpResponse = TRUMP_ABSURD[round] || TRUMP_ABSURD[TRUMP_ABSURD.length-1];
        const line = METTE_DIPLO[round];
        // Light relationship nudge only
        adjustRelationship('mette', {respect:-1, trust:-1}, 'absurd-offer');
        // Show Trump first, then Lars after ~1.2s (if he has a line)
        // Keep Trump's bubble visible until Lars' bubble has also finished
        const delayMs = 1200;
        if (line){
          const larsDur = 2000;
          const trumpDur = delayMs + larsDur + 300;
          say(player, trumpResponse, trumpDur);
          setTimeout(() => { try { say(GL.mette, line, larsDur); } catch(_){} }, delayMs);
          GL.state.larsDialogRounds = round + 1;
          if (GL.state.larsDialogRounds >= maxRounds){
            setTimeout(() => { try { startGreenlandLarsMinigame(); } catch(_){} }, delayMs + larsDur + 50);
          }
        } else {
          const trumpDur = 1600;
          say(player, trumpResponse, trumpDur);
          GL.state.larsDialogRounds = round + 1;
          if (GL.state.larsDialogRounds >= maxRounds){
            setTimeout(() => { try { startGreenlandLarsMinigame(); } catch(_){} }, trumpDur + 50);
          }
        }
        GL.mette.nextBlink = nowMs() + 2000 + Math.random()*3000;
        GL.mette.blinkUntil = 0;
      }
      else if (obj.type==='rig'){
        GL.rig.burstUntil = nowMs() + 900;
        // emit oil burst from the top and falling to ground
        const topX = GL.rig.x, topY = GL.rig.y - 90*CFG.SCALE - 12*CFG.SCALE;
        spawnOil(topX, topY, 24);
        say(player,'Huge energy play. Beautiful, clean oil!',1600);
      }
      else if (obj.type==='heli'){
        addSafe('greenland', 'heli-travel');
          openChoice("Board helicopter?\n1. Bliv på Grønland\n2. Flyv til The White House\n3. Flyv til Moskva (møde)\n4. Epstein files\n5. Flyv til Mar-a-Lago (mini-putt)", k=>{
          closeChoice();
          if (k==='2'){ switchScene('oval'); }
          if (k==='3'){ switchScene('kremlin'); }
          if (k==='4'){ switchScene('epstein'); }
          if (k==='5'){ try { SFX.whoosh(); } catch(_){} startGolf('course-mar-a-lago'); }
        });
      }
      else if (obj.type==='pickup'){
        obj.collected=true;
        addToInventory(obj.id, obj.name);
        say(player, `Samlet: ${obj.name}`, 1000);
        addSafe('greenland', obj.id);
      }
    } else {
      if (scene==='oval'){
        if (player.selectedItem==='dynamite'){
          const obj = nearestOV();
          if (obj) addInteractionFeedback(obj); // Add visual feedback
          // Allow planting in Oval: plant on ground near player
          const g = H - world.floor; const px = player.x + (player.facing>0? 12*CFG.SCALE : -12*CFG.SCALE);
          beginPlant({type:'ground', x:px, y:g});
          return;
        }
        const obj = nearestOV(); if (!obj) return;
        addInteractionFeedback(obj); // Add visual feedback
        if (obj.type==='door'){
          openChoice("Forlade The Oval Office?\n1. Bliv her\n2. Tilbage til Grønland", k=>{
            closeChoice();
            if (k==='2') switchScene('greenland');
          });
        }
        // aide disabled in this scene layout
        else if (obj.type==='yes'){
          praiseChoir();
          addSafe('oval', 'praise-choir');
        }
        else if (obj.type==='button'){
          // Add visual press effect
          obj.pressed = true;
          setTimeout(() => { if (obj) obj.pressed = false; }, 200);

          // Sound effects
          ensureAudioInit();
          SFX.buttonPress && SFX.buttonPress();

          // Surprise button (nuclear) - ALWAYS triggers missile!
          if (obj.action === 'surprise') {
            SFX.error && SFX.error();
            setTimeout(() => SFX.explosion && SFX.explosion(), 500);
            launchMissile();
            OV.decisions.active = false;
            return;
          }

          // Presidential Decisions mini-game - handle Ja/Nej
          if (OV.decisions.active && OV.decisions.phase === 'guest_asking') {
            handleOvalAnswer(obj.action);
            return;
          }

          // If not in guest_asking phase, Ja/Nej don't do anything
          if (OV.decisions.active) {
            say(player, 'Wait for a guest to arrive...', 1200);
            return;
          }

          // Fallback for when mini-game is not active
          praiseChoir();
        }
        else if (obj.type==='heli'){
          ensureAudioInit();
          SFX.helicopter();
          addSafe('oval', 'heli-travel');
          openChoice("Board helicopter?\n1. Bliv her\n2. Flyv til Grønland\n3. Flyv til Moskva (møde)\n4. Epstein files\n5. Flyv til Mar-a-Lago (mini-putt)", k=>{
            closeChoice();
            if (k==='2') { SFX.whoosh(); switchScene('greenland'); }
            if (k==='3') { SFX.whoosh(); switchScene('kremlin'); }
            if (k==='4') { SFX.whoosh(); switchScene('epstein'); }
            if (k==='5') { SFX.whoosh(); startGolf('course-mar-a-lago'); }
          });
        }
      } else if (scene==='kremlin'){
        if (player.selectedItem==='dynamite'){
          const obj = nearestKR();
          if (obj) addInteractionFeedback(obj); // Add visual feedback
          // Special: allow planting on Putin for a satirical ending, else plant on ground
          if (obj && obj.type==='putin') { beginPlant(obj); return; }
          const g = H - world.floor; const px = player.x + (player.facing>0? 12*CFG.SCALE : -12*CFG.SCALE);
          beginPlant({type:'ground', x:px, y:g});
          return;
        }
        const obj = nearestKR(); if (!obj) return;
        addInteractionFeedback(obj); // Add visual feedback
        if (obj.type==='door'){
          openChoice("Forlade mødet?\n1. Bliv her\n2. Tilbage til Grønland", k=>{ closeChoice(); if (k==='2') switchScene('greenland'); });
        }
        else if (obj.type==='putin'){
          startHandshake();
        }
        else if (obj.type==='statue'){
          // Check if Trump is caught by security camera
          if (isStatueUnderSurveillance(obj)) {
            // BUSTED! Discovery system activates
            triggerSecurityDiscovery(obj);
            return; // Don't collect the statue
          }
          
          obj.collected=true;
          addToInventory(obj.id, obj.name);
          // Bonus: display stolen statue on Oval Office shelves
          if (!OV.shelfLoot) OV.shelfLoot = [];
          OV.shelfLoot.push({ variant: obj.variant||1, time: nowMs() });
          addSafe('kremlin', obj.id);
          const boast=[
            'Only I could get this deal.',
            'They love me here. Tremendous!',
            'Beautiful piece. I deserve it.',
            'Everyone says it belongs with me.'
          ];
          say(player, boast[Math.floor(Math.random()*boast.length)], 1400);
        }
        else if (obj.type==='heli'){
          addSafe('kremlin', 'heli-travel');
          openChoice("Board helicopter?\n1. Bliv her\n2. Flyv til Grønland\n3. Flyv til The White House\n4. Epstein files\n5. Flyv til Mar-a-Lago (mini-putt)", k=>{
            closeChoice();
            if (k==='2') switchScene('greenland');
            if (k==='3') switchScene('oval');
            if (k==='4') switchScene('epstein');
            if (k==='5') { try { SFX.whoosh(); } catch(_){} startGolf('course-mar-a-lago'); }
          });
        }
      } else if (scene==='epstein') {
        // Epstein scene interactions (door exit when game is over)
        if (!EP.gameActive) {
          const obj = {type: 'door', x: EP.door.x, y: EP.door.y};
          const d = Math.hypot(player.x - obj.x, player.y - obj.y);
          if (d < CFG.INTERACT_DIST*CFG.SCALE) {
            openChoice("Leave document review?\n1. Stay here\n2. Back to helicopter", k=>{
              closeChoice();
              if (k==='2') switchScene('greenland');
            });
          }
        }
      }
    }
  }
  // Interact handler consolidated in main keydown listener above

  // ---------- Tweet logic ----------
  function doTweet(){
    const text = nextTweet();
    GL.state.hasTweeted = true;
    const wrapped = wrapTwoLines(text, 220*CFG.SCALE);
    const msg = wrapped.length>1 ? ('Tweet: "'+wrapped[0]+'\n'+wrapped[1]+'"') : ('Tweet: "'+wrapped[0]+'"');
    say(player, msg, 2400);
    tweetCount++;
    phoneBlinkUntil = nowMs() + 600;
    
    // Adjust relationships based on tweet context in different scenes
    if (scene === 'kremlin') {
      adjustRelationship('putin', {trust: -2, fear: 1}, 'tweeting_in_kremlin');
      SFX.tweet();
      // Putin might react to aggressive tweeting
      if (tweetCount > 3 && RELATIONSHIPS.putin.trust < 30) {
        setTimeout(() => {
          KR.putin.speakingUntil = nowMs() + 1500;
          KR.putin.say = 'Perhaps less... social media?';
        }, 1000);
      }
    } else if (scene === 'greenland') {
      adjustRelationship('mette', {respect: -1, trust: -2}, 'public_tweeting');
      SFX.tweet();
    }
  }
  function wrapTwoLines(text, maxW){
    ctx.save(); ctx.font=`${12*CFG.SCALE}px/1.2 system-ui`;
    const words = String(text).split(/\s+/);
    let line1='', line2='';
    for (const w of words){
      const test = line1 ? line1+' '+w : w;
      if (ctx.measureText(test).width <= maxW) line1 = test;
      else { line2 = line2 ? line2+' '+w : w; }
    }
    if (!line1 && line2){ line1=line2; line2=''; }
    ctx.restore();
    return line2 ? [line1, line2] : [line1];
  }

  const SHOP_ITEMS = [
    {
      id: 'tan',
      label: 'Selvbruner',
      price: 3,
      allowDuplicates: true,
      buyLine: 'Selvbruner +1',
      onPurchase(){
        addToInventory('tan');
        player.tanLevel = Math.min(5, (player.tanLevel || 0) + 1);
      }
    },
    {
      id: 'shoes',
      label: 'Guldsneakers',
      price: 8,
      allowDuplicates: false,
      buyLine: 'Guldsko på! Tempo x2.',
      onPurchase(){
        player.goldenShoesOn = true;
        updatePlayerSpeedMul();
        renderHUD();
      }
    },
    {
      id: 'maga',
      label: 'MAGA-cap',
      price: 5,
      allowDuplicates: false,
      buyLine: 'Ny MAGA-cap – total patrioteffekt!',
      onPurchase(){
        player.capOn = true;
      }
    },
    {
      id: 'dynamite',
      label: 'Dynamit (x5)',
      price: 6,
      allowDuplicates: true,
      buyLine: 'Boom! Fem styk dynamit.',
      onPurchase(){
        addToInventory('dynamite');
      }
    }
  ];

  let shopTutorialShown = false;
  function handleShopFirstPurchase(){
    if (shopTutorialShown) return false;
    shopTutorialShown = true;
    if (invEl && invEl.classList.contains('hidden')) {
      toggleInventory();
    }
    say(player, 'press B to see my beautiful stuff', 2200);
    return true;
  }

  function openShop(){
    if (choiceOverlay) {
      const layout = layoutChoiceOverlay();
      if (layout && layout.boxes) {
        const p = toCanvasCoords(e, cvs);
        const mx = p.x / DPR, my = p.y / DPR;
        const hit = layout.boxes.find(b => mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h);
        if (hit) {
          choiceOverlay.selected = layout.boxes.indexOf(hit);
          choiceOverlay.onKey(hit.key);
        } else if (choiceOverlay.options && choiceOverlay.options.length) {
          const opt = choiceOverlay.options[choiceOverlay.selected || 0];
          if (opt) choiceOverlay.onKey(opt.key);
        }
      }
      return;
    }
    const balance = player.goldBalance || 0;
    const lines = SHOP_ITEMS.map((item, idx) => `${idx + 1}. ${item.label} – ${item.price} guld`);
    const exitIndex = SHOP_ITEMS.length + 1;
    lines.push(`${exitIndex}) Forlad boden`);
    const header = `Roadside Shop\nGuld: ${balance}\n`;
    openChoice(header + lines.join('\n'), key => {
      if (key === String(exitIndex) || key === 'escape') {
        closeChoice();
        return;
      }
      const choice = parseInt(key, 10) - 1;
      if (Number.isNaN(choice) || choice < 0 || choice >= SHOP_ITEMS.length) {
        say(player, 'Forstår ikke valget.', 900);
        return;
      }
      const item = SHOP_ITEMS[choice];
      if ((player.goldBalance || 0) < item.price){
        say(player, 'Ikke nok guld.', 1100);
        return;
      }
      if (!item.allowDuplicates && hasItem(item.id)){
        say(player, 'Du har allerede den genstand.', 1100);
        return;
      }
      closeChoice();
      player.goldBalance = (player.goldBalance || 0) - item.price;
      if (!item.allowDuplicates && !hasItem(item.id)) addToInventory(item.id);
      if (item.onPurchase) item.onPurchase();
      const tutorial = handleShopFirstPurchase();
      if (!tutorial) {
        say(player, item.buyLine || 'Tak for købet!', 1300);
      }
      renderHUD();
    });
  }
  function hasItem(id){ return inventory.some(it=>it.id===id); }
  
  function checkCoinRewards(){
    if (collectedCoins === 10 && !player.speedBoost10) {
      player.speedBoost10 = true;
      player.baseSpeedMul = (player.baseSpeedMul || 1) * 1.25;
      updatePlayerSpeedMul();
      say(player, 'Speed boost! +25%', 2000);
    }
    if (collectedCoins === 18 && !player.healthBoost18) {
      player.healthBoost18 = true;
      // Add health regeneration or other bonus
      say(player, 'Health boost unlocked!', 2000);
    }
    // Check if all gold bars collected (total across all scenes: 12+7+4=23)
    const totalCoins = GL.coins.length + OV.coins.length + KR.coins.length;
    if (collectedCoins >= totalCoins && !player.masterCollector) {
      player.masterCollector = true;
      say(player, 'Gold Rush Master! All gold bars found!', 3000);
    }
  }
  function useInventoryKey(k){
    // map 1,2,3 to ITEM_META order
    const order = Object.keys(ITEM_META);
    const idx = parseInt(k,10)-1;
    const id = order[idx];
    if (!id) return;
    if (!hasItem(id)) { say(player, 'Ingen '+(ITEM_META[id].name||id)+' i inventaret', 900); return; }
    if (id==='tan') { 
      player.tanLevel = Math.min(5, (player.tanLevel||0)+1); 
      say(player,'Selvbruner +1',1000); 
      // Small celebratory sparkles around the head
      spawnSparks(player.x, player.y - 44*CFG.SCALE, 10);
      renderInv(); 
      return; 
    }
    if (id==='shoes') {
      player.goldenShoesOn = !player.goldenShoesOn;
      say(player, player.goldenShoesOn ? 'Guld-sko på! Tempo x2.' : 'Guld-sko af.', 1000);
      if (!player.goldenShoesOn) {
        // ensure base speed multiplier remains >0
        if (!player.baseSpeedMul) player.baseSpeedMul = 1;
      }
      updatePlayerSpeedMul();
      renderInv(); renderHUD();
      return;
    }
    if (id==='maga') { player.capOn = !player.capOn; say(player, player.capOn? 'Hat på.' : 'Hat af.',900); renderInv(); return; }
    if (id==='dynamite') { 
      player.selectedItem = 'dynamite'; 
      say(player,'Dynamit valgt! Klar til sprængning!',1200); 
      renderInv(); 
      // Clear selection after 10 seconds
      setTimeout(() => {
        if (player.selectedItem === 'dynamite') {
          player.selectedItem = null;
          say(player, 'Dynamit ikke længere valgt', 800);
          renderInv();
        }
      }, 10000);
      return; 
    }
  }
  function nextTweet(){
    const lines = [];
    if (scene==='greenland'){
      if (!GL.state.flagPlanted && !GL.state.bearGone) lines.push('Great day in Greenland. Beautiful ice!');
      if (GL.state.flagPlanted) lines.push('We planted a small flag. Very legal & very cool.');
      if (GL.state.bearGone && CFG.NON_VIOLENT) lines.push('Made peace with a polar bear. Tremendous diplomacy.');
      if (GL.state.bearGone && !CFG.NON_VIOLENT) lines.push('Protected the people from a very dangerous bear!');
    } else {
      lines.push('Working hard in the Oval!');
    }
    if (hasItem('maga')) lines.push('Wearing my favorite hat. Crowds go wild!');
    if (hasItem('shoes')) lines.push('Guld-skoene er på. Hurtigere end nogensinde!');
    if (hasItem('tan')) lines.push('Natural tan. Best you’ve ever seen.');
    const presets = [
      'So much winning!',
      'The Fake News won’t report this!',
      'MAKE GREENLAND GREAT AGAIN!',
      'Covfefe.',
    ];
    lines.push(presets[tweetCount % presets.length]);
    return lines.slice(0,2).join(' ');
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         12. MOUSE & TOUCH CONTROLS                         ║
  // ║  Click-to-walk, click-to-interact, touch support                           ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Mouse: hover + click-to-interact ----------
  // DPR-correct pointer → canvas coordinates
  function toCanvasCoords(e, c){
    const r = c.getBoundingClientRect();
    const cx = (e.touches?.[0]?.clientX ?? e.clientX);
    const cy = (e.touches?.[0]?.clientY ?? e.clientY);
    return {
      x: (cx - r.left) * (c.width / r.width),
      y: (cy - r.top) * (c.height / r.height)
    };
  }
  const mouse = { x:0, y:0, active:false };
  let mouseMoveThrottle = 0;
  cvs.addEventListener('mousemove', e=>{
    const now = performance.now();
    if (now - mouseMoveThrottle < (GAME_CONSTANTS.PERFORMANCE && GAME_CONSTANTS.PERFORMANCE.MOUSE_THROTTLE_MS || 16)) return; // ~60fps throttle
    mouseMoveThrottle = now;
    
    const p = toCanvasCoords(e, cvs);
    // World coords use CSS pixels; ctx is scaled by DPR → divide back
    mouse.x = p.x / DPR;
    mouse.y = p.y / DPR;
    mouse.active = true;
    // Golf-specific drag logic is handled by golf pointer handlers

    // Enhanced drawing during drag
    if (isDrawing && borderDraw && borderDraw.mode === 'trump') {
      const card = getBorderCardRect();
      if (mouse.x>=card.x && mouse.x<=card.x+card.w && mouse.y>=card.y && mouse.y<=card.y+card.h){
        addDrawingPoint(mouse.x, mouse.y, now);
      }
    }
  }, { passive: true });
  cvs.addEventListener('mouseleave', ()=>{ 
    mouse.active=false; 
    isDrawing=false; 
    // Golf pointer capture handles cancellation
  });
  
  // Enhanced drawing events
  cvs.addEventListener('mousedown', e=>{
    // Allow left-click to trigger standard interact when appropriate
    if (e.button === 0 && !borderDraw && scene !== 'golf' && !choiceOverlay && !infoCard && !flagOverlay) {
      interact();
    }

    // Golf-specific press handled by golf pointer handlers

    if (borderDraw && borderDraw.mode === 'trump') {
      const card = getBorderCardRect();
      const p = toCanvasCoords(e, cvs);
      const mx = p.x / DPR, my = p.y / DPR;
      if (mx>=card.x && mx<=card.x+card.w && my>=card.y && my<=card.y+card.h){
        isDrawing = true;
        lastDrawPoint = {x: mx, y: my, time: nowMs()};
        if (borderDraw.points.length === 0) {
          borderDraw.points.push({x:mx, y:my});
        }
        e.preventDefault();
      }
    }
  });
  
  cvs.addEventListener('mouseup', e=>{
    // Golf release handled by golf pointer handlers
    isDrawing = false;
    lastDrawPoint = null;
  });

  // simple auto-walk tween
  let walkTween = null; // {sx,tx,start,dur}
  function startWalkTo(xTarget, dur, onDone){
    walkTween = { sx: player.x, tx: xTarget, start: nowMs(), dur: Math.max(100, dur), onDone };
    player.facing = Math.sign(xTarget - player.x) || player.facing;
  }
  function stepWalkTween(t){
    if (!walkTween) {
      // Not walking with tween
      if (player.walking && !keys.has('arrowleft') && !keys.has('arrowright') && !keys.has('arrowup') && !keys.has('arrowdown')) {
        player.walking = false;
        player.walkCycle = 0;
      }
      return false;
    }
    const k = Math.min(1, (t - walkTween.start)/walkTween.dur);
    // ease in-out
    const e = k<0.5? 2*k*k : -1 + (4 - 2*k)*k;
    const oldX = player.x;
    player.x = walkTween.sx + (walkTween.tx - walkTween.sx)*e;
    
    // Walking animation during tween
    const dt = 1/60; // Approximate delta time for animation
    if (Math.abs(player.x - oldX) > 0.1) {
      player.walking = true;
      player.walkCycle += dt * 8;
    }
    
    if (k>=1){ 
      const cb=walkTween.onDone; 
      walkTween=null; 
      player.walking = false; 
      player.walkCycle = 0; 
      cb && cb(); 
    }
    return true;
  }
  // Planting dynamite (immediate)
  let PLANTED = []; // [{x,y,start,ttl}]
  let lastPlantAt = 0;
  const PLANT_COOLDOWN_MS = 900;
  function beginPlant(obj){
    // Immediate plant (no hold)
    const nowt = nowMs();
    if ((nowt - lastPlantAt) < PLANT_COOLDOWN_MS) return; // throttle accidental repeats
    lastPlantAt = nowt;
    PLANT = null;
    completePlantImmediate(obj);
  }
  function completePlant(){
    if (!PLANT) return; const obj = PLANT.obj; PLANT=null; completePlantImmediate(obj);
  }
  function completePlantImmediate(obj){
    SFX.buttonPress();
    // show placed sticks briefly at ground near target
    PLANTED.push({ x: obj.x, y: obj.y - 12*CFG.SCALE, start: nowMs(), ttl: 900, lastSparkAt: 0 });
    // consume dynamite from inventory
    const dyn = inventory.find(i=>i.id==='dynamite');
    if (dyn){ dyn.qty = Math.max(0, (dyn.qty||1)-1); if (dyn.qty===0){ const idx=inventory.indexOf(dyn); if (idx!==-1) inventory.splice(idx,1); player.selectedItem=null; } renderInv(); }
    ensureAudioInit();
    spawnSparks(obj.x, obj.y - 20*CFG.SCALE, 12);
    if (obj.type==='mette'){
      // Mette flyver ud af skærmen
      SFX.explosion();
      triggerShake(8*CFG.SCALE, 500);
      say(GL.mette, 'AAAAHH!', 800);
      GL.mette.blownUp = true;
      GL.mette.vy = -600*CFG.SCALE;
      GL.mette.vx = 400*CFG.SCALE;
      // Award Greenland medal
      awardMedal('greenland');
      // Start flag-animation efter kort delay
      setTimeout(() => {
        startFlagDrop();
      }, 1200);
    } else if (obj.type==='bear'){
      GL.bear.angry=true; GL.bear.chasing=true; GL.bear.speed=300; SFX.error();
    } else if (obj.type==='rig'){
      const topX = GL.rig.x, topY = GL.rig.y - 90*CFG.SCALE - 12*CFG.SCALE; spawnFlame(topX, topY, 24);
    } else if (obj.type==='glacier'){
      say(player, 'Perfect! Let\'s blow these ice walls for a TREMENDOUS view!', 1800);
      setTimeout(()=>{
        GL.glaciers.forEach(g=>g.blown=true); GL.state.glaciersBlown=true; startGlacierExplosion();
      }, 600);
    } else if (obj.type==='putin'){
      // Drastic option: blowing up Putin → tongue-in-cheek "world peace" ending
      ensureAudioInit(); SFX.explosion(); triggerShake(10*CFG.SCALE, 600);
      KR.putin.speakingUntil = nowMs() + 1200; KR.putin.say = '…';
      setTimeout(()=>{ try { gameOverCause('kremlin', {delayMs:0, title:'World Peace?', subtitle:'Historic day in geopolitics'}); } catch(_){} }, 500);
    } else if (obj.type==='ground'){
      // Ground explosion with proper feedback
      SFX.explosion();
      triggerShake(4*CFG.SCALE, 300);
      spawnSparks(obj.x, obj.y - 10*CFG.SCALE, 15);
      say(player, 'BOOM! Dynamit plantet!', 1200);
    }
  }
  function nearestToPoint(objs, x, y){
    let best=null, bd=1e9; for (const o of objs){ const d=Math.hypot(x-o.x,y-o.y); if (d<bd){bd=d; best=o;} }
    return {obj:best, dist:bd};
  }
  cvs.addEventListener('click', e=>{
    // Handle intro screen clicks
    if (scene === 'intro') {
      startGame();
      return;
    }
    
    if (choiceOverlay) {
      const layout = layoutChoiceOverlay();
      if (layout && layout.boxes) {
        const p = toCanvasCoords(e, cvs);
        const mx = p.x / DPR, my = p.y / DPR;
        const hit = layout.boxes.find(b => mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h);
        if (hit) {
          choiceOverlay.selected = layout.boxes.indexOf(hit);
          choiceOverlay.onKey(hit.key);
        } else if (choiceOverlay.options && choiceOverlay.options.length) {
          const opt = choiceOverlay.options[choiceOverlay.selected || 0];
          if (opt) choiceOverlay.onKey(opt.key);
        }
      }
      return;
    }
    if (infoCard) return;
    if (flagOverlay) return;
    // Border drawing now handled by mousedown/drag system
    if (borderDraw){
      return;
    }
    
    // Handle Epstein scene clicks
    if (scene === 'epstein') {
      handleEpsteinClick(mouse.x, mouse.y);
      return;
    }
    if (scene === 'golf'){
      return;
    }
    const objs = scene==='greenland' ? [GL.mine, GL.bear, GL.mette, GL.rig, GL.heli, ...GL.items.filter(it=>!it.collected)]
                   : scene==='oval' ? [OV.door, OV.aide, OV.heli, OV.yes, ...OV.buttons]
                   : [KR.door, KR.putin, KR.heli, ...KR.statues.filter(s=>!s.collected)];
    const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
    if (!obj) return;
    const maxClickDist = GAME_CONSTANTS.UI.CLICK_DISTANCE*CFG.SCALE;
    if (dist > maxClickDist) return; // click too far from any object
    // Special-case heli: allow interaction when standing at the side/cabin area
    const need = CFG.INTERACT_DIST*CFG.SCALE - 2;
    let canInteract = false;
    if (obj.type==='heli'){
      canInteract = heliProximity(obj, player.x, player.y) <= 8*CFG.SCALE;
    } else {
      const pd = Math.hypot(player.x-obj.x, player.y-obj.y);
      canInteract = pd <= need;
    }
    if (canInteract){ interact(); return; }
    // auto-walk to just within range then interact
    const side = Math.sign(obj.x - player.x) || 1;
    const targetX = clamp(obj.x - side*need, 40*CFG.SCALE, W-40*CFG.SCALE);
    const dx = Math.abs(targetX - player.x);
    const dur = Math.min(900, (dx / (CFG.SPEED*CFG.SCALE)) * 1000 + 150);
    startWalkTo(targetX, dur, () => interact());
  });

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         13. PHYSICS & MOVEMENT                             ║
  // ║  Jump, animations, glacier explosion, particles, effects                   ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Jump ----------
  let jumpTween = null; // {start,dur,height}
  function doJump(){
    if (choiceOverlay) return;
    if (infoCard) return;
    if (flagOverlay) return;
    if (jumpTween) return;
    // MAGA hat gives super jump!
    const jumpHeight = player.capOn ? 50*CFG.SCALE : 26*CFG.SCALE;
    jumpTween = { start: nowMs(), dur: 520, height: jumpHeight };
  }

  // slight nudge/knockback tween
  function nudge(who, dx, dy, dur=120){
    const s = nowMs(); const sx=who.x, sy=who.y;
    function step(t){ const k=Math.min(1,(t-s)/dur); const e = 1-Math.cos(k*Math.PI); who.x = sx + dx*e; who.y = sy + dy*e; if (k<1) requestAnimationFrame(step); }
    requestAnimationFrame(step);
  }

  
  function startGlacierExplosion() {
    glacierExplosion.active = true;
    glacierExplosion.waterLevel = 0;
    
    // Create multiple explosion points
    GL.glaciers.forEach(glacier => {
      glacierExplosion.explosions.push({
        x: glacier.x,
        y: glacier.y,
        time: nowMs(),
        duration: 1000
      });
      
      // Create ice chunks falling from each glacier
      for (let i = 0; i < 15; i++) {
        glacierExplosion.iceChunks.push({
          x: glacier.x + (Math.random() - 0.5) * glacier.w * CFG.SCALE,
          y: glacier.y - glacier.h * CFG.SCALE/2,
          vx: (Math.random() - 0.5) * 300 * CFG.SCALE,
          vy: -Math.random() * 100 * CFG.SCALE,
          size: 4 + Math.random() * 8,
          rotation: Math.random() * Math.PI * 2,
          rotSpeed: (Math.random() - 0.5) * 10,
          life: 3000 + Math.random() * 2000
        });
      }
    });
    
    // Camera shake for dramatic effect
    triggerShake(15 * CFG.SCALE, 1200);
    
    // Sound effects
    ensureAudioInit();
    SFX.error(); // Explosion sound
    setTimeout(SFX.heartbeat, 300);
    setTimeout(SFX.heartbeat, 600);
    
    // Start water rising after a delay
    setTimeout(() => {
      startWaterRising();
    }, 2000);
  }
  
  function startWaterRising() {
    // Water level will rise and then cap. Now treated as fatal mistake → game over after short delay
    const riseInterval = setInterval(() => {
      glacierExplosion.waterLevel += H / 600; // slower rise
      const maxWater = H * 0.6;
      if (glacierExplosion.waterLevel >= maxWater) {
        glacierExplosion.waterLevel = maxWater;
        clearInterval(riseInterval);
      }
    }, 16);
    // Show dramatic water for a moment, then end the game
    setTimeout(() => { try { gameOverCause('ice'); } catch(_){} }, 1500);
  }

  // ---------- Particle System ----------
  // Object pooling for better performance
  const fx = { blood: [], sparks: [], downwash: [], oil: [], flame: [], confetti: [] };
  const particlePools = { blood: [], sparks: [], downwash: [], oil: [], flame: [] };

  function getParticle(type) { return particlePools[type]?.pop() || {}; }
  function returnParticle(type, particle) {
    Object.keys(particle).forEach(key => delete particle[key]);
    if (particlePools[type]) particlePools[type].push(particle);
  }

  // Generalized particle spawner
  const PARTICLE_CONFIG = {
    blood:    { vxRange: [-30,30], vyRange: [-70,-10], lifeBase: 400, lifeRand: 300, sizeBase: 3, sizeRand: 2 },
    sparks:   { vxRange: [-60,60], vyRange: [-180,-40], lifeBase: 300, lifeRand: 300, sizeBase: 2, sizeRand: 2 },
    oil:      { vxRange: [-30,30], vyRange: [-200,-80], lifeBase: 900, lifeRand: 600, sizeBase: 3, sizeRand: 3, extra: { landed: false } },
    flame:    { vxRange: [-40,40], vyRange: [40,120], lifeBase: 300, lifeRand: 250, sizeBase: 2, sizeRand: 3, colors: ['#ff9800','#ffd54f'] },
    downwash: { vxRange: [-30,30], vyRange: [-60,-20], lifeBase: 300, lifeRand: 300, sizeBase: 3, sizeRand: 3, posRand: [40,6] },
    confetti: { vxRange: [-120,120], vyRange: [-360,-80], lifeBase: 900, lifeRand: 900, sizeBase: 2, sizeRand: 3,
                colors: ['#e91e63','#9c27b0','#3f51b5','#03a9f4','#009688','#8bc34a','#ffeb3b','#ff9800'], hasRotation: true }
  };

  function spawnParticles(type, x, y, count, extraProps = {}) {
    const cfg = PARTICLE_CONFIG[type];
    if (!cfg) return;
    for (let i = 0; i < count; i++) {
      const usePool = type !== 'confetti';
      const p = usePool ? getParticle(type) : {};
      p.x = x + (cfg.posRand ? (Math.random() * cfg.posRand[0] - cfg.posRand[0]/2) : 0);
      p.y = y + (cfg.posRand ? (Math.random() * cfg.posRand[1] - cfg.posRand[1]/2) : 0);
      p.vx = (cfg.vxRange[0] + Math.random() * (cfg.vxRange[1] - cfg.vxRange[0])) * CFG.SCALE;
      p.vy = (cfg.vyRange[0] + Math.random() * (cfg.vyRange[1] - cfg.vyRange[0])) * CFG.SCALE;
      p.life = cfg.lifeBase + Math.random() * cfg.lifeRand;
      p.size = cfg.sizeBase + Math.floor(Math.random() * cfg.sizeRand);
      if (cfg.colors) p.color = cfg.colors[Math.floor(Math.random() * cfg.colors.length)];
      if (cfg.extra) Object.assign(p, cfg.extra);
      if (cfg.hasRotation) { p.rot = Math.random() * Math.PI * 2; p.rotSpeed = (Math.random() * 2 - 1) * 2; }
      Object.assign(p, extraProps);
      fx[type].push(p);
    }
  }

  // Convenience wrappers (maintain API compatibility)
  function spawnBlood(x, y, count = 8) { spawnParticles('blood', x, y, count); }
  function spawnSparks(x, y, count = 12) { spawnParticles('sparks', x, y, count); }
  function spawnOil(x, y, count = 18) { spawnParticles('oil', x, y, count); }
  function spawnFlame(x, y, count = 10) { spawnParticles('flame', x, y, count); }
  function spawnConfetti(x, y, count = 40) { spawnParticles('confetti', x, y, count); }
  function spawnDownwash(x, y, scn) {
    const color = scn === 'greenland' ? 'rgba(255,255,255,0.6)' : 'rgba(200,200,200,0.5)';
    spawnParticles('downwash', x, y, 4 + Math.floor(Math.random() * 3), { color });
  }

  const NUKE = { active:false, x:0, y:0, start:0, dur:3200, startY:0, endY:0 };
  const SHAKE = { start:0, dur:0, amp:0, until:0 };
  function triggerShake(amp, dur){ SHAKE.start=nowMs(); SHAKE.dur=dur; SHAKE.amp=amp; SHAKE.until=SHAKE.start+dur; }
  function launchMissile(){
    NUKE.active=true; NUKE.start=nowMs(); NUKE.dur=3200; NUKE.x = W/2;
    NUKE.startY = H + 200*CFG.SCALE; NUKE.endY = -260*CFG.SCALE; NUKE.y = NUKE.startY;
    triggerShake(8*CFG.SCALE, 700);
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         14. OVERLAYS & MINI-GAMES                          ║
  // ║  Choice dialogs, info cards, handshake tug-of-war, border drawing          ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Choice overlay ----------
  const CHOICE_BOX_COLORS = ['#9feaf2', '#e7e77b', '#f36a6a', '#e892f4', '#5f79df'];
  function parseChoiceText(text){
    const lines = String(text || '').split('\n');
    let header = (lines.shift() || '').trim();
    const options = [];
    lines.forEach(line => {
      const trimmed = line.trim();
      if (!trimmed) return;
      const m = trimmed.match(/^(\d+)\)\s*(.+)$/);
      if (m) options.push({ key: m[1], label: m[2] });
      else options.push({ key: String(options.length + 1), label: trimmed });
    });
    if (!options.length && header) { options.push({ key: '1', label: header }); header = ''; }
    return { header, options };
  }
  function layoutChoiceOverlay(){
    if (!choiceOverlay) return null;
    const options = choiceOverlay.options || [];
    const count = Math.max(1, options.length);
    const boxW = Math.min(W * 0.44, 400 * CFG.SCALE);
    const gap = 8 * CFG.SCALE;
    const maxBoxH = 52 * CFG.SCALE;
    const minBoxH = 30 * CFG.SCALE;
    const targetH = Math.min(H * 0.42, maxBoxH * count + gap * (count - 1));
    const boxH = clamp((targetH - gap * (count - 1)) / count, minBoxH, maxBoxH);
    const totalH = boxH * count + gap * (count - 1);
    const headerH = choiceOverlay.header ? 28 * CFG.SCALE : 0;
    const headerGap = choiceOverlay.header ? 14 * CFG.SCALE : 0;
    const blockH = totalH + headerH + headerGap;
    const startY = (H - blockH) / 2 + headerH + headerGap;
    const x = (W - boxW) / 2;
    const boxes = options.map((opt, i) => ({
      x,
      y: startY + i * (boxH + gap),
      w: boxW,
      h: boxH,
      key: opt.key,
      label: opt.label
    }));
    choiceOverlay.boxes = boxes;
    let hoverIndex = null;
    if (mouse && mouse.active) {
      for (let i = 0; i < boxes.length; i++) {
        const b = boxes[i];
        if (mouse.x >= b.x && mouse.x <= b.x + b.w && mouse.y >= b.y && mouse.y <= b.y + b.h) {
          hoverIndex = i;
          break;
        }
      }
    }
    choiceOverlay.hoverIndex = hoverIndex;
    if (hoverIndex !== null) choiceOverlay.selected = hoverIndex;
    return { boxes, headerY: startY - headerGap, boxW, boxH };
  }
  function openChoice(text, onKey){
    const parsed = parseChoiceText(text);
    choiceOverlay = { text, onKey, header: parsed.header, options: parsed.options, selected: 0, hoverIndex: null, boxes: [] };
  }
  function closeChoice(){ choiceOverlay = null; }

  // ---------- Info card overlay ----------
  let infoCard = null; // {text, onKey} - styled like flag overlay card
  function openInfoCard(text, onKey){
    infoCard = { text, onKey };
  }
  function closeInfoCard(){ infoCard = null; }
  // Start Nobel drop if ready when closing any info card
  const _origCloseInfoCard = closeInfoCard;
  closeInfoCard = function(){
    infoCard = null;
    if (nobelDrop && nobelDrop.ready && !nobelDrop.active && !GS.nobelAwarded){
      nobelDrop.active = true; nobelDrop.y = -80*CFG.SCALE; nobelDrop.vy = 0; nobelDrop.swingPhase = 0; nobelDrop.swingAmp = 0.6;
    }
  };

  function drawInfoCard() {
    if (!infoCard) return;
    
    const card = getBorderCardRect();
    
    // Dim background outside card area only
    ctx.fillStyle='rgba(0,0,0,.6)'; 
    ctx.fillRect(0, 0, W, H);
    
    // Clear card area (remove dimming)
    ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
    
    // Draw card background with border frame
    ctx.fillStyle='#f7f5ee'; 
    ctx.fillRect(card.x, card.y, card.w, card.h);
    
    // Enhanced frame/border around card
    ctx.strokeStyle='#c9a641'; 
    ctx.lineWidth=6; 
    ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
    
    // Inner shadow effect
    ctx.strokeStyle='#8b7355'; 
    ctx.lineWidth=2; 
    ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);
    
    // Draw text content centered in card
    const lines = infoCard.text.split('\n');
    ctx.fillStyle='#333'; 
    ctx.font=`bold ${16*CFG.SCALE}px system-ui`; 
    ctx.textAlign='center';
    
    const lineHeight = 22*CFG.SCALE;
    const totalTextHeight = lines.length * lineHeight;
    const startY = card.y + (card.h - totalTextHeight) / 2 + lineHeight;
    
    lines.forEach((line, i) => {
      ctx.fillText(line, card.x + card.w/2, startY + i * lineHeight);
    });
    
    ctx.textAlign='left';
  }

  // ---------- Tug-of-war mini-game ----------
  let tug = null; // {pos,lastKey,start,dur}
  function startHandshake(){ 
    openInfoCard("HANDTRYKS-KAMP MED PUTIN\n\nHvem har det kraftigste handtryk?\nDig eller Putin?\nDen staerkeste faar Ukraine!\n\nTryk A og D hurtigt for at vinde!\n\n1. Start kampen!\n2. Du kan ikke fortryde", k => {
      closeInfoCard();
      // Begge options starter spillet - ingen vej tilbage!
      startTug();
    });
  }
  function startTug(){
    if (tug) return;
    tug = { pos:0, lastKey:'', start: nowMs(), dur: 6000, phase: 1 }; // longer duration, phase tracking
  }
  function handleTugKey(k){
    if (!tug) return;
    const elapsed = nowMs() - tug.start;
    const halfTime = tug.dur / 2;

    // Phase 1: A+D, Phase 2: F+K
    if (elapsed < halfTime) {
      tug.phase = 1;
      if ((k==='a' || k==='d') && k!==tug.lastKey){ tug.pos += 0.15; tug.lastKey = k; }
    } else {
      tug.phase = 2;
      if ((k==='f' || k==='k') && k!==tug.lastKey){ tug.pos += 0.15; tug.lastKey = k; }
    }
  }

  function drawArmWrestling(ctx, centerX, centerY, progress) {
    // progress: -1 (Putin winning) to +1 (Trump winning)
    const armAngle = progress * 0.6; // radians, how far the arms are tilted

    ctx.save();
    ctx.translate(centerX, centerY);

    // Table surface
    ctx.fillStyle = '#5d4037';
    ctx.fillRect(-80*CFG.SCALE, 20*CFG.SCALE, 160*CFG.SCALE, 15*CFG.SCALE);
    ctx.fillStyle = '#4e342e';
    ctx.fillRect(-80*CFG.SCALE, 30*CFG.SCALE, 160*CFG.SCALE, 5*CFG.SCALE);

    // Arms pivot point (elbow on table)
    const elbowY = 15*CFG.SCALE;

    // Trump's arm (left side, orange/tan skin)
    ctx.save();
    ctx.translate(-15*CFG.SCALE, elbowY);
    ctx.rotate(-Math.PI/2 + armAngle); // Start vertical, tilt based on progress

    // Trump forearm
    ctx.fillStyle = '#f5cba7'; // tan skin
    ctx.fillRect(-8*CFG.SCALE, -50*CFG.SCALE, 16*CFG.SCALE, 50*CFG.SCALE);

    // Trump suit sleeve
    ctx.fillStyle = '#1a237e'; // dark blue suit
    ctx.fillRect(-10*CFG.SCALE, -10*CFG.SCALE, 20*CFG.SCALE, 15*CFG.SCALE);

    // Trump hand (fist)
    ctx.fillStyle = '#f5cba7';
    ctx.beginPath();
    ctx.arc(0, -55*CFG.SCALE, 10*CFG.SCALE, 0, Math.PI*2);
    ctx.fill();
    // Fingers gripping
    ctx.fillRect(-6*CFG.SCALE, -62*CFG.SCALE, 12*CFG.SCALE, 8*CFG.SCALE);

    ctx.restore();

    // Putin's arm (right side, pale skin)
    ctx.save();
    ctx.translate(15*CFG.SCALE, elbowY);
    ctx.rotate(-Math.PI/2 - armAngle); // Mirror angle

    // Putin forearm
    ctx.fillStyle = '#fdebd0'; // pale skin
    ctx.fillRect(-8*CFG.SCALE, -50*CFG.SCALE, 16*CFG.SCALE, 50*CFG.SCALE);

    // Putin suit sleeve (dark)
    ctx.fillStyle = '#212121';
    ctx.fillRect(-10*CFG.SCALE, -10*CFG.SCALE, 20*CFG.SCALE, 15*CFG.SCALE);

    // Putin hand (fist)
    ctx.fillStyle = '#fdebd0';
    ctx.beginPath();
    ctx.arc(0, -55*CFG.SCALE, 10*CFG.SCALE, 0, Math.PI*2);
    ctx.fill();
    // Fingers gripping
    ctx.fillRect(-6*CFG.SCALE, -62*CFG.SCALE, 12*CFG.SCALE, 8*CFG.SCALE);

    ctx.restore();

    // Hands gripping each other (center)
    ctx.fillStyle = '#e8daef';
    ctx.beginPath();
    const handY = elbowY - 50*CFG.SCALE - Math.abs(armAngle)*20*CFG.SCALE;
    ctx.arc(armAngle*30*CFG.SCALE, handY, 14*CFG.SCALE, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Strain lines when close to winning/losing
    if (Math.abs(progress) > 0.5) {
      ctx.strokeStyle = progress > 0 ? '#27ae60' : '#e74c3c';
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2 + nowMs()/200;
        const r1 = 18*CFG.SCALE;
        const r2 = 25*CFG.SCALE;
        ctx.beginPath();
        ctx.moveTo(armAngle*30*CFG.SCALE + Math.cos(angle)*r1, handY + Math.sin(angle)*r1);
        ctx.lineTo(armAngle*30*CFG.SCALE + Math.cos(angle)*r2, handY + Math.sin(angle)*r2);
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  // ---------- Border drawing overlay (Kremlin) ----------
  // borderDraw already declared above
  function startBorderDraw(mode){
    borderDraw = { active:true, points:[], mode: mode==='putin' ? 'putin' : 'trump', gen:false };
  }
  function stopBorderDraw(save){
    if (save && borderDraw){
      // normalize and store in KR.border
      const card = getBorderCardRect();
      const pts = borderDraw.points.map(p=>({ x: (p.x - card.x)/card.w, y: (p.y - card.y)/card.h }));
      KR.border = pts;
      reactToBorder(pts, borderDraw.mode);
    }
    borderDraw = null;
  }
  function getBorderCardRect(){
    const w = Math.min(620*CFG.SCALE, W*0.8), h = w*0.6;
    return { x: W/2 - w/2, y: H/2 - h/2, w, h };
  }

  // ---------- Flag planting system ----------
  function plantFlag(flagType) {
    KR.ukraineFlag = flagType;
    flagOverlay = { 
      flagType, 
      startTime: nowMs(),
      animationStart: nowMs(),
      animationDuration: 2000 // 2 seconds for animation
    };
  }

  function closeFlagOverlay() {
    flagOverlay = null;
    // Award Nobel immediately after exiting the map if pending and American flag planted
    if (KR.nobelPending && KR.ukraineFlag === 'american' && !GS.nobelAwarded) {
      KR.nobelPending = false;
      awardNobel();
    }
  }

  // Nobel medal drop FX state
  let nobelDrop = { active:false, ready:false, y:-80, vy:0, swingPhase:0, swingAmp:0.6 };
  function awardNobel(){
    ensureAudioInit();
    SFX.achievement();
    // Start falling medal from above immediately
    nobelDrop.ready = false;
    nobelDrop.active = true; 
    nobelDrop.y = -80*CFG.SCALE; 
    nobelDrop.vy = 0; 
    nobelDrop.swingPhase = 0; 
    nobelDrop.swingAmp = 0.6; 
  }

  function drawFlagOverlay() {
    if (!flagOverlay) return;
    
    const card = getBorderCardRect();
    
    // Dim background outside card area only
    ctx.fillStyle='rgba(0,0,0,.6)'; 
    ctx.fillRect(0, 0, W, H);
    
    // Clear card area (remove dimming)
    ctx.fillStyle='rgba(0,0,0,0)';
    ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
    
    // Draw map background with border frame
    ctx.fillStyle='#f7f5ee'; 
    ctx.fillRect(card.x, card.y, card.w, card.h);
    
    // Enhanced frame/border around card
    ctx.strokeStyle='#c9a641'; 
    ctx.lineWidth=6; 
    ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
    
    // Inner shadow effect
    ctx.strokeStyle='#8b7355'; 
    ctx.lineWidth=2; 
    ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);
    
    // Draw world map
    if (MAP_IMG_READY){
      ctx.drawImage(MAP_IMG, card.x, card.y, card.w, card.h);
    } else {
      ctx.save(); 
      ctx.translate(card.x, card.y);
      drawEnhancedWorldMap(ctx, card.w, card.h);
      ctx.restore();
    }
    
    // Draw flag on Ukraine
    drawFlagOnUkraine(card, flagOverlay.flagType);
    
    // Show message inside bottom frame with white text
    ctx.fillStyle='#fff'; 
    ctx.font=`bold ${18*CFG.SCALE}px system-ui`; 
    ctx.textAlign='center';
    const message = flagOverlay.flagType === 'american' ? 'UKRAINE ER NU AMERIKANSK TERRITORIUM!' : 'UKRAINE FORBLIVER UNDER RUSSISK INDFLYDELSE!';
    ctx.fillText(message, W/2, card.y + card.h - 25*CFG.SCALE);
    // Instruction inside the frame at the bottom
    ctx.fillStyle='#333'; 
    ctx.font=`${14*CFG.SCALE}px system-ui`;
    ctx.fillText('Tryk Enter for at fortsætte', W/2, card.y + card.h - 6*CFG.SCALE);
    ctx.textAlign='left';
  }

  function drawFlagOnUkraine(card, flagType) {
    // Ukraine position on map (relative to card) - updated for new cropped map
    const ukraineX = card.x + card.w * 0.50;
    const ukraineY = card.y + card.h * 0.50;
    
    // Animation calculations
    const elapsed = nowMs() - flagOverlay.animationStart;
    const progress = Math.min(1, elapsed / flagOverlay.animationDuration);
    
    // Easing function with bounce
    const easeOutBounce = (t) => {
      if (t < 1/2.75) {
        return 7.5625 * t * t;
      } else if (t < 2/2.75) {
        return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
      } else if (t < 2.5/2.75) {
        return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
      } else {
        return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
      }
    };
    
    const animatedProgress = easeOutBounce(progress);
    
    // Animation: flag drops from above and scales in
    const startY = ukraineY - 60; // Start position (above Ukraine)
    const currentY = startY + (ukraineY - startY) * animatedProgress;
    const scale = 0.3 + (0.7 * animatedProgress); // Start small, grow to normal
    
    // Draw flag with animation
    const flagWidth = 16 * scale;
    const flagHeight = 12 * scale;
    
    ctx.save();
    // Add slight rotation during fall
    const rotation = (1 - animatedProgress) * 0.3;
    ctx.translate(ukraineX, currentY);
    ctx.rotate(rotation);
    
    if (flagType === 'american') {
      // American flag (simplified)
      ctx.fillStyle='#b22234'; // red
      ctx.fillRect(-flagWidth/2, -flagHeight/2, flagWidth, flagHeight);
      ctx.fillStyle='#ffffff'; // white stripes
      for (let i = 1; i < flagHeight; i += 2) {
        ctx.fillRect(-flagWidth/2, -flagHeight/2+i, flagWidth, 1);
      }
      ctx.fillStyle='#3c3b6e'; // blue canton
      ctx.fillRect(-flagWidth/2, -flagHeight/2, flagWidth/2, flagHeight/2);
    } else if (flagType === 'russian') {
      // Russian flag (simplified)
      ctx.fillStyle='#ffffff'; // white
      ctx.fillRect(-flagWidth/2, -flagHeight/2, flagWidth, flagHeight/3);
      ctx.fillStyle='#0039a6'; // blue  
      ctx.fillRect(-flagWidth/2, -flagHeight/2+flagHeight/3, flagWidth, flagHeight/3);
      ctx.fillStyle='#d52b1e'; // red
      ctx.fillRect(-flagWidth/2, -flagHeight/2+2*flagHeight/3, flagWidth, flagHeight/3);
    }
    
    ctx.restore();
  }
  
  function drawEnhancedWorldMap(ctx, w, h) {
    // Ocean background - darker blue
    ctx.fillStyle='#1a5276';
    ctx.fillRect(0, 0, w, h);

    // Simplified map focused on Europe/Ukraine/Russia region

    // Europe (western) - muted purple
    ctx.fillStyle='#5d6d7e';
    ctx.beginPath();
    ctx.moveTo(w*0.05, h*0.25);
    ctx.lineTo(w*0.25, h*0.20);
    ctx.lineTo(w*0.35, h*0.30);
    ctx.lineTo(w*0.35, h*0.55);
    ctx.lineTo(w*0.20, h*0.65);
    ctx.lineTo(w*0.05, h*0.50);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle='#2c3e50';
    ctx.lineWidth=2;
    ctx.stroke();

    // Russia - large red mass on right
    ctx.fillStyle='#c0392b';
    ctx.beginPath();
    ctx.moveTo(w*0.55, h*0.10);
    ctx.lineTo(w*0.95, h*0.08);
    ctx.lineTo(w*0.98, h*0.35);
    ctx.lineTo(w*0.90, h*0.55);
    ctx.lineTo(w*0.65, h*0.60);
    ctx.lineTo(w*0.55, h*0.45);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle='#922b21';
    ctx.lineWidth=3;
    ctx.stroke();

    // UKRAINE - THE PRIZE! Big, central, prominent
    // More accurate Ukraine shape
    ctx.fillStyle='#f4d03f'; // Bright yellow (Ukrainian flag color)
    ctx.beginPath();
    ctx.moveTo(w*0.38, h*0.32); // Northwest
    ctx.lineTo(w*0.52, h*0.28); // North
    ctx.lineTo(w*0.58, h*0.35); // Northeast
    ctx.lineTo(w*0.62, h*0.42); // East (Donbas region)
    ctx.lineTo(w*0.58, h*0.55); // Southeast (Crimea area)
    ctx.lineTo(w*0.50, h*0.58); // South
    ctx.lineTo(w*0.42, h*0.55); // Southwest
    ctx.lineTo(w*0.36, h*0.45); // West
    ctx.closePath();
    ctx.fill();

    // Ukraine border - thick and visible
    ctx.strokeStyle='#2874a6'; // Blue (Ukrainian flag color)
    ctx.lineWidth=4;
    ctx.stroke();

    // Pulsing glow effect for Ukraine
    const pulse = Math.sin(nowMs() / 300) * 0.3 + 0.7;
    ctx.shadowColor = '#f4d03f';
    ctx.shadowBlur = 15 * pulse;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Black Sea
    ctx.fillStyle='#1b4f72';
    ctx.beginPath();
    ctx.ellipse(w*0.52, h*0.72, w*0.15, h*0.12, 0, 0, Math.PI*2);
    ctx.fill();

    // Labels - big and clear
    ctx.textAlign='center';

    // UKRAINE label - biggest and most prominent
    ctx.fillStyle='#1a5276';
    ctx.font = `bold ${Math.floor(h*0.08)}px system-ui`;
    ctx.fillText('UKRAINE', w*0.50, h*0.46);

    // Flag colors on Ukraine text
    ctx.fillStyle='#f4d03f';
    ctx.fillRect(w*0.35, h*0.48, w*0.30, h*0.02);
    ctx.fillStyle='#2874a6';
    ctx.fillRect(w*0.35, h*0.50, w*0.30, h*0.02);

    // Other labels
    ctx.fillStyle='#ecf0f1';
    ctx.font = `bold ${Math.floor(h*0.05)}px system-ui`;
    ctx.fillText('🇪🇺 EUROPE', w*0.18, h*0.40);
    ctx.fillText('🇷🇺 RUSSIA', w*0.75, h*0.30);

    // Black Sea label
    ctx.fillStyle='#85c1e9';
    ctx.font = `${Math.floor(h*0.035)}px system-ui`;
    ctx.fillText('Black Sea', w*0.52, h*0.74);

    // Arrows pointing at Ukraine from both sides (tug-of-war visual)
    ctx.strokeStyle='#e74c3c';
    ctx.lineWidth=3;
    // Arrow from Russia
    ctx.beginPath();
    ctx.moveTo(w*0.68, h*0.40);
    ctx.lineTo(w*0.62, h*0.42);
    ctx.stroke();
    drawArrowHead(ctx, w*0.62, h*0.42, Math.PI, h*0.03);

    ctx.strokeStyle='#3498db';
    // Arrow from Europe
    ctx.beginPath();
    ctx.moveTo(w*0.32, h*0.40);
    ctx.lineTo(w*0.38, h*0.42);
    ctx.stroke();
    drawArrowHead(ctx, w*0.38, h*0.42, 0, h*0.03);

    ctx.textAlign='left';
  }

  function drawArrowHead(ctx, x, y, angle, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-size, -size/2);
    ctx.lineTo(-size, size/2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  
  function drawNuclearSymbol(ctx, x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle='#e84393';
    // Nuclear trefoil symbol
    for(let i = 0; i < 3; i++) {
      ctx.save();
      ctx.rotate(i * Math.PI * 2/3);
      ctx.beginPath();
      ctx.arc(0, -size*0.7, size*0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    // Center circle
    ctx.beginPath();
    ctx.arc(0, 0, size*0.3, 0, Math.PI * 2);
    ctx.fillStyle='#2d3436';
    ctx.fill();
    ctx.restore();
  }
  function smoothBorder() {
    if (!borderDraw || borderDraw.points.length < 3) return;
    
    // Simple smoothing using average of neighboring points
    const original = [...borderDraw.points];
    for (let i = 1; i < original.length - 1; i++) {
      const prev = original[i-1];
      const curr = original[i];
      const next = original[i+1];
      
      // Average position with neighbors (weighted toward current)
      borderDraw.points[i] = {
        x: (prev.x * 0.2 + curr.x * 0.6 + next.x * 0.2),
        y: (prev.y * 0.2 + curr.y * 0.6 + next.y * 0.2)
      };
    }
  }
  
  function addDrawingPoint(x, y, time) {
    if (!borderDraw || !borderDraw.points) return;
    
    // Check if we should add this point based on distance and time
    if (lastDrawPoint) {
      const dist = Math.hypot(x - lastDrawPoint.x, y - lastDrawPoint.y);
      const timeDiff = time - lastDrawPoint.time;
      const speed = dist / Math.max(timeDiff, 1) * 1000; // pixels per second
      
      // Skip point if too close or moving too fast (likely erratic)
      if (dist < drawingSettings.smoothingDistance) return;
      if (speed > drawingSettings.maxDrawingSpeed && borderDraw.points.length > 2) return;
    }
    
    // Add point with smooth interpolation if gap is large
    if (lastDrawPoint) {
      const dist = Math.hypot(x - lastDrawPoint.x, y - lastDrawPoint.y);
      if (dist > drawingSettings.smoothingDistance * 3) {
        // Add intermediate points for smooth curves
        const steps = Math.floor(dist / drawingSettings.smoothingDistance);
        for (let i = 1; i < steps; i++) {
          const t = i / steps;
          const ix = lastDrawPoint.x + (x - lastDrawPoint.x) * t;
          const iy = lastDrawPoint.y + (y - lastDrawPoint.y) * t;
          borderDraw.points.push({x: ix, y: iy});
        }
      }
    }
    
    borderDraw.points.push({x, y});
    lastDrawPoint = {x, y, time};
    
    // Limit total points to prevent performance issues
    if (borderDraw.points.length > 200) {
      // Remove every other point to reduce complexity while maintaining shape
      borderDraw.points = borderDraw.points.filter((_, i) => i % 2 === 0);
    }
  }
  
  function analyzeBorderLive(pts, card) {
    // Real-time analysis for drawing feedback
    let len=0, turns=0, aggression=0;
    
    for (let i=1;i<pts.length;i++){
      const dx=pts[i].x-pts[i-1].x, dy=pts[i].y-pts[i-1].y;
      len+=Math.hypot(dx,dy);
      
      if (i>1){
        const a=Math.atan2(dy,dx), b=Math.atan2(pts[i-1].y-pts[i-2].y, pts[i-1].x-pts[i-2].x);
        if (Math.abs(a-b)>0.8) turns++;
      }
      
      // Normalized coordinates for aggression check
      const normalX = (pts[i].x - card.x) / card.w;
      if (normalX > 0.6) aggression++;
    }
    
    const lengthDesc = len < 200 ? 'Short' : len < 500 ? 'Medium' : 'Long';
    const strategyDesc = turns < 3 ? 'Direct' : turns < 8 ? 'Diplomatic' : 'Complex';
    const aggressionDesc = aggression < 2 ? 'Peaceful' : aggression < 5 ? 'Assertive' : 'Aggressive';
    
    return { lengthDesc, strategyDesc, aggressionDesc };
  }
  
  function reactToBorder(pts, mode){
    // Enhanced border analysis
    let len=0, turns=0, straightness=0, aggression=0;
    
    for (let i=1;i<pts.length;i++){
      const dx=pts[i].x-pts[i-1].x, dy=pts[i].y-pts[i-1].y;
      len+=Math.hypot(dx,dy);
      
      if (i>1){
        const a=Math.atan2(dy,dx), b=Math.atan2(pts[i-1].y-pts[i-2].y, pts[i-1].x-pts[i-2].x);
        const angleDiff = Math.abs(a-b);
        if (angleDiff>0.8) turns++;
        straightness += angleDiff;
      }
      
      // Check for aggressive land grabs (going into enemy territory)
      if (mode==='trump' && pts[i].x > 0.6) aggression++;
      if (mode==='putin' && pts[i].x < 0.4) aggression++;
    }
    
    const complexity = turns + straightness*10;
    const landGrab = aggression / pts.length;
    
    // Enhanced reactions based on border characteristics
    let trumpLines, putinLines;
    
    if (landGrab > 0.3) {
      trumpLines = ['Tremendous expansion!', 'Best deals, huge territory!', 'Making borders great again!'];
      putinLines = ['Very aggressive move.', 'Bold territorial claim.', 'Interesting strategy.'];
    } else if (complexity < 5) {
      trumpLines = ['Simple and effective!', 'Clean lines, perfect!', 'Straight to the point!'];
      putinLines = ['Efficient boundaries.', 'Practical approach.', 'Minimalist style.'];
    } else if (complexity > 20) {
      trumpLines = ['Complex negotiations!', 'Artistic borders!', 'Very detailed work!'];
      putinLines = ['Complicated boundaries.', 'Intricate design.', 'Many considerations.'];
    } else {
      trumpLines = ['Fair and balanced!', 'Perfect compromise!', 'Diplomatic borders!'];
      putinLines = ['Reasonable solution.', 'Balanced approach.', 'Acceptable terms.'];
    }
    
    const line = (mode==='trump' ? trumpLines : putinLines)[Math.floor(Math.random() * 3)];
    
    if (mode==='trump') {
      say(player, line, 1800);
    } else { 
      KR.putin.speakingUntil=nowMs()+1800; 
      KR.putin.say=line;
    }
    
    // Store border metrics for potential future use
    KR.borderMetrics = { length: len, complexity, aggression: landGrab, mode };
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         15. SPRITE DRAWING FUNCTIONS                       ║
  // ║  All procedural character/object rendering (Trump, Mette, Bear, etc.)      ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Tegn elementer ----------
  function drawTrump(x,y,dir=1){
    // Draw either custom sprite or fallback
    const usedImg = GRAPHICS.drawOrFallback(ctx, 'trump', drawTrumpFallback, x, y, dir);
    if (!usedImg) drawTrumpFallback(x, y, dir);
    // Overlay Nobel medal if awarded
    if (GS.nobelAwarded) drawNobelMedal(x, y);
  }
  
  function drawTrumpFallback(x,y,dir=1){
    // slight head/torso nod
    const nod = Math.sin(nowMs()/1100 + (player.nodPhase||0)) * 0.6*CFG.SCALE;
    // subtle swim bob when submerged
    let bob = 0;
    if (scene==='greenland' && glacierExplosion && glacierExplosion.active && glacierExplosion.waterLevel>0){
      const waterLine = H - glacierExplosion.waterLevel;
      const headY = y - 44*CFG.SCALE + nod - 38*CFG.SCALE;
      if (headY > waterLine) bob = Math.sin(nowMs()/600)*1.5*CFG.SCALE;
    }
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE + nod + bob); ctx.scale(CFG.SCALE, CFG.SCALE);
    
    const wearingGoldSneakers = !!player.goldenShoesOn;
    function paintLegRect(xPos, yPos, w, h){
      const pantHeight = wearingGoldSneakers ? Math.max(0, h - 4) : h;
      if (pantHeight > 0){
        ctx.fillStyle='#2b2b2b';
        ctx.fillRect(xPos, yPos, w, pantHeight);
      }
      if (wearingGoldSneakers){
        const shoeY = yPos + pantHeight;
        const shoeH = Math.max(0, h - pantHeight);
        if (shoeH > 0){
          ctx.fillStyle='#f5d36a';
          ctx.fillRect(xPos, shoeY, w, shoeH);
          if (shoeH >= 2 && w >= 4){
            ctx.fillStyle='#1e4fbf';
            ctx.fillRect(xPos + 1, shoeY, Math.max(1, w - 2), 1);
            if (shoeH >= 3){
              ctx.fillStyle='#ff3b2f';
              ctx.fillRect(xPos + 1, shoeY + 1, Math.max(1, w - 2), 1);
            }
          }
          ctx.fillStyle='#b88a1d';
          ctx.fillRect(xPos, shoeY + shoeH - 1, w, 1);
        }
      }
    }

    // Walking animation for legs
    if (player.walking && Math.floor(player.walkCycle) % 2 === 0) {
      // Walking pose 1 - left leg forward
      paintLegRect(-10,34,9,10); // left leg normal
      paintLegRect(2,36,9,8);    // right leg back/up
    } else if (player.walking) {
      // Walking pose 2 - right leg forward  
      paintLegRect(-10,36,9,8);  // left leg back/up
      paintLegRect(2,34,9,10);   // right leg normal
    } else {
      // Standing still - normal pose
      paintLegRect(-10,34,9,10); 
      paintLegRect(2,34,9,10);
    }
    ctx.fillStyle='#7a5328'; ctx.fillRect(-12,6,24,26);
    ctx.fillStyle='#d8e6ff'; ctx.fillRect(-8,10,16,18);
    ctx.fillStyle='#e02424'; ctx.fillRect(-2,14,4,14);
    ctx.fillStyle=skinColor(); ctx.fillRect(-9,-2,18,12);
    // eyes (blink)
    if (!(player.blinkUntil && nowMs() < player.blinkUntil)){
      ctx.fillStyle='#111'; ctx.fillRect(-6,2,2,2); ctx.fillRect(4,2,2,2);
    } else {
      ctx.fillStyle='#111'; ctx.fillRect(-6,3,2,1); ctx.fillRect(4,3,2,1);
    }
    // hair or cap
    if (player.capOn){
      ctx.fillStyle='#c22'; ctx.fillRect(-10,-6,20,6); ctx.fillRect(-12,-2,24,2);
    } else {
      ctx.fillStyle='#f3a32d'; ctx.fillRect(-10,-6,20,6);
    }
    // item in hand: dynamite if selected, otherwise phone (blinking)
    const blinking = nowMs() < phoneBlinkUntil && Math.floor(nowMs()/100)%2===0;
    if (player.selectedItem === 'dynamite'){
      ctx.fillStyle='#d32f2f';
      if (dir<0){ ctx.fillRect(-20,12,6,14); ctx.fillRect(-12,12,6,14); ctx.fillStyle='#333'; ctx.fillRect(-20,16,6,2); ctx.fillRect(-12,16,6,2); }
      else { ctx.fillStyle='#d32f2f'; ctx.fillRect(10,12,6,14); ctx.fillRect(18,12,6,14); ctx.fillStyle='#333'; ctx.fillRect(10,16,6,2); ctx.fillRect(18,16,6,2); }
    } else {
      ctx.fillStyle='#111';
      if (dir<0){
        ctx.fillRect(-20,12,10,16);
        ctx.fillStyle = blinking ? '#6ff' : '#09f';
        ctx.fillRect(-17,16,4,8);
      } else {
        ctx.fillRect(10,12,10,16);
        ctx.fillStyle = blinking ? '#6ff' : '#09f';
        ctx.fillRect(13,16,4,8);
      }
    }
    ctx.globalAlpha=.2; ctx.fillStyle='#000'; if (dir<0) ctx.fillRect(-14,15,2,10); else ctx.fillRect(12,15,2,10);
    ctx.restore();
  }
  // Generalized character drawing system for Trump/Epstein variants
  const CHAR_VARIANTS = {
    trumpSmile: { type:'trump', legs:'#2b2b2b', suit:'#7a5328', shirt:'#d8e6ff', tie:'#e02424', face:null, eyes:'#111', hair:'#f3a32d', smile:true, goldShoes:true },
    trumpBW:    { type:'trump', legs:'#444', suit:'#666', shirt:'#bbb', tie:'#555', face:'#caa', eyes:'#222', hair:'#999' },
    epstein:    { type:'epstein', suit:'#333', legs:'#111', shirt:'#ddd', face:'#e6c9a8', hair:'#bbb', sunglasses:true },
    epsteinBW:  { type:'epstein', suit:'#444', legs:'#222', shirt:'#bbb', face:'#999', hair:'#aaa', sunglasses:true }
  };

  function drawCharVariant(x, y, variant) {
    const v = CHAR_VARIANTS[variant];
    if (!v) return;
    const nod = (variant === 'trumpSmile') ? Math.sin(nowMs()/1100 + (player.nodPhase||0)) * 0.3*CFG.SCALE : 0;
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE + nod); ctx.scale(CFG.SCALE, CFG.SCALE);

    if (v.type === 'trump') {
      // Trump body structure
      const goldShoes = v.goldShoes && player.goldenShoesOn;
      [[-10,34,9,10], [2,34,9,10]].forEach(([lx,ly,lw,lh]) => {
        const pantH = goldShoes ? Math.max(0, lh - 4) : lh;
        if (pantH > 0) { ctx.fillStyle = v.legs; ctx.fillRect(lx, ly, lw, pantH); }
        if (goldShoes && lh - pantH > 0) {
          const shoeY = ly + pantH, shoeH = lh - pantH;
          ctx.fillStyle = '#f5d36a'; ctx.fillRect(lx, shoeY, lw, shoeH);
          ctx.fillStyle = '#1e4fbf'; ctx.fillRect(lx+1, shoeY, lw-2, 1);
          ctx.fillStyle = '#ff3b2f'; ctx.fillRect(lx+1, shoeY+1, lw-2, 1);
          ctx.fillStyle = '#b88a1d'; ctx.fillRect(lx, shoeY+shoeH-1, lw, 1);
        }
      });
      ctx.fillStyle = v.suit; ctx.fillRect(-12,6,24,26);
      ctx.fillStyle = v.shirt; ctx.fillRect(-8,10,16,18);
      ctx.fillStyle = v.tie; ctx.fillRect(-2,14,4,14);
      ctx.fillStyle = v.face || skinColor(); ctx.fillRect(-9,-2,18,12);
      ctx.fillStyle = v.eyes; ctx.fillRect(-6,2,2,2); ctx.fillRect(4,2,2,2);
      ctx.fillStyle = v.hair; ctx.fillRect(-10,-6,20,6);
      if (v.smile) { ctx.fillStyle = '#111'; ctx.fillRect(-3,6,6,1); ctx.fillRect(-4,5,1,1); ctx.fillRect(3,5,1,1); }
    } else {
      // Epstein body structure
      ctx.fillStyle = v.suit; ctx.fillRect(-10,8,20,26);
      ctx.fillStyle = v.legs; ctx.fillRect(-7,34,6,10); ctx.fillRect(1,34,6,10);
      ctx.fillStyle = v.shirt; ctx.fillRect(-6,12,12,12);
      ctx.fillStyle = v.face; ctx.fillRect(-8,-2,16,12);
      if (v.sunglasses) { ctx.fillStyle = '#111'; ctx.fillRect(-7,2,6,3); ctx.fillRect(1,2,6,3); ctx.fillRect(-1,3,2,1); }
      ctx.fillStyle = v.hair; ctx.fillRect(-9,-5,18,5);
    }
    ctx.restore();
  }

  // Convenience wrappers (maintain API compatibility)
  function drawTrumpSmile(x,y) { drawCharVariant(x, y, 'trumpSmile'); }
  function drawEpsteinSunglasses(x,y) { drawCharVariant(x, y, 'epstein'); }
  function drawTrumpBW(x,y) { drawCharVariant(x, y, 'trumpBW'); }
  function drawEpsteinBWSunglasses(x,y) { drawCharVariant(x, y, 'epsteinBW'); }
  // Simple plane labeled VIRGIN
  function drawVirginPlane(cx, cy, scale=1){
    ctx.save(); ctx.translate(cx, cy); ctx.scale(CFG.SCALE*scale, CFG.SCALE*scale);
    // fuselage
    ctx.fillStyle='#e0e0e0'; ctx.fillRect(-120,-20,240,40);
    // nose
    ctx.beginPath(); ctx.moveTo(-120,-20); ctx.quadraticCurveTo(-150,0,-120,20); ctx.closePath(); ctx.fill();
    // tail
    ctx.fillStyle='#b71c1c'; ctx.fillRect(90,-40,20,40);
    // wing
    ctx.fillStyle='#d0d0d0'; ctx.fillRect(-30,-8,140,16);
    // text VIRGIN
    ctx.fillStyle='#b71c1c'; ctx.font='bold 12px system-ui'; ctx.textAlign='center'; ctx.fillText('VIRGIN', 10, 4);
    ctx.restore();
  }
  function drawNobelMedal(x,y){
    // Draw simple ribbon + gold medal overlay on chest area
    ctx.save();
    ctx.translate(x, y-44*CFG.SCALE);
    ctx.scale(CFG.SCALE, CFG.SCALE);
    // ribbon
    ctx.fillStyle = '#1565c0';
    ctx.fillRect(-8, 10, 16, 3);
    // medal string
    ctx.fillStyle = '#1e88e5';
    ctx.fillRect(-2, 10, 4, 8);
    // medal
    ctx.fillStyle = '#d4af37';
    ctx.beginPath(); ctx.arc(0, 20, 5, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function skinColor(){
    // Enhanced, more dramatic tan gradient (0..5)
    const levels = ['#f4cda4','#f1b577','#ee9850','#ea7a28','#e16706','#c65200'];
    return levels[Math.min(levels.length-1, player.tanLevel||0)];
  }
  function drawMette(x,y,rotation=0){
    // Lars Løkke character (replaces Mette)
    const larsScale = 0.85;
    const baseH = 37; // leg bottom in local sprite coords
    const nod = rotation ? 0 : Math.sin(nowMs()/1200 + (GL.mette.nodPhase||0)) * 0.5*CFG.SCALE*larsScale;
    const offset = getInteractionOffset({type:'mette', x, y});
    ctx.save();
    ctx.translate(x + offset.x, y-baseH*CFG.SCALE*larsScale + nod + offset.y);
    if (rotation) ctx.rotate(rotation);
    ctx.scale(CFG.SCALE*larsScale, CFG.SCALE*larsScale);
    // Dark suit jacket
    ctx.fillStyle='#1a1a2e'; ctx.fillRect(-10,8,20,22);
    // Suit lapels (lighter)
    ctx.fillStyle='#2a2a4e';
    ctx.beginPath();
    ctx.moveTo(-8,8); ctx.lineTo(-2,18); ctx.lineTo(-8,18); ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(8,8); ctx.lineTo(2,18); ctx.lineTo(8,18); ctx.closePath();
    ctx.fill();
    // White shirt and blue tie
    ctx.fillStyle='#fff'; ctx.fillRect(-3,10,6,14);
    ctx.fillStyle='#2c4f9e'; ctx.fillRect(-1,12,2,10);
    // legs (dark suit pants) - very short stumpy legs
    ctx.fillStyle='#1a1a2e'; ctx.fillRect(-6,30,6,1); ctx.fillRect(0,30,6,1);
    // face (slightly rounder)
    ctx.fillStyle='#f4c59a'; ctx.fillRect(-9,-2,18,14);
    // Grey hair
    ctx.fillStyle='#bdbdbd';
    ctx.fillRect(-10,-6,20,4);
    ctx.fillRect(-9,-3,3,6); ctx.fillRect(6,-3,3,6);
    // Glasses
    ctx.fillStyle='#333';
    ctx.fillRect(-7,1,6,4); ctx.fillRect(1,1,6,4); // frames
    ctx.fillRect(-1,2,2,1); // bridge
    ctx.fillStyle='rgba(200,220,255,0.3)';
    ctx.fillRect(-6,2,4,2); ctx.fillRect(2,2,4,2); // lens glare
    // eyes behind glasses
    if (!(GL.mette.blinkUntil && nowMs() < GL.mette.blinkUntil)){
      ctx.fillStyle='#111'; ctx.fillRect(-5,3,2,1); ctx.fillRect(3,3,2,1);
    }
    // slight smile
    ctx.fillStyle='#c9a080'; ctx.fillRect(-3,8,6,1);
    // pipe in hand
    ctx.fillStyle='#1a1a2e'; ctx.fillRect(6,14,5,6); // sleeve
    ctx.fillStyle='#f4c59a'; ctx.fillRect(9,12,4,4); // hand
    ctx.fillStyle='#7b4a2f'; ctx.fillRect(11,7,6,4); // bowl
    ctx.fillStyle='#5a3a24'; ctx.fillRect(4,9,7,1); // stem
    ctx.fillStyle='#2b1b12'; ctx.fillRect(13,6,2,1); // rim
    // pipe smoke
    const smokeT = (nowMs() % 3800) / 3800;
    const smokeActive = smokeT < 0.35;
    if (smokeActive){
      for (let i=0; i<3; i++){
        const p = (smokeT/0.35 + i*0.45) % 1;
        const sx = 15 + p*9;
        const sy = 0 - p*16;
        const r = 6 + p*5;
        const fade = Math.max(0, 1 - p*0.6);
        ctx.fillStyle = `rgba(255,255,255,${0.55*fade})`;
        ctx.strokeStyle = `rgba(200,210,220,${0.4*fade})`;
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(sx, sy, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      }
    }
    ctx.restore();
  }
  function drawBear(x,y,alive=true){
    // Check if custom bear image is available
    if (GRAPHICS.drawOrFallback(ctx, 'bear', drawBearFallback, x, y, alive)) {
      return; // Custom image was drawn successfully
    }
    
    drawBearFallback(x, y, alive);
  }
  
  function drawBearFallback(x,y,alive=true){
    const offset = getInteractionOffset({type:'bear', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-30*CFG.SCALE + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // Body
    ctx.fillStyle='#ffffff'; 
    ctx.fillRect(-30,10,60,18); // main body
    ctx.fillRect(-26,26,10,6); ctx.fillRect(-6,26,10,6); ctx.fillRect(14,26,10,6); // paws
    
    // Head - bigger when angry, faces direction (only check in Greenland scene)
    const facing = (scene === 'greenland' && GL.bear) ? (GL.bear.facing || 1) : 1;
    
    if (scene === 'greenland' && GL.bear && GL.bear.angry && alive) {
      // BIGGER ANGRY HEAD - position based on facing direction
      ctx.fillStyle='#ffffff';
      const headX = facing > 0 ? 18 : -42; // flip head position
      ctx.fillRect(headX,-8,24,20);   // much bigger head
      
      // ANGRY BEAR - RED EYES, BIG OPEN MOUTH WITH TEETH
      ctx.fillStyle='#ff0000'; // Red angry eyes  
      if (facing > 0) {
        // Facing right
        ctx.fillRect(36,4,6,5); ctx.fillRect(28,2,4,3); // bigger red eyes
        
        // Much bigger open mouth (black)
        ctx.fillStyle='#000';
        ctx.fillRect(24,8,14,8); // much wider and taller mouth
        
        // More sharp white teeth
        ctx.fillStyle='#fff';
        // Top row of teeth
        ctx.fillRect(25,8,2,4); ctx.fillRect(28,8,2,4); ctx.fillRect(31,8,2,4); ctx.fillRect(34,8,2,4); 
        // Bottom row of teeth  
        ctx.fillRect(26,12,2,4); ctx.fillRect(29,12,2,4); ctx.fillRect(32,12,2,4); ctx.fillRect(35,12,2,4);
        
        // Extra angry eyebrows
        ctx.fillStyle='#000';
        ctx.fillRect(26,0,6,2); ctx.fillRect(36,0,6,2); // bigger angry eyebrows
      } else {
        // Facing left - mirror everything
        ctx.fillRect(-42,4,6,5); ctx.fillRect(-32,2,4,3); // bigger red eyes (flipped)
        
        // Much bigger open mouth (black)
        ctx.fillStyle='#000';
        ctx.fillRect(-38,8,14,8); // much wider and taller mouth (flipped)
        
        // More sharp white teeth
        ctx.fillStyle='#fff';
        // Top row of teeth (flipped)
        ctx.fillRect(-37,8,2,4); ctx.fillRect(-34,8,2,4); ctx.fillRect(-31,8,2,4); ctx.fillRect(-28,8,2,4); 
        // Bottom row of teeth (flipped)
        ctx.fillRect(-36,12,2,4); ctx.fillRect(-33,12,2,4); ctx.fillRect(-30,12,2,4); ctx.fillRect(-27,12,2,4);
        
        // Extra angry eyebrows (flipped)
        ctx.fillStyle='#000';
        ctx.fillRect(-42,0,6,2); ctx.fillRect(-32,0,6,2); // bigger angry eyebrows
      }
      
    } else {
      // Normal smaller head - position based on facing direction  
      ctx.fillStyle='#ffffff';
      const headX = facing > 0 ? 22 : -38;
      ctx.fillRect(headX,0,16,12);   // normal head
      // Normal bear eyes - position based on facing
      ctx.fillStyle='#222'; 
      if (facing > 0) {
        ctx.fillRect(34,6,4,4); ctx.fillRect(30,4,2,2);
        
        if (!alive){ 
          ctx.fillStyle='#d33'; 
          ctx.fillRect(30,4,2,2); ctx.fillRect(34,6,4,1); 
        }
      } else {
        // Facing left - flipped eyes
        ctx.fillRect(-38,6,4,4); ctx.fillRect(-32,4,2,2);
        
        if (!alive){ 
          ctx.fillStyle='#d33'; 
          ctx.fillRect(-32,4,2,2); ctx.fillRect(-38,6,4,1); 
        }
      }
    }
    
    ctx.restore();
  }
  function drawBearHP(bear){
    if (!bear.alive) return;
    const hp = Math.max(0, bear.hp||2), max=2;
    const y = bear.y - 40*CFG.SCALE; const x = bear.x - (max*10*CFG.SCALE)/2;
    for (let i=0;i<max;i++){
      ctx.fillStyle = i < hp ? '#e33' : 'rgba(255,255,255,.35)';
      ctx.fillRect(x + i*10*CFG.SCALE, y, 8*CFG.SCALE, 4*CFG.SCALE);
    }
  }
  function drawMine(x,y){
    // Mine entrance with wooden frame and equipment
    const offset = getInteractionOffset({type:'mine', x, y});
    ctx.save(); ctx.translate(x + offset.x, y + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);

    // Wooden mine frame (entrance arch)
    ctx.fillStyle = '#5a3d1a';
    ctx.fillRect(-28, -45, 6, 50); // Left post
    ctx.fillRect(22, -45, 6, 50);  // Right post
    ctx.fillRect(-32, -50, 64, 8); // Top beam

    // Support beams (diagonal)
    ctx.fillStyle = '#4a3015';
    ctx.fillRect(-26, -42, 4, 4);
    ctx.fillRect(22, -42, 4, 4);

    // Dark mine entrance (hole)
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(-22, -42, 44, 47);

    // Depth gradient inside
    const grad = ctx.createLinearGradient(0,-42,0,10);
    grad.addColorStop(0,'#1a1a1a'); grad.addColorStop(1,'#000000');
    ctx.fillStyle = grad;
    ctx.fillRect(-20, -40, 40, 45);

    // Track rails going into mine
    ctx.fillStyle = '#555';
    ctx.fillRect(-15, 0, 3, 8);
    ctx.fillRect(12, 0, 3, 8);
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(-18, 5, 36, 3);

    // Ladder visible inside
    ctx.fillStyle = '#6b4f2a';
    ctx.fillRect(-4, -38, 2, 40);
    ctx.fillRect(2, -38, 2, 40);
    ctx.fillStyle = '#8b6f3a';
    for (let i = -35; i < 0; i += 8) { ctx.fillRect(-4, i, 8, 2); }

    // Glowing minerals inside (animated)
    const pulse = 0.6 + 0.4 * Math.sin(Date.now() / 400);
    ctx.fillStyle = `rgba(100, 200, 255, ${pulse * 0.8})`;
    ctx.fillRect(-12, -25, 4, 4);
    ctx.fillStyle = `rgba(255, 200, 50, ${pulse * 0.7})`;
    ctx.fillRect(8, -18, 3, 3);
    ctx.fillStyle = `rgba(150, 255, 150, ${pulse * 0.6})`;
    ctx.fillRect(-8, -12, 3, 3);

    // Mining cart next to entrance
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(-50, -8, 20, 12);
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(-46, 6, 4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(-34, 6, 4, 0, Math.PI*2); ctx.fill();
    // Ore in cart
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(-48, -12, 16, 6);
    ctx.fillStyle = '#5ac8fa';
    ctx.fillRect(-45, -14, 4, 4);
    ctx.fillStyle = '#ffd700';
    ctx.fillRect(-40, -13, 3, 3);

    // Pickaxe leaning against frame
    ctx.fillStyle = '#6b4f2a';
    ctx.fillRect(30, -35, 3, 38);
    ctx.fillStyle = '#555';
    ctx.fillRect(26, -38, 12, 5);
    ctx.fillRect(24, -36, 5, 8);

    // Warning light (blinking)
    const blink = Math.floor(Date.now() / 500) % 2;
    ctx.fillStyle = blink ? '#ff4444' : '#880000';
    ctx.beginPath(); ctx.arc(-28, -52, 4, 0, Math.PI*2); ctx.fill();

    // Wooden sign: "MINE"
    const sx = 0, sy = -58;
    ctx.fillStyle = '#7b5a2b';
    ctx.fillRect(sx - 2, sy, 4, 10);
    ctx.fillStyle = '#9b7a3e';
    ctx.fillRect(sx - 30, sy - 18, 60, 18);
    ctx.strokeStyle = '#5a3d1a';
    ctx.lineWidth = 2;
    ctx.strokeRect(sx - 30, sy - 18, 60, 18);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('⛏️ MINE', sx, sy - 5);
    ctx.textAlign = 'left';

    ctx.restore();
  }

  function drawMineFlagUS(x, y) {
    // American flag on a pole at the mine
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(CFG.SCALE, CFG.SCALE);

    // Flag pole
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(-2, -60, 4, 80);

    // Flag waving animation
    const wave = Math.sin(Date.now() / 300) * 2;

    // Flag background (red stripes)
    ctx.fillStyle = '#bf0a30';
    ctx.fillRect(2, -58 + wave, 35, 24);

    // White stripes
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 7; i += 2) {
      ctx.fillRect(2, -58 + wave + i * 3.4, 35, 3.4);
    }

    // Blue canton
    ctx.fillStyle = '#002868';
    ctx.fillRect(2, -58 + wave, 14, 13);

    // Stars (simplified - just white dots)
    ctx.fillStyle = '#fff';
    for (let row = 0; row < 3; row++) {
      for (let col = 0; col < 3; col++) {
        ctx.fillRect(4 + col * 4, -56 + wave + row * 4, 2, 2);
      }
    }

    // Pole top (gold ball)
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(0, -62, 4, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawShopStall(shop){
    if (!shop) return;
    const off = getInteractionOffset(shop);
    ctx.save();
    ctx.translate(shop.x + (off?.x || 0), shop.y + (off?.y || 0));
    ctx.scale(CFG.SCALE, CFG.SCALE);
    const SCALE = 0.273;
    const anchorX = 483.5; // centre of main body in SVG coords
    const anchorY = 478.9; // bottom of legs
    ctx.scale(SCALE, SCALE);
    ctx.translate(-anchorX, -anchorY);

    function rect(fill, stroke, x, y, w, h, lineWidth){
      ctx.fillStyle = fill;
      ctx.fillRect(x, y, w, h);
      if (stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = lineWidth || 6; ctx.strokeRect(x, y, w, h); }
    }
    function poly(fill, stroke, pts, lineWidth){
      ctx.beginPath();
      pts.forEach(([px, py], i) => i ? ctx.lineTo(px, py) : ctx.moveTo(px, py));
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.fill();
      if (stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = lineWidth || 6; ctx.stroke(); }
    }

    // Legs
    rect('#c38d51', '#b08350', 572.5, 453, 18.6, 25.9, 6);
    rect('#c38d51', '#b08350', 373, 453, 18.6, 25.9, 6);

    // Main cabinet
    rect('#bb3d3d', '#cc5454', 370, 279, 227, 179.7, 6);

    // Horizontal bands (front panels)
    poly('#e54848', '#902222', [
      [571.5, 386.5], [399.5, 386.5], [399.5, 448.5], [571.5, 449.5]
    ], 6);
    poly('#e54848', '#902222', [
      [571.5, 293], [399.5, 293], [399.5, 355], [571.5, 356]
    ], 6);

    // Shelves
    poly('#f2d2d2', '#902222', [
      [567.5, 336], [399.5, 336], [373.5, 375], [594.5, 375.5]
    ], 6);
    poly('#f2d2d2', '#902222', [
      [571.5, 421.5], [399.5, 421.5], [373.5, 460.5], [594.5, 461]
    ], 6);

    // Shelf trim lines
    ctx.strokeStyle = '#bb3d3d';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(332.5, 289);
    ctx.lineTo(643.5, 289);
    ctx.moveTo(367.2, 462);
    ctx.lineTo(600, 462);
    ctx.stroke();

    // Roof
    poly('#bb3d3d', '#a43636', [
      [601, 241], [381, 241], [340, 284], [638.5, 284]
    ], 6);

    // Sign posts
    rect('#f2b470', '#c05454', 598, 140, 5.4, 122.8, 6);
    rect('#f2b470', '#c05454', 373, 140, 5.4, 122.8, 6);

    // Sign board
    rect('#f2b470', '#c05454', 364, 75, 245.7, 69, 6);
    ctx.fillStyle = '#5b2b2b';
    ctx.font = 'bold 42px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('BUTIK', 486.85, 123);
    ctx.textAlign = 'left';

    // Product layout (use original coordinates)
    const shelfItemY = 350;
    const layout = [
      { id: 'tan', x: 430, y: 320 },
      { id: 'shoes', x: 540, y: 320 },
      { id: 'maga', x: 420, y: 380 },
      { id: 'dynamite', x: 550, y: 380 }
    ];
    layout.forEach(slot => {
      const item = SHOP_ITEMS.find(it => it.id === slot.id);
      if (!item) return;
      ctx.save();
      const sy = slot.y || shelfItemY;
      ctx.translate(slot.x, sy);
      ctx.scale(2.4, 2.4);
      ctx.translate(-19, -16);
      drawInvIcon(ctx, slot.id);
      ctx.restore();

      const tagY = (slot.y || shelfItemY) + 48;
      const tagW = 64;
      const tagH = 20;
      ctx.fillStyle = '#fdf0c4';
      ctx.fillRect(slot.x - tagW/2, tagY, tagW, tagH);
      ctx.strokeStyle = '#b08350';
      ctx.lineWidth = 4;
      ctx.strokeRect(slot.x - tagW/2, tagY, tagW, tagH);
    ctx.fillStyle = '#5b2b2b';
    ctx.font = 'bold 14px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`${item.price} g`, slot.x, tagY + 14);
      ctx.textAlign = 'left';
    });

    ctx.restore();
  }
  // y parameter is pole base (ground contact)
  function drawFlag(x,y){
    const poleH = 40*CFG.SCALE; const flagW = 36*CFG.SCALE; const flagH = 24*CFG.SCALE;
    // pole
    ctx.fillStyle='#666'; ctx.fillRect(x-2, y-poleH, 4, poleH);
    // flag top anchored near pole top
    const topY = y - poleH + 4*CFG.SCALE;
    const fx = x + 2;
    // stripes
    const stripes = 13; const stripeH = flagH/stripes;
    for (let i=0;i<stripes;i++){
      ctx.fillStyle = (i%2===0) ? '#bf0a30' : '#fff';
      ctx.fillRect(fx, topY + i*stripeH, flagW, stripeH);
    }
    // canton
    const cantonW = 14*CFG.SCALE; const cantonH = stripeH*7;
    ctx.fillStyle = '#002868';
    ctx.fillRect(fx, topY, cantonW, cantonH);
    // tiny stars
    ctx.fillStyle='#fff';
    for (let r=0;r<5;r++){
      for (let c=0;c<6;c++){
        const sx = fx + 2 + c* (cantonW/6);
        const sy = topY + 2 + r* (cantonH/5);
        ctx.fillRect(sx, sy, 1, 1);
      }
    }
  }
  function drawPhone(x,y){
    const offset = getInteractionOffset({type:'phone', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-34*CFG.SCALE + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#111'; ctx.fillRect(-8,0,16,28);
    ctx.fillStyle='#0af'; ctx.fillRect(-6,4,12,18);
    ctx.restore();
  }
  function drawPickup(it){
    const bob = Math.sin(nowMs()/600 + it.x*0.01)*4*CFG.SCALE;
    const px = it.x, py = it.y-26*CFG.SCALE + bob;
    // Try custom sprites based on item id
    if (it.id==='tan' && GRAPHICS.drawOrFallback(ctx, 'tan_bottle', () => {}, px, py)) return;
    if (it.id==='shoes' && GRAPHICS.drawOrFallback(ctx, 'golden_shoes', () => {}, px, py)) return;
    if (it.id==='maga' && GRAPHICS.drawOrFallback(ctx, 'maga_cap', () => {}, px, py)) return;
    if (it.id==='dynamite' && GRAPHICS.drawOrFallback(ctx, 'dynamite', () => {}, px, py)) return;
    // Fallback vector icons
    ctx.save(); ctx.translate(px, py); ctx.scale(CFG.SCALE, CFG.SCALE);
    if (it.id==='tan'){ ctx.fillStyle='#8b5e3c'; ctx.fillRect(-8,8,16,10); ctx.fillStyle='#ccc'; ctx.fillRect(-6,4,12,6); }
    else if (it.id==='shoes'){
      ctx.fillStyle='#f5d36a'; ctx.fillRect(-14,4,28,12);
      ctx.fillStyle='#b88a1d'; ctx.fillRect(-14,14,28,4);
      ctx.fillStyle='#fff'; ctx.fillRect(-14,18,28,2);
      ctx.fillStyle='#ff3b2f'; ctx.fillRect(0,6,12,3);
      ctx.fillStyle='#1e4fbf'; ctx.fillRect(4,-2,12,6);
      ctx.fillStyle='#ffd700'; ctx.fillRect(6,0,3,2); ctx.fillRect(11,0,3,2); ctx.fillRect(8,2,3,2);
    }
    else if (it.id==='maga'){ ctx.fillStyle='#c22'; ctx.fillRect(-12,10,24,8); ctx.fillRect(-10,4,20,6); }
    else if (it.id==='dynamite'){ 
      // Two red sticks with black bands (match inventory icon)
      ctx.fillStyle='#d32f2f'; ctx.fillRect(-8,0,6,16); ctx.fillRect(2,0,6,16);
      ctx.fillStyle='#333'; ctx.fillRect(-8,4,6,2); ctx.fillRect(2,4,6,2);
      ctx.fillStyle='#333'; ctx.fillRect(-8,10,6,2); ctx.fillRect(2,10,6,2);
    }
    ctx.restore();
  }
  function drawGoldBar(goldBar){
    // gentle float/bob like pickups
    const bob = Math.sin(nowMs()/400 + goldBar.x*0.01)*3*CFG.SCALE;
    ctx.save(); ctx.translate(goldBar.x, goldBar.y-20*CFG.SCALE + bob); ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // 3D Gold bar design (no text on bar itself)
    // Bottom/side shadow (darker gold)
    ctx.fillStyle='#cc9900';
    ctx.fillRect(-8, -2, 16, 8); // bottom part
    ctx.fillRect(6, -4, 2, 6);   // right side edge
    
    // Main body (bright gold)
    ctx.fillStyle='#ffd700';
    ctx.fillRect(-8, -4, 14, 6);
    
    // Top surface highlight (lighter gold)
    ctx.fillStyle='#ffed4e';
    ctx.fillRect(-8, -4, 14, 3); // top surface
    ctx.fillRect(-8, -6, 2, 2);  // left edge highlight
    
    ctx.restore();
  }
  function drawRig(x,y){
    // Oil rig silhouette aligned to ground (no shadow)
    ctx.save(); ctx.translate(x, y-78*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // base
    ctx.fillStyle='#111'; ctx.fillRect(-36,70,72,8); ctx.fillRect(-30,62,60,6);
    // tower legs (triangular)
    ctx.fillStyle='#222';
    ctx.fillRect(-22,10,4,52); ctx.fillRect(18,10,4,52);
    // cross braces
    ctx.strokeStyle='#222'; ctx.lineWidth=4; ctx.beginPath();
    ctx.moveTo(-22,12); ctx.lineTo(18,36); ctx.moveTo(-22,36); ctx.lineTo(18,60);
    ctx.moveTo(18,12); ctx.lineTo(-22,36); ctx.moveTo(18,36); ctx.lineTo(-22,60);
    ctx.stroke();
    // central column
    ctx.fillStyle='#1a1a1a'; ctx.fillRect(-3,4,6,62);
    // top cap
    ctx.fillStyle='#1a1a1a'; ctx.fillRect(-16,-6,32,12); ctx.fillRect(-20,6,40,4);
    ctx.restore();
  }
  function drawHeli(x,y,spin=0.35){
    // Check if custom helicopter image is available
    if (GRAPHICS.drawOrFallback(ctx, 'helicopter', drawHeliFallback, x, y, spin)) {
      return; // Custom image was drawn successfully
    }
    
    drawHeliFallback(x, y, spin);
  }
  
  function drawHeliFallback(x,y,spin=0.35){
    ctx.save(); ctx.translate(x, y); ctx.scale(CFG.SCALE, CFG.SCALE);
    // krop
    ctx.fillStyle='#2c3e50'; ctx.fillRect(-40,-10,100,28); // body
    // cockpit
    ctx.fillStyle='#86d0ff'; ctx.fillRect(46,-6,10,16);
    // rotor
    ctx.fillStyle='#333'; ctx.fillRect(6,-18,4,8); ctx.fillRect(-40,-22,140,4);
    // subtle rotor blur
    const t = nowMs();
    const alpha = Math.min(1, Math.max(0, spin));
    ctx.globalAlpha = 0.18 * alpha; ctx.fillStyle = '#000';
    const blurW = 160 + Math.sin(t/80)*8; ctx.fillRect(-blurW/2, -23, blurW, 6);
    ctx.globalAlpha = 1;
    // ben
    ctx.fillStyle='#333'; ctx.fillRect(-30,18,60,4); ctx.fillRect(20,18,40,4);
    ctx.restore();
  }
  function playEntryHeli(line, stopX, stopY){
    entryHeli.active = true; entryHeli.line = line || '';
    entryHeli.vertical = true;
    // Fixed stop X like Greenland, descend from above screen
    entryHeli.targetX = (typeof stopX === 'number') ? stopX : 160*CFG.SCALE;
    entryHeli.x = entryHeli.targetX;
    entryHeli.targetY = (typeof stopY === 'number') ? stopY : (H - world.floor) - 18*CFG.SCALE;
    entryHeli.startY = Math.min(-200*CFG.SCALE, entryHeli.targetY - 240*CFG.SCALE);
    entryHeli.y = entryHeli.startY;
    entryHeli.start = nowMs(); entryHeli.dur = 1600;
  }
  // Intro: land helicopter from offscreen and have Trump step out
  function scheduleHeliIntro(line){
    // Use the same vertical entry animation as other scenes
    playEntryHeli(line || 'Perfect landing! Helicopter takes us anywhere.', 160*CFG.SCALE);
  }
  function drawBerg(cx,cy,w,h){ ctx.beginPath(); ctx.moveTo(cx-w/2, cy+h/2); ctx.lineTo(cx, cy-h/2); ctx.lineTo(cx+w/2, cy+h/2); ctx.closePath(); ctx.fill(); }
  
  function drawGlacier(x, y, w, h, blown = false) {
    if (blown) return; // Don't draw if blown up
    
    const offset = getInteractionOffset({type:'glacier', x, y});
    ctx.save(); 
    ctx.translate(x + offset.x, y + offset.y); 
    ctx.scale(CFG.SCALE, CFG.SCALE);
    // Optional glacier sprite override
    if (GRAPHICS.imageReady('glacier')) {
      const img = GRAPHICS.images.get('glacier');
      const gw = w, gh = h;
      ctx.drawImage(img, -gw/2, -gh/2, gw, gh);
      ctx.restore();
      return;
    }
    
    // Large glacier - more detailed than small bergs
    ctx.fillStyle='#e8f4f8';
    ctx.beginPath();
    ctx.moveTo(-w/2, h/2);
    ctx.lineTo(-w/3, -h/2);
    ctx.lineTo(0, -h/2 - 20);
    ctx.lineTo(w/3, -h/2);
    ctx.lineTo(w/2, h/2);
    ctx.closePath();
    ctx.fill();
    
    // Shading/details
    ctx.fillStyle='#d0e8f0';
    ctx.beginPath();
    ctx.moveTo(-w/4, 0);
    ctx.lineTo(-w/6, -h/3);
    ctx.lineTo(w/6, -h/3);
    ctx.lineTo(w/4, 0);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  }

  // Oval Office
  function drawOvalBackdrop(){
    // Wallpapered wall
    ctx.fillStyle='#f4efe3'; ctx.fillRect(0,0,W,H);
    // subtle damask-like pattern
    ctx.save(); ctx.globalAlpha=0.06; ctx.fillStyle='#bfb7a6';
    for (let y=40*CFG.SCALE; y<H-80*CFG.SCALE; y+=30*CFG.SCALE){
      for (let x=40*CFG.SCALE; x<W; x+=50*CFG.SCALE){
        ctx.beginPath(); ctx.ellipse(x, y, 18*CFG.SCALE, 8*CFG.SCALE, 0, 0, Math.PI*2); ctx.fill();
      }
    }
    ctx.restore();
    
    // Mantle and shelf
    const shelfY = H - world.floor - 44*CFG.SCALE;
    const shelfW = W*0.62, shelfX = W/2 - shelfW/2;
    // simple mantle block
    ctx.fillStyle='#e9e4d8'; ctx.fillRect(shelfX-30*CFG.SCALE, shelfY-30*CFG.SCALE, shelfW+60*CFG.SCALE, 26*CFG.SCALE);
    ctx.strokeStyle='#d2cbbd'; ctx.lineWidth=2; ctx.strokeRect(shelfX-30*CFG.SCALE, shelfY-30*CFG.SCALE, shelfW+60*CFG.SCALE, 26*CFG.SCALE);
    // shelf top
    ctx.fillStyle='#d9d2c4'; ctx.fillRect(shelfX, shelfY, shelfW, 10*CFG.SCALE);
    ctx.fillStyle='#cfc7b6'; ctx.fillRect(shelfX, shelfY+10*CFG.SCALE, shelfW, 4*CFG.SCALE);

    // Two floating shelves left and right of TV (below TV center)
    const tvW = 110*CFG.SCALE, tvH = 196*CFG.SCALE; // keep in sync with drawOvalWallScreen
    const tvCx = W/2, tvCy = 115*CFG.SCALE + tvH/2 + 150;
    const shelfY2 = tvCy + tvH*0.15; // a little lower than TV center
    const gap = 40*CFG.SCALE; // gap around TV
    const leftW = tvCx - tvW/2 - gap - 60*CFG.SCALE; // left shelf width
    const rightW = W - (tvCx + tvW/2 + gap) - 60*CFG.SCALE; // right shelf width
    const leftX = 40*CFG.SCALE; const rightX = tvCx + tvW/2 + gap;
    // draw shelves
    drawFloatingShelf(leftX, shelfY2, leftW);
    drawFloatingShelf(rightX, shelfY2, rightW);
    // base statues: 3 per shelf
    drawShelfStatuesRow(leftX, shelfY2, leftW, 3);
    drawShelfStatuesRow(rightX, shelfY2, rightW, 3);
    // extra stolen statues added alternating left/right
    drawLootStatues(leftX, rightX, shelfY2, leftW, rightW);
    
    // carpet (keep)
    ctx.fillStyle='#d4c6a6'; ctx.fillRect(0,H-world.floor,W,world.floor);
    ctx.save(); ctx.globalAlpha=0.18; ctx.fillStyle='#000';
    ctx.beginPath(); ctx.ellipse(W/2, H - world.floor + 60*CFG.SCALE, 200*CFG.SCALE, 40*CFG.SCALE, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    // subtle seal
    const cy = H - world.floor + 56*CFG.SCALE, cx = W/2;
    ctx.save(); ctx.translate(cx, cy); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.globalAlpha = 0.22; ctx.fillStyle = '#1e3a5f'; ctx.beginPath(); ctx.arc(0,0,38,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.9; ctx.strokeStyle='#f6e27d'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,40,0,Math.PI*2); ctx.stroke();
    ctx.restore();
    // (Desk body drawn later after Trump for proper layering)

    // Wall screen (TV) behind desk
    drawOvalWallScreen();
  }

  function drawFloatingShelf(x, y, w){
    ctx.fillStyle='#d9d2c4'; ctx.fillRect(x, y, w, 8*CFG.SCALE);
    ctx.fillStyle='#cfc7b6'; ctx.fillRect(x, y+8*CFG.SCALE, w, 3*CFG.SCALE);
  }
  function drawShelfStatuesRow(x, y, w, count){
    const spacing = w/(count+1);
    for (let i=1;i<=count;i++){
      const sx = Math.round(x + spacing*i);
      const variant = (i % 3) + 1; // stable pattern 1..3
      drawOneGoldStatue(sx, y, variant);
    }
  }
  function drawOneGoldStatue(x, y, variant){
    const sx = Math.round(x);
    ctx.save();
    ctx.fillStyle='#8a6b2f'; ctx.fillRect(sx-10*CFG.SCALE, y-16*CFG.SCALE, 20*CFG.SCALE, 16*CFG.SCALE);
    ctx.fillStyle='#d4af37';
    const v = variant || 1;
    if (v===1){ ctx.fillRect(sx-3*CFG.SCALE, y-40*CFG.SCALE, 6*CFG.SCALE, 24*CFG.SCALE); ctx.fillRect(sx-12*CFG.SCALE, y-28*CFG.SCALE, 24*CFG.SCALE, 8*CFG.SCALE); }
    else if (v===2){ ctx.fillRect(sx-2*CFG.SCALE, y-42*CFG.SCALE, 4*CFG.SCALE, 26*CFG.SCALE); ctx.fillRect(sx-10*CFG.SCALE, y-34*CFG.SCALE, 20*CFG.SCALE, 6*CFG.SCALE); }
    else { ctx.fillRect(sx-4*CFG.SCALE, y-36*CFG.SCALE, 8*CFG.SCALE, 20*CFG.SCALE); ctx.fillRect(sx-2*CFG.SCALE, y-44*CFG.SCALE, 4*CFG.SCALE, 8*CFG.SCALE); }
    ctx.restore();
  }
  function drawLootStatues(leftX, rightX, y, leftW, rightW){
    if (!OV.shelfLoot || !OV.shelfLoot.length) return;
    // place extra starting from center outward: alternate shelves
    let leftCount = 0, rightCount = 0;
    const base = 3; // already placed per shelf
    for (let i=0;i<OV.shelfLoot.length;i++){
      const placeRight = (i%2===0);
      if (placeRight){
        const spacing = rightW/(base+2+rightCount);
        const sx = Math.round(rightX + spacing*(base+rightCount+1));
        drawOneGoldStatue(sx, y, (OV.shelfLoot[i] && OV.shelfLoot[i].variant) || 1);
        rightCount++;
      } else {
        const spacing = leftW/(base+2+leftCount);
        const sx = Math.round(leftX + spacing*(base+leftCount+1));
        drawOneGoldStatue(sx, y, (OV.shelfLoot[i] && OV.shelfLoot[i].variant) || 1);
        leftCount++;
      }
    }
  }

  // Draws wall-mounted TV with Breaking News (top) and MAGA Dashboard (bottom)
  function drawOvalWallScreen(){
    const TV = { W: 200*CFG.SCALE, H: 280*CFG.SCALE, PAD: 8*CFG.SCALE }; // Larger TV for readability
    const tvW = TV.W, tvH = TV.H;
    const tvRaise = 100*CFG.SCALE;
    const cx = W/2, cy = 100*CFG.SCALE + tvH/2 + 100 - tvRaise; // Raised to avoid desk overlap
    const d = OV.decisions;

    ctx.save();
    // TV frame
    ctx.fillStyle = '#111'; ctx.fillRect(cx - tvW/2 - 6, cy - tvH/2 - 6, tvW+12, tvH+12);
    ctx.fillStyle = '#1a1a1a'; ctx.fillRect(cx - tvW/2, cy - tvH/2, tvW, tvH);

    const pad = TV.PAD;
    const innerW = tvW - 2*pad;
    const innerH = tvH - 2*pad;
    const topHalf = innerH * 0.55; // Breaking news section
    const bottomHalf = innerH * 0.45; // Dashboard section

    // ========== TOP HALF: BREAKING NEWS ==========
    const newsY = cy - tvH/2 + pad;

    // News background - dark blue like CNN
    ctx.fillStyle = '#0a1628';
    ctx.fillRect(cx - innerW/2, newsY, innerW, topHalf);

    // Red "BREAKING NEWS" banner at top
    ctx.fillStyle = '#cc0000';
    ctx.fillRect(cx - innerW/2, newsY, innerW, 20*CFG.SCALE);
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${11*CFG.SCALE}px system-ui`;
    ctx.textAlign = 'center';
    ctx.fillText('BREAKING NEWS', cx, newsY + 15*CFG.SCALE);

    // News content
    const newsContentY = newsY + 24*CFG.SCALE;
    if (d && d.breakingNews && nowMs() < d.breakingNews.until) {
      // Show breaking news
      const news = d.breakingNews;
      ctx.fillStyle = news.isGood ? '#2e7d32' : '#c62828';
      ctx.fillRect(cx - innerW/2 + 4, newsContentY, innerW - 8, topHalf - 28*CFG.SCALE);

      // News text (word wrap) - larger font
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${10*CFG.SCALE}px system-ui`;
      const words = news.text.split(' ');
      let line = '';
      let lineY = newsContentY + 18*CFG.SCALE;
      const maxWidth = innerW - 20;
      for (const word of words) {
        const testLine = line + word + ' ';
        if (ctx.measureText(testLine).width > maxWidth && line) {
          ctx.fillText(line.trim(), cx, lineY);
          line = word + ' ';
          lineY += 14*CFG.SCALE;
        } else {
          line = testLine;
        }
      }
      if (line) ctx.fillText(line.trim(), cx, lineY);
    } else {
      // Idle state - waiting for news
      ctx.fillStyle = '#333';
      ctx.fillRect(cx - innerW/2 + 4, newsContentY, innerW - 8, topHalf - 28*CFG.SCALE);
      ctx.fillStyle = '#666';
      ctx.font = `${10*CFG.SCALE}px system-ui`;
      ctx.fillText('Awaiting presidential', cx, newsContentY + 28*CFG.SCALE);
      ctx.fillText('decision...', cx, newsContentY + 44*CFG.SCALE);
    }

    // ========== BOTTOM HALF: MAGA DASHBOARD ==========
    const dashY = cy - tvH/2 + pad + topHalf + 4;

    // Dashboard background
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(cx - innerW/2, dashY, innerW, bottomHalf - 4);

    // MAGA APPROVAL RATING
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${6*CFG.SCALE}px system-ui`;
    ctx.fillText('MAGA APPROVAL', cx, dashY + 10*CFG.SCALE);

    // Approval bar
    const barX = cx - innerW/2 + 8;
    const barY = dashY + 14*CFG.SCALE;
    const barW = innerW - 16;
    const barH = 10*CFG.SCALE;
    const approval = d ? (d.approvalRating || 0) : 0;

    // Bar background
    ctx.fillStyle = '#333';
    ctx.fillRect(barX, barY, barW, barH);

    // Bar fill with gradient based on approval
    let barColor = '#ff6b6b'; // Low = red
    if (approval >= 70) barColor = '#4caf50'; // High = green
    else if (approval >= 40) barColor = '#ffc107'; // Medium = yellow

    ctx.fillStyle = barColor;
    ctx.fillRect(barX, barY, barW * (approval / 100), barH);

    // Percentage text
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${7*CFG.SCALE}px system-ui`;
    ctx.fillText(`${Math.round(approval)}%`, cx, barY + 8*CFG.SCALE);

    // DECISIONS PROGRESS
    ctx.font = `bold ${6*CFG.SCALE}px system-ui`;
    ctx.fillText('DECISIONS', cx, dashY + 34*CFG.SCALE);

    // Guest result icons
    const correct = d ? (d.correctAnswers || 0) : 0;
    const results = d ? (d.guestResults || []) : [];
    const iconY = dashY + 40*CFG.SCALE;
    const iconSpacing = 20*CFG.SCALE;
    const startX = cx - iconSpacing;

    for (let i = 0; i < 3; i++) {
      const iconX = startX + i * iconSpacing;
      if (i < results.length) {
        // Answered - show checkmark or X
        if (results[i].correct) {
          ctx.fillStyle = '#4caf50';
          ctx.fillRect(iconX - 6*CFG.SCALE, iconY, 12*CFG.SCALE, 12*CFG.SCALE);
          ctx.fillStyle = '#fff';
          ctx.font = `bold ${8*CFG.SCALE}px system-ui`;
          ctx.fillText('✓', iconX, iconY + 10*CFG.SCALE);
        } else {
          ctx.fillStyle = '#f44336';
          ctx.fillRect(iconX - 6*CFG.SCALE, iconY, 12*CFG.SCALE, 12*CFG.SCALE);
          ctx.fillStyle = '#fff';
          ctx.font = `bold ${8*CFG.SCALE}px system-ui`;
          ctx.fillText('✗', iconX, iconY + 10*CFG.SCALE);
        }
      } else {
        // Not yet answered - show empty box
        ctx.fillStyle = '#444';
        ctx.fillRect(iconX - 6*CFG.SCALE, iconY, 12*CFG.SCALE, 12*CFG.SCALE);
        ctx.fillStyle = '#666';
        ctx.font = `${7*CFG.SCALE}px system-ui`;
        ctx.fillText('?', iconX, iconY + 9*CFG.SCALE);
      }
    }

    // Score text
    ctx.fillStyle = '#aaa';
    ctx.font = `${5*CFG.SCALE}px system-ui`;
    ctx.fillText(`${correct}/3 correct`, cx, iconY + 20*CFG.SCALE);

    ctx.textAlign = 'left';
    ctx.restore();
  }

  // Draw desk body (panel/top/legs) and on‑desk buttons so Trump appears behind it
  function drawOvalDesk(){
    const y = H - world.floor + 30*CFG.SCALE;
    const deskX = 420*CFG.SCALE, deskW = 340*CFG.SCALE;
    // body and top
    ctx.fillStyle='#7a4a22'; ctx.fillRect(deskX, y-40*CFG.SCALE, deskW, 80*CFG.SCALE);
    ctx.fillStyle='#8a5a2a'; ctx.fillRect(deskX-8, y-44*CFG.SCALE, deskW+16, 8*CFG.SCALE);
    // legs
    ctx.fillStyle='#6b3e18';
    ctx.fillRect(deskX+12, y+40*CFG.SCALE, 16*CFG.SCALE, 20*CFG.SCALE);
    ctx.fillRect(deskX+deskW-28*CFG.SCALE, y+40*CFG.SCALE, 16*CFG.SCALE, 20*CFG.SCALE);
    // drawer seams + handles
    ctx.strokeStyle='#5e3415'; ctx.lineWidth=2; ctx.beginPath();
    ctx.moveTo(deskX+deskW*0.33, y-8*CFG.SCALE); ctx.lineTo(deskX+deskW*0.33, y+36*CFG.SCALE);
    ctx.moveTo(deskX+deskW*0.66, y-8*CFG.SCALE); ctx.lineTo(deskX+deskW*0.66, y+36*CFG.SCALE);
    ctx.stroke();
    ctx.fillStyle='#d4af37'; ctx.fillRect(deskX+deskW*0.33-4, y+8*CFG.SCALE, 8, 4); ctx.fillRect(deskX+deskW*0.66-4, y+8*CFG.SCALE, 8, 4);
    // buttons sitting ON the slim top board (y-44..y-36)
    OV.buttons.forEach((b,i)=>{
      const topY = y-44*CFG.SCALE; // top board upper edge
      ctx.save(); ctx.translate(b.x, topY);

      if (b.isDoomsday) {
        // === BIG DOOMSDAY BUTTON WITH GLASS DOME ===
        const baseW = b.w;
        const baseH = 12*CFG.SCALE;
        const buttonRadius = 22*CFG.SCALE;
        const domeRadius = 30*CFG.SCALE;
        const pressOffset = b.pressed ? 4*CFG.SCALE : 0;

        // Black/yellow hazard base plate
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(-baseW/2 - 8*CFG.SCALE, -baseH/2, baseW + 16*CFG.SCALE, baseH);
        // Yellow hazard stripes
        ctx.fillStyle = '#f4d03f';
        for (let s = 0; s < 6; s++) {
          ctx.fillRect(-baseW/2 - 6*CFG.SCALE + s*12*CFG.SCALE, -baseH/2 + 2*CFG.SCALE, 6*CFG.SCALE, baseH - 4*CFG.SCALE);
        }

        // Metal ring base for dome
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(0, -baseH/2, domeRadius + 4*CFG.SCALE, Math.PI, 0);
        ctx.fill();
        ctx.fillStyle = '#888';
        ctx.beginPath();
        ctx.arc(0, -baseH/2, domeRadius + 2*CFG.SCALE, Math.PI, 0);
        ctx.fill();

        // Glass dome (transparent)
        ctx.fillStyle = 'rgba(200, 220, 255, 0.25)';
        ctx.beginPath();
        ctx.arc(0, -baseH/2, domeRadius, Math.PI, 0);
        ctx.fill();
        // Dome highlight (reflection)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2*CFG.SCALE;
        ctx.beginPath();
        ctx.arc(-8*CFG.SCALE, -baseH/2 - 12*CFG.SCALE, 12*CFG.SCALE, Math.PI * 0.8, Math.PI * 1.3);
        ctx.stroke();

        // THE BIG RED BUTTON inside dome (clipped so bottom looks flat like it's behind the desk)
        ctx.save();
        ctx.beginPath();
        ctx.rect(-200*CFG.SCALE, -200*CFG.SCALE, 400*CFG.SCALE, 200*CFG.SCALE); // clip at y=0
        ctx.clip();

        // Button shadow/base
        ctx.fillStyle = '#8b0000';
        ctx.beginPath();
        ctx.arc(0, -baseH/2 - 4*CFG.SCALE + pressOffset, buttonRadius, 0, Math.PI * 2);
        ctx.fill();

        // Button top surface (pulsing glow when not pressed)
        const pulse = b.pressed ? 1 : (0.85 + 0.15 * Math.sin(nowMs() / 200));
        ctx.fillStyle = b.pressed ? '#a00' : `rgb(${Math.floor(200 * pulse)}, ${Math.floor(30 * pulse)}, ${Math.floor(30 * pulse)})`;
        ctx.beginPath();
        ctx.arc(0, -baseH/2 - 8*CFG.SCALE + pressOffset, buttonRadius - 3*CFG.SCALE, 0, Math.PI * 2);
        ctx.fill();

        // Button highlight
        ctx.fillStyle = 'rgba(255, 150, 150, 0.4)';
        ctx.beginPath();
        ctx.arc(-5*CFG.SCALE, -baseH/2 - 14*CFG.SCALE + pressOffset, 8*CFG.SCALE, 0, Math.PI * 2);
        ctx.fill();

        // Outer glow effect (pulsing)
        if (!b.pressed) {
          ctx.globalAlpha = 0.3 + 0.2 * Math.sin(nowMs() / 300);
          ctx.fillStyle = '#ff0000';
          ctx.beginPath();
          ctx.arc(0, -baseH/2 - 6*CFG.SCALE, buttonRadius + 6*CFG.SCALE, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        ctx.restore();

        // "DO NOT PRESS" label on base
        ctx.fillStyle = '#ff0';
        ctx.font = `bold ${5*CFG.SCALE}px system-ui`;
        ctx.textAlign = 'center';
        ctx.fillText('DO NOT PRESS', 0, baseH/2 - 2*CFG.SCALE);
        ctx.textAlign = 'left';

      } else {
        // === NORMAL JA/NEJ BUTTONS ===
        // base (mount) sits inside the 8px top thickness
        const baseH = 4; ctx.fillStyle='#5a4632'; ctx.fillRect(-b.w/2, 0, b.w, baseH);

        // cap rises above the top surface - adjust position if pressed
        const pressOffset = b.pressed ? 3 : 0;
        const capHeight = b.pressed ? b.h - 2 : b.h;
        ctx.fillStyle = b.pressed ? darkenColor(b.color) : b.color;
        ctx.fillRect(-b.w/2+2, -capHeight-2+pressOffset, b.w-4, capHeight);

        // highlight on cap - dimmer when pressed
        ctx.globalAlpha = b.pressed ? 0.1 : 0.25;
        ctx.fillStyle='#fff';
        ctx.fillRect(-b.w/2+4, -capHeight+pressOffset, b.w-8, 2);
        ctx.globalAlpha = 1;

        // Draw label on button
        if (b.label) {
          ctx.fillStyle = '#fff';
          ctx.font = `bold ${8*CFG.SCALE}px system-ui`;
          ctx.textAlign = 'center';
          ctx.fillText(b.label, 0, -capHeight/2 + 3 + pressOffset);
          ctx.textAlign = 'left';
        }
      }
      ctx.restore();
    });

    // Draw answer feedback if active
    const d = OV.decisions;
    if (d && d.answerFeedback && nowMs() < d.answerFeedback.until) {
      const fb = d.answerFeedback;
      ctx.save();
      ctx.font = `bold ${14*CFG.SCALE}px system-ui`;
      ctx.textAlign = 'center';
      ctx.fillStyle = fb.correct ? '#2e7d32' : '#c62828';
      ctx.fillText(fb.text, deskX + deskW/2, y - 70*CFG.SCALE);
      ctx.textAlign = 'left';
      ctx.restore();
    }

    // Draw score indicator
    if (d && d.active && d.correctAnswers > 0) {
      ctx.save();
      ctx.font = `bold ${12*CFG.SCALE}px system-ui`;
      ctx.fillStyle = '#2e7d32';
      ctx.fillText('Korrekt: ' + d.correctAnswers + '/3', deskX + 10, y - 60*CFG.SCALE);
      ctx.restore();
    }

  }

  // Draw guest NPC for Presidential Decisions
  // Draw guest NPC in Trump-like blocky style with walking animation
  function drawOvalGuest(x, y) {
    const d = OV.decisions;
    if (!d || !OV.guest.visible) return;

    const guestIdx = d.guestOrder[d.currentGuestIndex];
    if (guestIdx === undefined || guestIdx < 0) return;
    const guest = OVAL_GUESTS[guestIdx];
    if (!guest) return;

    const app = guest.appearance;
    const isWalking = d.phase === 'guest_entering' || d.phase === 'guest_leaving';

    // Nod animation like Trump
    const nod = Math.sin(nowMs()/1100 + Math.random()*6.28) * 0.6*CFG.SCALE;

    ctx.save();
    // Bigger head for JD Vance
    const headScale = app.bigHead ? 1.15 : 1;
    ctx.translate(x, y - 44*CFG.SCALE + nod);
    ctx.scale(CFG.SCALE, CFG.SCALE);

    // Walking animation for legs
    const walkCycle = Math.floor(nowMs() / 200);
    const legColor = app.isShaman ? '#2a2a2a' : '#1a1a1a';

    if (isWalking && walkCycle % 2 === 0) {
      ctx.fillStyle = legColor;
      ctx.fillRect(-10, 34, 9, 10);
      ctx.fillRect(2, 36, 9, 8);
    } else if (isWalking) {
      ctx.fillStyle = legColor;
      ctx.fillRect(-10, 36, 9, 8);
      ctx.fillRect(2, 34, 9, 10);
    } else {
      ctx.fillStyle = legColor;
      ctx.fillRect(-10, 34, 9, 10);
      ctx.fillRect(2, 34, 9, 10);
    }

    // === SPECIAL: QAnon Shaman ===
    if (app.isShaman) {
      // Bare chest with fur vest
      ctx.fillStyle = '#e8c4a0'; // Skin tone
      ctx.fillRect(-12, 6, 24, 26);
      // Fur vest
      ctx.fillStyle = '#8b7355'; // Brown fur
      ctx.fillRect(-12, 6, 6, 26);
      ctx.fillRect(6, 6, 6, 26);
      // Fur texture on vest
      ctx.fillStyle = '#a08060';
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(-11, 8 + i*5, 4, 2);
        ctx.fillRect(7, 10 + i*5, 4, 2);
      }
      // Tattoos on chest (simple lines)
      ctx.fillStyle = '#334455';
      ctx.fillRect(-4, 12, 8, 1);
      ctx.fillRect(-2, 16, 4, 1);

      // Head with face paint
      ctx.fillStyle = '#e8c4a0';
      ctx.fillRect(-9, -2, 18, 12);
      // Red face paint (left side)
      ctx.fillStyle = '#cc0000';
      ctx.fillRect(-9, -2, 6, 12);
      // Blue face paint (right side)
      ctx.fillStyle = '#002868';
      ctx.fillRect(3, -2, 6, 12);
      // White stripe down middle
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-3, -2, 6, 12);

      // Eyes (on face paint)
      const blinkNow = Math.random() < 0.02;
      if (!blinkNow) {
        ctx.fillStyle = '#111';
        ctx.fillRect(-6, 2, 2, 2);
        ctx.fillRect(4, 2, 2, 2);
      } else {
        ctx.fillStyle = '#111';
        ctx.fillRect(-6, 3, 2, 1);
        ctx.fillRect(4, 3, 2, 1);
      }

      // Open mouth (yelling)
      ctx.fillStyle = '#222';
      ctx.fillRect(-3, 6, 6, 3);
      ctx.fillStyle = '#ff6666'; // Tongue
      ctx.fillRect(-2, 7, 4, 2);

      // Beard
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(-7, 8, 14, 4);
      ctx.fillRect(-6, 10, 12, 3);

      // Buffalo horn headdress with fur
      ctx.fillStyle = '#8b7355'; // Fur cap base
      ctx.fillRect(-12, -8, 24, 8);
      // Fur texture on cap
      ctx.fillStyle = '#a08060';
      ctx.fillRect(-10, -6, 4, 4);
      ctx.fillRect(6, -6, 4, 4);
      // Left horn (dark, curved via rectangles)
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(-16, -14, 4, 8);
      ctx.fillRect(-18, -18, 4, 6);
      ctx.fillRect(-19, -22, 3, 5);
      // Right horn
      ctx.fillRect(12, -14, 4, 8);
      ctx.fillRect(14, -18, 4, 6);
      ctx.fillRect(16, -22, 3, 5);
      // Horn highlights
      ctx.fillStyle = '#444';
      ctx.fillRect(-15, -16, 2, 4);
      ctx.fillRect(13, -16, 2, 4);

      // American flag on spear (held to side)
      ctx.fillStyle = '#8b4513'; // Spear pole
      ctx.fillRect(16, -10, 2, 50);
      // Flag
      ctx.fillStyle = '#cc0000';
      ctx.fillRect(18, -8, 12, 8);
      ctx.fillStyle = '#fff';
      ctx.fillRect(18, -6, 12, 2);
      ctx.fillRect(18, -2, 12, 2);
      ctx.fillStyle = '#002868';
      ctx.fillRect(18, -8, 5, 4);

    } else {
      // === NORMAL GUESTS ===
      // Body/suit
      ctx.fillStyle = app.suit || '#1a1a2e';
      ctx.fillRect(-12, 6, 24, 26);

      // Shirt
      ctx.fillStyle = '#d8e6ff';
      ctx.fillRect(-8, 10, 16, 18);

      // Tie (if has one)
      if (app.tie) {
        ctx.fillStyle = app.tie;
        ctx.fillRect(-2, 14, 4, 14);
      }

      // Head/face (bigger for Vance)
      ctx.save();
      if (app.bigHead) ctx.scale(headScale, headScale);
      ctx.fillStyle = '#f5d0a9';
      ctx.fillRect(-9, -2, 18, 12);

      // Eyes
      const blinkNow = Math.random() < 0.02;
      if (!blinkNow) {
        ctx.fillStyle = '#111';
        ctx.fillRect(-6, 2, 2, 2);
        ctx.fillRect(4, 2, 2, 2);
      } else {
        ctx.fillStyle = '#111';
        ctx.fillRect(-6, 3, 2, 1);
        ctx.fillRect(4, 3, 2, 1);
      }

      // Hair
      ctx.fillStyle = app.hair || '#3a2a1a';
      if (app.isF) {
        ctx.fillRect(-10, -6, 20, 6);
        ctx.fillRect(-12, -2, 4, 10);
        ctx.fillRect(8, -2, 4, 10);
      } else if (app.isElon) {
        // Elon's receding hairline
        ctx.fillRect(-6, -5, 12, 4);
        ctx.fillRect(-8, -3, 2, 2);
        ctx.fillRect(6, -3, 2, 2);
      } else {
        ctx.fillRect(-10, -6, 20, 6);
      }
      ctx.restore();

      // Glasses (journalist)
      if (app.hasGlasses) {
        ctx.fillStyle = '#222';
        ctx.fillRect(-7, 0, 6, 4);
        ctx.fillRect(1, 0, 6, 4);
        ctx.fillRect(-1, 1, 2, 2);
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(-6, 1, 2, 1);
        ctx.fillRect(2, 1, 2, 1);
      }

      // Notepad (journalist)
      if (app.hasNotepad) {
        ctx.fillStyle = '#f5f5dc';
        ctx.fillRect(-18, 20, 8, 10);
        ctx.fillStyle = '#333';
        ctx.fillRect(-17, 22, 6, 1);
        ctx.fillRect(-17, 24, 5, 1);
        ctx.fillRect(-17, 26, 6, 1);
      }

      // Microphone (Fox News)
      if (app.hasMic) {
        ctx.fillStyle = '#333';
        ctx.fillRect(14, 15, 3, 12);
        ctx.fillStyle = '#666';
        ctx.fillRect(13, 12, 5, 4);
      }

      // American flag pin (MTG)
      if (app.hasFlag) {
        ctx.fillStyle = '#cc0000';
        ctx.fillRect(-10, 12, 6, 4);
        ctx.fillStyle = '#fff';
        ctx.fillRect(-10, 14, 6, 1);
        ctx.fillStyle = '#002868';
        ctx.fillRect(-10, 12, 3, 2);
      }

      // Beard (JD Vance)
      if (app.hasBeard) {
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(-7, 6, 14, 4);
        ctx.fillRect(-8, 4, 3, 4);
        ctx.fillRect(5, 4, 3, 4);
      }
    }

    ctx.restore();

    // Draw nametag above guest's head
    ctx.save();
    ctx.font = `bold ${11*CFG.SCALE}px system-ui`;
    ctx.textAlign = 'center';
    const nameText = guest.name;
    const nameWidth = ctx.measureText(nameText).width + 12*CFG.SCALE;
    const nameY = y - (app.isShaman ? 105 : 85)*CFG.SCALE; // Higher for Shaman due to horns
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(x - nameWidth/2, nameY - 9*CFG.SCALE, nameWidth, 16*CFG.SCALE);
    ctx.fillStyle = '#fff';
    ctx.fillText(nameText, x, nameY + 3*CFG.SCALE);
    ctx.textAlign = 'left';
    ctx.restore();
  }
  function drawKremlinBackdrop(){
    // walls
    ctx.fillStyle='#f2e6e6'; ctx.fillRect(0,0,W,H);
    // red drapes
    ctx.fillStyle='#b33'; for(let i=0;i<4;i++){ const x=300*CFG.SCALE + i*160*CFG.SCALE; ctx.fillRect(x,80*CFG.SCALE,80*CFG.SCALE,160*CFG.SCALE); }
    // Stalin pictogram in golden frame
    const fx = 160*CFG.SCALE, fy = 90*CFG.SCALE, fw = 90*CFG.SCALE, fh = 70*CFG.SCALE;
    ctx.fillStyle='#c9a641'; ctx.fillRect(fx-6, fy-6, fw+12, fh+12);
    ctx.fillStyle='#f5efe1'; ctx.fillRect(fx, fy, fw, fh);
    ctx.fillStyle='#333'; ctx.fillRect(fx+fw*0.35, fy+fh*0.28, fw*0.3, fh*0.38);
    ctx.fillRect(fx+fw*0.42, fy+fh*0.12, fw*0.16, fh*0.18);
    // carpet
    ctx.fillStyle='#8b0000'; ctx.fillRect(0,H-world.floor,W,world.floor);
    // long black table (main body only - top edge drawn later)
    const y = H - world.floor + 24*CFG.SCALE;
    const tx = 300*CFG.SCALE, tw = (W - 2*300*CFG.SCALE), th = 60*CFG.SCALE;
    ctx.fillStyle='#111'; ctx.fillRect(tx, y-30*CFG.SCALE, tw, th);
    // framed border map if drawn
    if (KR.border && KR.border.length>1){
      const mw=120*CFG.SCALE, mh=80*CFG.SCALE, mx=W - 220*CFG.SCALE, my=100*CFG.SCALE;
      ctx.fillStyle='#c9a641'; ctx.fillRect(mx-6,my-6,mw+12,mh+12);
      ctx.fillStyle='#f5efe1'; ctx.fillRect(mx,my,mw,mh);
      // draw stored polyline
      ctx.strokeStyle='#222'; ctx.lineWidth=3; ctx.beginPath();
      ctx.moveTo(mx + KR.border[0].x*mw, my + KR.border[0].y*mh);
      for (let i=1;i<KR.border.length;i++) ctx.lineTo(mx + KR.border[i].x*mw, my + KR.border[i].y*mh);
      ctx.stroke(); ctx.strokeStyle='#ffd54f'; ctx.lineWidth=2; ctx.stroke();
    }
  }
  function drawDoor(x,y){
    ctx.save(); ctx.translate(x, y-80*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#ddd'; ctx.fillRect(-14,0,28,80); ctx.fillStyle='#bbb'; ctx.fillRect(10,34,4,8);
    ctx.restore();
  }
  function drawAide(x,y){
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#223'; ctx.fillRect(-10,8,20,26);
    ctx.fillStyle='#e8d7c2'; ctx.fillRect(-8,-2,16,12);
    ctx.fillStyle='#444'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  function drawYesGroup(x,y){
    // If a custom sprite is provided for group members, draw three of them
    if (GRAPHICS.imageReady('yes_member')){
      const spacing = 34*CFG.SCALE;
      GRAPHICS.drawImage(ctx, GRAPHICS.images.get('yes_member'), x - spacing, y - 22*CFG.SCALE, null, null, true);
      GRAPHICS.drawImage(ctx, GRAPHICS.images.get('yes_member'), x,             y - 22*CFG.SCALE, null, null, true);
      GRAPHICS.drawImage(ctx, GRAPHICS.images.get('yes_member'), x + spacing, y - 22*CFG.SCALE, null, null, true);
      return;
    }
    const men = OV.yes.members || [];
    const spacing = 34*CFG.SCALE;
    const praising = OV.yes.speakingUntil > nowMs();
    for (let i=0;i<3;i++){
      const m = men[i] || { blinkUntil:0, nodPhase:i, isF: i===1 };
      const dx = x + (-spacing + i*spacing);
      // amplify nod a bit so it reads
      const nod = Math.sin(nowMs()/900 + (m.nodPhase||0))*1.0*CFG.SCALE;
      ctx.save(); ctx.translate(dx, y-44*CFG.SCALE + nod); ctx.scale(CFG.SCALE, CFG.SCALE);
      const suits = ['#cc0000','#ffffff','#0044cc']; // Red, white, blue (MAGA theme)
      // legs
      ctx.fillStyle='#2b2b2b'; ctx.fillRect(-10,34,9,10); ctx.fillRect(2,34,9,10);
      // torso/dress (left woman = pink w/o flag, right woman = red flag dress)
      if (m.isF){
        if (i===0){ ctx.fillStyle='#e91e63'; ctx.fillRect(-10,8,20,26); }
        else { ctx.fillStyle='#c01818'; ctx.fillRect(-10,8,20,26); ctx.fillStyle='#fff'; ctx.fillRect(-2,8,4,26); ctx.fillRect(-10,20,20,4); }
      }
      else { ctx.fillStyle=suits[i%3]; ctx.fillRect(-10,8,20,26); }
      // head
      ctx.fillStyle='#e8d7c2'; ctx.fillRect(-8,-2,16,12);
      // eyes (blink)
      if (!(m.blinkUntil && nowMs() < m.blinkUntil)){
        ctx.fillStyle='#111'; ctx.fillRect(-5,2,2,2); ctx.fillRect(3,2,2,2);
      } else {
        ctx.fillStyle='#111'; ctx.fillRect(-5,3,2,1); ctx.fillRect(3,3,2,1);
      }
      // hair (long hair for women)
      if (m.isF){
        ctx.fillStyle='#6b4328';
        ctx.fillRect(-9,-5,18,5);            // top
        ctx.fillRect(-10,-2,4,16);           // left strand
        ctx.fillRect(6,-2,4,16);             // right strand
      } else {
        ctx.fillStyle='#444'; ctx.fillRect(-9,-5,18,5);
      }
      // MAGA hat (red cap with white text) - varied sizes
      const hatSizes = [1.0, 0.85, 1.15]; // different sizes for variation
      const hatScale = hatSizes[i % 3];
      ctx.fillStyle='#cc0000';
      ctx.fillRect(-9*hatScale,-8,18*hatScale,5); // cap top
      ctx.fillRect(-11*hatScale,-4,6*hatScale,2); // brim
      ctx.fillStyle='#fff';
      ctx.font = `bold ${3*hatScale}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText('MAGA', 0, -5);
      // arms: raise when reacting
      ctx.globalAlpha=0.9; ctx.fillStyle=suits[i%3];
      if (praising){
        // raised arms near head
        ctx.fillRect(-14,0,4,14); // left up
        ctx.fillRect(10,0,4,14);  // right up
        // Draw sign above head
        const mood = OV.yes.mood || 'happy';
        const signColor = mood === 'happy' ? '#00aa00' : '#cc0000';
        const signText = mood === 'happy' ? 'YES!' : 'BOO!';
        ctx.fillStyle = signColor;
        ctx.fillRect(-12,-28,24,14); // sign background
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 8px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(signText, 0, -18);
      } else {
        // down arms along sides
        ctx.globalAlpha=.5; ctx.fillStyle=suits[i%3];
        ctx.fillRect(-14,15,4,10); ctx.fillRect(10,15,4,10);
      }
      ctx.restore();
    }
  }
  function drawTesla(x,y){
    // align wheels to ground y; larger car
    ctx.save(); ctx.translate(x, y-12*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // wheels
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(-20,12,5,0,Math.PI*2); ctx.arc(20,12,5,0,Math.PI*2); ctx.fill();
    // body
    ctx.fillStyle='#c00'; ctx.fillRect(-36,-2,72,18);
    // window strip
    ctx.fillStyle='#222'; ctx.fillRect(-28,-4,56,6);
    // Tesla logo (stylized T)
    ctx.fillStyle='#fff'; ctx.fillRect(-2,0,4,8); ctx.fillRect(-10,-2,20,2);
    ctx.restore();
  }
  function drawButton(x,y,color,label){
    const offset = getInteractionOffset({type:'button', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-10*CFG.SCALE + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#444'; ctx.fillRect(-16,10,32,8);
    ctx.fillStyle=color; ctx.fillRect(-14,4,28,8);
    ctx.fillStyle='#fff'; ctx.font='bold 8px system-ui'; ctx.textAlign='center';
    ctx.fillText(label, 0, 0);
    ctx.restore();
  }

  // PRAISE and COUNTRIES loaded from game-text-data JSON block
  const BOO_LINES = ['Boooo!', 'Not cool!', 'Sad!', 'Wrong answer!', 'Fake decision!'];
  function praiseChoir(){
    const line = PRAISE[Math.floor(Math.random()*PRAISE.length)];
    OV.yes.say = line; OV.yes.speakingUntil = nowMs()+1200;
    OV.yes.mood = 'happy';
  }
  function booChoir(){
    const line = BOO_LINES[Math.floor(Math.random()*BOO_LINES.length)];
    OV.yes.say = line; OV.yes.speakingUntil = nowMs()+1200;
    OV.yes.mood = 'angry';
  }
  function pickRandomCountry(){
    return COUNTRIES[Math.floor(Math.random()*COUNTRIES.length)];
  }
  function drawPutin(x,y){
    const nod = Math.sin(nowMs()/1150 + (KR.putin.nodPhase||0)) * 0.4*CFG.SCALE;
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE + nod); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#223'; ctx.fillRect(-10,8,20,26);
    // Ben
    ctx.fillStyle='#111'; ctx.fillRect(-7,34,5,10); // venstre ben
    ctx.fillStyle='#111'; ctx.fillRect(2,34,5,10);  // højre ben
    ctx.fillStyle='#e6c9a8'; ctx.fillRect(-8,-2,16,12);
    if (!(KR.putin.blinkUntil && nowMs() < KR.putin.blinkUntil)){
      ctx.fillStyle='#111'; ctx.fillRect(-5,2,2,2); ctx.fillRect(3,2,2,2);
    } else { ctx.fillStyle='#111'; ctx.fillRect(-5,3,2,1); ctx.fillRect(3,3,2,1); }
    ctx.fillStyle='#c2a26a'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  function drawGoldStatue(x,y,variant=1){
    ctx.save(); ctx.translate(x, y-30*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // pedestal
    ctx.fillStyle='#8a6b2f'; ctx.fillRect(-10,16,20,6);
    // statue variants
    ctx.fillStyle='#d4af37';
    if (variant===1){ ctx.fillRect(-3,0,6,14); ctx.fillRect(-8,6,16,6); ctx.fillRect(-2,-6,4,6); }
    else if (variant===2){ ctx.fillRect(-2,0,4,14); ctx.fillRect(-10,8,20,4); ctx.fillRect(-2,-4,4,4); }
    else { ctx.fillRect(-4,2,8,12); ctx.fillRect(-2,-2,4,4); }
    ctx.restore();
  }

  function updateSecurityCamera(cam, offset = 0) {
    const now = nowMs();
    const elapsed = (now - cam.sweepStart) / 1000; // seconds
    const sweepDuration = 4; // 4 seconds for full sweep in one direction (faster!)
    const fullCycle = sweepDuration * 2; // 8 seconds for full back-and-forth cycle

    // Calculate which part of cycle we're in (with offset for opposite sweeping)
    const cycleProgress = ((elapsed / fullCycle) + offset) % 1;

    let sweepProgress;
    if (cycleProgress < 0.5) {
      // First half: left to right
      sweepProgress = cycleProgress * 2; // 0 to 1
    } else {
      // Second half: right to left
      sweepProgress = 2 - (cycleProgress * 2); // 1 to 0
    }

    // Calculate sweep angle (30° to 150°)
    cam.angle = Math.PI/6 + (2*Math.PI/3) * sweepProgress;
  }

  function updateAllSecurityCameras() {
    // Update legacy single camera (for backwards compatibility)
    updateSecurityCamera(KR.camera, 0);
    // Update all cameras in array
    if (KR.cameras) {
      KR.cameras.forEach(cam => updateSecurityCamera(cam, cam.sweepOffset || 0));
    }
  }

  function drawSingleCamera(cam) {
    // Draw camera body (3x larger)
    ctx.save();
    ctx.translate(cam.x, cam.y);

    // Camera housing (3x size)
    ctx.fillStyle = '#333';
    ctx.fillRect(-24*CFG.SCALE, -18*CFG.SCALE, 48*CFG.SCALE, 36*CFG.SCALE);

    // Camera lens - fixed at top center of housing (3x size)
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(0, -18*CFG.SCALE, 12*CFG.SCALE, 0, Math.PI*2);
    ctx.fill();

    // Red light when active - fixed position on lens
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(0, -18*CFG.SCALE, 4.5*CFG.SCALE, 0, Math.PI*2);
    ctx.fill();

    // Direction indicator (small line showing where camera points)
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    const indicatorLength = 20*CFG.SCALE;
    const endX = Math.cos(cam.angle) * indicatorLength;
    const endY = Math.sin(cam.angle) * indicatorLength;
    ctx.moveTo(0, -18*CFG.SCALE);
    ctx.lineTo(endX, -18*CFG.SCALE + endY);
    ctx.stroke();

    ctx.restore();
  }

  function drawSecurityCamera() {
    updateAllSecurityCameras();

    // Draw all cameras
    if (KR.cameras && KR.cameras.length > 0) {
      KR.cameras.forEach(cam => drawSingleCamera(cam));
    } else {
      // Fallback to legacy single camera
      drawSingleCamera(KR.camera);
    }

    // Note: Laser cone is now drawn separately after depth sorting to be on top of everything
  }

  function drawLaserCone(x, y, angle) {
    // Calculate laser length to reach the floor
    const floorY = H - world.floor;
    const distanceToFloor = floorY - y;
    const coneLength = distanceToFloor / Math.sin(Math.abs(angle)) * 1.5; // Extended to ensure it reaches floor
    const coneWidth = Math.PI/8; // 22.5 degrees cone width
    
    // Calculate cone points
    const endX = x + Math.cos(angle) * coneLength;
    const endY = y + Math.sin(angle) * coneLength;
    
    const leftAngle = angle - coneWidth/2;
    const rightAngle = angle + coneWidth/2;
    
    const leftX = x + Math.cos(leftAngle) * coneLength;
    const leftY = y + Math.sin(leftAngle) * coneLength;
    const rightX = x + Math.cos(rightAngle) * coneLength;
    const rightY = y + Math.sin(rightAngle) * coneLength;
    
    // Draw laser cone
    ctx.save();
    ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(leftX, leftY);
    ctx.lineTo(rightX, rightY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Center beam
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    ctx.restore();
  }

  function isPointUnderCameraSurveillance(px, py, cam) {
    const coneWidth = Math.PI/8; // Same as in drawLaserCone

    // Use lens position (same as laser cone)
    const lensX = cam.x;
    const lensY = cam.y - 18*CFG.SCALE;

    // Calculate angle from lens to point
    const dx = px - lensX;
    const dy = py - lensY;
    const pointAngle = Math.atan2(dy, dx);

    // Normalize angles to 0-2PI range
    const normalizeAngle = (a) => {
      while (a < 0) a += Math.PI * 2;
      while (a >= Math.PI * 2) a -= Math.PI * 2;
      return a;
    };

    const camAngle = normalizeAngle(cam.angle);
    const targetAngle = normalizeAngle(pointAngle);

    // Calculate angular difference
    let diff = Math.abs(camAngle - targetAngle);
    if (diff > Math.PI) diff = Math.PI * 2 - diff;

    // Check if point is within camera cone
    return diff <= coneWidth/2;
  }

  function isStatueUnderSurveillance(statue) {
    // Check all cameras
    const camerasToCheck = (KR.cameras && KR.cameras.length > 0) ? KR.cameras : [KR.camera];
    for (const cam of camerasToCheck) {
      if (isPointUnderCameraSurveillance(statue.x, statue.y, cam)) {
        if (CFG.DEBUG) console.log(`Statue under surveillance by camera at ${cam.x}`);
        return true;
      }
    }
    return false;
  }

  function isPlayerUnderSurveillance() {
    // Check if player is under any camera's laser
    const camerasToCheck = (KR.cameras && KR.cameras.length > 0) ? KR.cameras : [KR.camera];
    for (const cam of camerasToCheck) {
      if (isPointUnderCameraSurveillance(player.x, player.y, cam)) {
        return true;
      }
    }
    return false;
  }

  function triggerSecurityDiscovery(statue) {
    if (CFG.DEBUG) console.log('🚨 SECURITY DISCOVERY TRIGGERED! 🚨');

    // Set discovery state
    KR.camera.discovered = true;

    // Putin reacts immediately
    KR.putin.speakingUntil = nowMs() + 2500;
    KR.putin.say = 'WAGNER! SEIZE HIM!';

    // Trump's panicked response
    say(player, 'This is fake surveillance!', 2000);

    // Damage relationship severely
    adjustRelationship('putin', {respect: -15, trust: -20, fear: 5}, 'caught_stealing');

    // Screen flash effect (handled in render loop)
    KR.camera.flashUntil = nowMs() + 500;

    // Spawn Wagner soldiers
    spawnWagnerSoldiers(statue);
  }

  function spawnWagnerSoldiers(statue) {
    if (CFG.DEBUG) console.log('🔴 Wagner soldiers spawning!');

    // Initialize Wagner chase state
    KR.wagnerChase = {
      active: true,
      soldiers: [
        {x: KR.door.x, y: KR.door.y, speed: 2.5*CFG.SCALE},
        {x: KR.door.x + 40*CFG.SCALE, y: KR.door.y, speed: 2.2*CFG.SCALE}
      ],
      startTime: nowMs(),
      escaped: false,
      caught: false
    };

    // Check if player has gold shoes for escape
    const hasGoldShoes = hasItem('shoes');

    if (hasGoldShoes) {
      say(player, 'Time to use these gold sneakers!', 1200);
      // Player gets speed boost
      KR.wagnerChase.playerSpeedBoost = 1.8;
    } else {
      // Without shoes, player will be caught
      KR.wagnerChase.playerSpeedBoost = 1.0;
    }

    // Start chase sequence - update happens in game loop
    setTimeout(() => {
      if (KR.wagnerChase && !KR.wagnerChase.escaped && !KR.wagnerChase.caught) {
        checkWagnerCatch();
      }
    }, 3000);
  }

  function updateWagnerChase() {
    if (!KR.wagnerChase || !KR.wagnerChase.active) return;

    const chase = KR.wagnerChase;

    // Move soldiers toward player
    chase.soldiers.forEach(soldier => {
      const dx = player.x - soldier.x;
      const dy = player.y - soldier.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist > 10) {
        soldier.x += (dx/dist) * soldier.speed;
        soldier.y += (dy/dist) * soldier.speed * 0.3; // slower vertical
      }
    });

    // Check if player reached helicopter (escape!)
    const heliDist = Math.sqrt((player.x - KR.heli.x)**2 + (player.y - KR.heli.y)**2);
    if (heliDist < 60*CFG.SCALE && hasItem('shoes')) {
      chase.escaped = true;
      chase.active = false;
      say(player, 'Nobody catches Trump! NOBODY!', 2000);
      // Quick escape - force helicopter menu
      setTimeout(() => {
        openChoice("ESCAPE! Where to?\n1. Grønland\n2. The White House\n3. Mar-a-Lago", k=>{
          closeChoice();
          if (k==='1') switchScene('greenland');
          else if (k==='2') switchScene('oval');
          else if (k==='3') { try { SFX.whoosh(); } catch(_){} startGolf('course-mar-a-lago'); }
        });
      }, 500);
      return;
    }

    // Check if soldiers caught player
    chase.soldiers.forEach(soldier => {
      const catchDist = Math.sqrt((player.x - soldier.x)**2 + (player.y - soldier.y)**2);
      if (catchDist < 30*CFG.SCALE && !chase.escaped) {
        chase.caught = true;
        chase.active = false;
        wagnerCatchPlayer();
      }
    });
  }

  function checkWagnerCatch() {
    if (!KR.wagnerChase || KR.wagnerChase.escaped) return;
    if (!KR.wagnerChase.caught) {
      // Time's up - they catch you if you didn't escape
      KR.wagnerChase.caught = true;
      KR.wagnerChase.active = false;
      wagnerCatchPlayer();
    }
  }

  function wagnerCatchPlayer() {
    KR.putin.speakingUntil = nowMs() + 3000;
    KR.putin.say = 'Take him to the gulag!';
    say(player, 'This is very unfair treatment!', 2000);

    // Game over - caught by Wagner
    setTimeout(() => {
      try {
        gameOverCause('wagner', {
          delayMs: 0,
          title: 'CAPTURED BY WAGNER',
          subtitle: 'Should have worn those gold sneakers...'
        });
      } catch(_){}
    }, 2500);
  }

  function drawWagnerSoldiers() {
    if (!KR.wagnerChase || !KR.wagnerChase.active) return;

    KR.wagnerChase.soldiers.forEach((soldier, i) => {
      ctx.save();
      ctx.translate(soldier.x, soldier.y - 44*CFG.SCALE);
      ctx.scale(CFG.SCALE, CFG.SCALE);

      // Military boots
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(-8, 34, 7, 10);
      ctx.fillRect(1, 34, 7, 10);

      // Camo pants
      ctx.fillStyle = '#4a5d23';
      ctx.fillRect(-9, 20, 8, 16);
      ctx.fillRect(1, 20, 8, 16);

      // Camo torso
      ctx.fillStyle = '#5d6b2f';
      ctx.fillRect(-10, 8, 20, 14);

      // Head
      ctx.fillStyle = '#d4b896';
      ctx.fillRect(-7, -2, 14, 12);

      // Balaclava (black mask)
      ctx.fillStyle = '#111';
      ctx.fillRect(-7, 0, 14, 8);

      // Eyes through mask
      ctx.fillStyle = '#fff';
      ctx.fillRect(-4, 2, 3, 2);
      ctx.fillRect(1, 2, 3, 2);

      // Military beret
      ctx.fillStyle = '#8B0000';
      ctx.fillRect(-8, -5, 16, 4);

      // Wagner patch (skull symbol)
      ctx.fillStyle = '#fff';
      ctx.fillRect(-3, 10, 6, 4);

      // Arms reaching forward
      ctx.fillStyle = '#5d6b2f';
      ctx.fillRect(-14, 10, 5, 10);
      ctx.fillRect(9, 10, 5, 10);

      ctx.restore();

      // "WAGNER" label above
      ctx.save();
      ctx.font = `bold ${8*CFG.SCALE}px system-ui`;
      ctx.fillStyle = '#ff0000';
      ctx.textAlign = 'center';
      ctx.fillText('WAGNER', soldier.x, soldier.y - 55*CFG.SCALE);
      ctx.restore();
    });
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         16. AI & ENTITY UPDATES                            ║
  // ║  Bear AI, actor blinking, NPC behavior                                     ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Bear AI and Physics ----------
  function updateBearAI(dt, ground) {
    if (!GL.bear || !GL.bear.alive) return;
    
    GL.bear.vx = GL.bear.vx || 0; GL.bear.vy = GL.bear.vy || 0;
    
    // Chasing AI - if angry and on ground, chase Trump! (Only after HP reaches 0)  
    if (GL.bear.angry && GL.bear.chasing && GL.bear.hp <= 0 && GL.bear.y >= ground - 5*CFG.SCALE) {
      updateBearChaseLogic(dt);
    }
    
    updateBearPhysics(dt, ground);
  }
  
  function updateBearChaseLogic(dt) {
    const distToTrump = player.x - GL.bear.x;
    const chaseSpeed = GL.bear.speed * CFG.SCALE * dt;
    
    // Face Trump direction
    GL.bear.facing = distToTrump > 0 ? 1 : -1;
    
    // Move towards Trump
    if (Math.abs(distToTrump) > GAME_CONSTANTS.PHYSICS.BEAR_CHASE_DISTANCE*CFG.SCALE) {
      if (distToTrump > 0) {
        GL.bear.vx += chaseSpeed; // Chase right
      } else {
        GL.bear.vx -= chaseSpeed; // Chase left  
      }
      // Cap chase speed
      const maxSpeed = GL.bear.speed * CFG.SCALE;
      GL.bear.vx = Math.max(-maxSpeed, Math.min(maxSpeed, GL.bear.vx));
    } else {
      // Close enough - try to attack!
      if (Math.random() < GAME_CONSTANTS.PHYSICS.BEAR_ATTACK_CHANCE) {
        executeBearAttack(distToTrump);
      }
    }
  }
  
  function executeBearAttack(distToTrump) {
    say(GL.bear, "CHOMP! 🦷", 800);
    spawnBlood(player.x, player.y - 10*CFG.SCALE, 8);
    // Push Trump away
    const pushDir = Math.sign(distToTrump) || 1;
    nudge(player, pushDir * GAME_CONSTANTS.PHYSICS.HORIZONTAL_KNOCKBACK*CFG.SCALE, -20*CFG.SCALE, 200);
    SFX.error();
    
    // Lose some health or game over if caught too many times
    hudToast = "🐻 Bear attack!";
    
    // Optional: could end game here if desired; doom mechanic removed
  }
  
  function updateBearPhysics(dt, ground) {
    // Apply physics
    const g = GAME_CONSTANTS.PHYSICS.GRAVITY * dt; // gravity px/s^2 scaled by dt
    GL.bear.vy += g;
    
    // Update position
    GL.bear.y += GL.bear.vy * dt;
    GL.bear.x += GL.bear.vx * dt;
    
    // Horizontal damping (less when chasing)
    const dampingFactor = GL.bear.chasing ? GAME_CONSTANTS.PHYSICS.CHASE_DAMPING : GAME_CONSTANTS.PHYSICS.NORMAL_DAMPING;
    GL.bear.vx *= dampingFactor;
    
    // Ground collision with improved detection
    if (GL.bear.y >= ground) { 
      GL.bear.y = ground; 
      GL.bear.vy = 0;
      // Extra damping when on ground to prevent sliding (less when chasing)
      GL.bear.vx *= GL.bear.chasing ? GAME_CONSTANTS.PHYSICS.GROUND_DAMPING_CHASE : GAME_CONSTANTS.PHYSICS.GROUND_DAMPING_NORMAL;
    }
    
    // Screen bounds to prevent getting stuck off-screen
    const minX = GAME_CONSTANTS.PHYSICS.SCREEN_MARGIN*CFG.SCALE, 
          maxX = W - GAME_CONSTANTS.PHYSICS.SCREEN_MARGIN*CFG.SCALE;
    if (GL.bear.x < minX) {
      GL.bear.x = minX;
      GL.bear.vx = Math.abs(GL.bear.vx) * GAME_CONSTANTS.PHYSICS.BOUNCE_DAMPING; // bounce back gently
    }
    if (GL.bear.x > maxX) {
      GL.bear.x = maxX;
      GL.bear.vx = -Math.abs(GL.bear.vx) * GAME_CONSTANTS.PHYSICS.BOUNCE_DAMPING; // bounce back gently
    }
  }

  function startFlagDrop(){
    // Flag starter midt på skærmen, øverst
    flagDrop = {
      x: player.x,
      y: -50*CFG.SCALE,
      vy: 0,
      targetY: H - world.floor,
      landed: false
    };
    say(player, 'The flag is coming! TREMENDOUS!', 2000);
  }

  function updateFlagDrop(dt){
    if (!flagDrop || flagDrop.landed) return;
    // Accelerer langsomt ned (som en faldskærm)
    flagDrop.vy += 200*CFG.SCALE * dt;
    flagDrop.vy = Math.min(flagDrop.vy, 150*CFG.SCALE); // max fart
    flagDrop.y += flagDrop.vy * dt;
    // Følg spilleren horisontalt
    flagDrop.x += (player.x - flagDrop.x) * 2 * dt;
    // Check om flaget er landet (ved Trumps hænder)
    const handY = player.y - 20*CFG.SCALE;
    if (flagDrop.y >= handY){
      flagDrop.y = handY;
      flagDrop.landed = true;
      flagDrop.x = player.x;
      // Placer flaget permanent
      GL.flag = {x: player.x, y: H - world.floor};
      GL.state.flagPlanted = true;
      say(player, 'GREENLAND IS NOW AMERICAN! 🇺🇸', 3000);
      SFX.coinCollect();
      spawnSparks(player.x, player.y - 30*CFG.SCALE, 20);
    }
  }

  // ---------- Actors update ----------
  function updateActors(dt){
    // Bear physics and AI - only in Greenland scene
    if (scene === 'greenland') {
      const ground = H - world.floor;
      updateBearAI(dt, ground);

      // Mette blown up physics
      if (GL.mette.blownUp){
        GL.mette.vx = GL.mette.vx || 0;
        GL.mette.vy = GL.mette.vy || 0;
        GL.mette.vy += 800*CFG.SCALE * dt; // gravity
        GL.mette.x += GL.mette.vx * dt;
        GL.mette.y += GL.mette.vy * dt;
        // Rotér mens hun flyver
        GL.mette.rotation = (GL.mette.rotation || 0) + 10 * dt;
      }

      // Flag drop animation
      updateFlagDrop(dt);
    } // End greenland scene check

    // Oval Office Presidential Decisions update
    if (scene === 'oval' && OV.decisions.active) {
      updateOvalDecisions(dt);
    }

    // clouds (parallax)
    if (CLOUDS && CLOUDS.length){
      CLOUDS.forEach(c=>{ c.x += c.vx*dt; if (c.x > W + c.w) c.x = -c.w; });
    }
    // schedule blinks
    const tnow = nowMs();
    function updBlink(o){
      if (!o) return;
      if (!o.nextBlink || tnow > o.nextBlink){
        o.blinkUntil = tnow + 120;
        // next blink 2–4.5s later
        o.nextBlink = tnow + 2000 + Math.random()*2500;
      }
    }
    updBlink(player);
    updBlink(GL.mette);
    updBlink(KR.putin);
    // yes-men
    if (OV.yes && OV.yes.members){ OV.yes.members.forEach(m=>{ if (!m.nextBlink || tnow>m.nextBlink){ m.blinkUntil = tnow+120; m.nextBlink = tnow + 2000 + Math.random()*2500; } }); }
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         17. PARTICLE EFFECTS                               ║
  // ║  Blood, sparks, oil, flames, confetti, downwash                            ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Generalized particle update system ----------
  const PARTICLE_PHYSICS = {
    blood:        { gravity: 220, gravMult: 0.6, dampX: 1, dampY: 1, usePool: true },
    sparks:       { gravity: 380, gravMult: 0.5, dampX: 0.98, dampY: 0.98, usePool: true },
    confetti:     { gravity: 380, gravMult: 0.6, dampX: 0.985, dampY: 0.985, usePool: false, hasRotation: true },
    contamination:{ gravity: 380, gravMult: 0.3, dampX: 0.95, dampY: 0.95, usePool: true, fadeAlpha: 0.5 },
    downwash:     { gravity: 260, gravMult: 0.4, dampX: 0.96, dampY: 0.96, usePool: true },
    flame:        { gravity: 0, gravMult: 0, dampX: 0.96, dampY: 0.98, usePool: true }
  };

  function updateParticleType(type, dt) {
    if (!fx[type]) return;
    const cfg = PARTICLE_PHYSICS[type];
    if (!cfg) return;

    const dead = [];
    fx[type] = fx[type].filter(p => {
      p.life -= dt * 1000;
      if (p.life <= 0) { dead.push(p); return false; }
      return true;
    });
    if (cfg.usePool) dead.forEach(p => returnParticle(type, p));

    const g = cfg.gravity * CFG.SCALE;
    fx[type].forEach(p => {
      if (cfg.gravity) p.vy += g * dt * cfg.gravMult;
      p.vx *= cfg.dampX;
      p.vy *= cfg.dampY;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (cfg.hasRotation && p.rotSpeed) p.rot += p.rotSpeed * dt;
      if (cfg.fadeAlpha && p.alpha !== undefined) p.alpha = Math.max(0.1, p.alpha - dt * cfg.fadeAlpha);
    });
  }

  // ---------- FX update/draw ----------
  function updateFx(dt){
    // Update standard particle types with generalized system
    ['blood', 'sparks', 'confetti', 'contamination', 'downwash', 'flame'].forEach(type => updateParticleType(type, dt));

    // oil particles - special ground collision logic
    const ground = H - world.floor;
    const deadOil = [];
    fx.oil = fx.oil.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) { deadOil.push(p); return false; }
      return true;
    });
    deadOil.forEach(p => returnParticle('oil', p));
    fx.oil.forEach(p => {
      if (!p.landed){
        p.vy += 900*CFG.SCALE*dt;
        p.x += p.vx*dt; p.y += p.vy*dt;
        if (p.y >= ground){ p.y = ground; p.vy = 0; p.vx *= 0.5; p.landed = true; p.life += 800; }
      } else {
        p.vx *= 0.9; p.x += p.vx*dt;
      }
    });
    
    // Update ice chunks from glacier explosion
    if (glacierExplosion.active) {
      glacierExplosion.iceChunks = glacierExplosion.iceChunks.filter(chunk => {
        chunk.life -= dt * 1000;
        if (chunk.life <= 0) return false;
        
        // Physics
        chunk.vy += 1400 * dt * 0.8; // Gravity for ice chunks
        chunk.x += chunk.vx * dt;
        chunk.y += chunk.vy * dt;
        chunk.rotation += chunk.rotSpeed * dt;
        
        // Bounce off ground
        if (chunk.y >= ground) {
          chunk.y = ground;
          chunk.vy *= -0.3; // Bounce with damping
          chunk.vx *= 0.8; // Friction
        }
        
        return true;
      });
    }
  }
  function drawFx(){
    // draw blood as pixel squares
    ctx.save();
    fx.blood.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/400));
      ctx.globalAlpha = a;
      ctx.fillStyle = '#b31217';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // sparks
    fx.sparks.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/300));
      ctx.globalAlpha = a;
      ctx.fillStyle = a>0.5 ? '#ffd54f' : '#ff9800';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // confetti
    fx.confetti.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/1200));
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      // draw small rotating square
      ctx.save();
      ctx.translate(p.x + p.size/2, p.y + p.size/2);
      ctx.rotate(p.rot);
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
      ctx.restore();
    });
    // Draw briefly placed dynamite objects
    if (PLANTED && PLANTED.length){
      const nowt = nowMs();
      PLANTED = PLANTED.filter(p => (nowt - p.start) < p.ttl);
      PLANTED.forEach(p => {
        const fuseOn = Math.floor(nowt/120)%2===0;
        ctx.save();
        ctx.fillStyle='#d32f2f';
        ctx.fillRect(p.x-6*CFG.SCALE, p.y-12*CFG.SCALE, 6*CFG.SCALE, 14*CFG.SCALE);
        ctx.fillRect(p.x+2*CFG.SCALE, p.y-12*CFG.SCALE, 6*CFG.SCALE, 14*CFG.SCALE);
        ctx.fillStyle='#333'; ctx.fillRect(p.x-6*CFG.SCALE, p.y-8*CFG.SCALE, 6*CFG.SCALE, 2*CFG.SCALE);
        ctx.fillRect(p.x+2*CFG.SCALE, p.y-8*CFG.SCALE, 6*CFG.SCALE, 2*CFG.SCALE);
        // fuse spark and particles
        const fxX = p.x + 8*CFG.SCALE, fxY = p.y - 14*CFG.SCALE;
        ctx.fillStyle = fuseOn? '#ffd54f' : '#ff9800';
        ctx.fillRect(fxX, fxY, 2*CFG.SCALE, 2*CFG.SCALE);
        // Emit small sparks periodically while the fuse "burns"
        if (!p.lastSparkAt || (nowt - p.lastSparkAt) > 140){
          spawnSparks(fxX, fxY, 3);
          p.lastSparkAt = nowt;
        }
        // slide-up arrow above placement
        const k = Math.max(0, Math.min(1, (nowt - p.start)/p.ttl));
        const ay = (p.y - 18*CFG.SCALE) - 10*CFG.SCALE*k;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.moveTo(p.x, ay - 6*CFG.SCALE);
        ctx.lineTo(p.x - 6*CFG.SCALE, ay + 4*CFG.SCALE);
        ctx.lineTo(p.x + 6*CFG.SCALE, ay + 4*CFG.SCALE);
        ctx.closePath(); ctx.fill();
        // 'Planted!' label
        ctx.font = `${10*CFG.SCALE}px system-ui`;
        ctx.fillStyle = `rgba(255,255,255,${(1 - (nowt - p.start)/p.ttl).toFixed(2)})`;
        ctx.textAlign = 'center';
        ctx.fillText('Planted!', p.x, ay - 6*CFG.SCALE);
        ctx.textAlign = 'left';
        ctx.restore();
      });
    }
    // contamination particles
    if (fx.contamination) {
      fx.contamination.forEach(p => {
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = '#00FF00'; // Bright green
        ctx.fillRect(p.x, p.y, p.size, p.size);
        // Add a slight glow effect
        ctx.globalAlpha = p.alpha * 0.3;
        ctx.fillStyle = '#90EE90';
        ctx.fillRect(p.x-1, p.y-1, p.size+2, p.size+2);
      });
    }
    // downwash
    fx.downwash.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/400));
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // oil
    fx.oil.forEach(p => {
      const a = Math.max(0.1, Math.min(1, p.life/900));
      ctx.globalAlpha = a;
      ctx.fillStyle = '#111';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // flame
    fx.flame.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/300));
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    
    // Draw glacier explosion effects
    if (glacierExplosion.active) {
      // Draw explosion effects
      glacierExplosion.explosions.forEach(exp => {
        const elapsed = nowMs() - exp.time;
        if (elapsed < exp.duration) {
          const progress = elapsed / exp.duration;
          const size = progress * 100 * CFG.SCALE;
          const alpha = 1 - progress;
          
          // Try custom explosion sprite
          if (!GRAPHICS.drawOrFallback(ctx, 'explosion', () => {}, exp.x, exp.y)) {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, size, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Inner white flash
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, size * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Draw ice chunks
      glacierExplosion.iceChunks.forEach(chunk => {
        const alpha = Math.max(0, chunk.life / 3000);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#e8f4f8';
        
        ctx.save();
        ctx.translate(chunk.x, chunk.y);
        ctx.rotate(chunk.rotation);
        ctx.fillRect(-chunk.size/2, -chunk.size/2, chunk.size, chunk.size);
        ctx.restore();
      });
      
      ctx.globalAlpha = 1;
    }
    
    ctx.restore();
  }

  // ---------- Missile overlay ----------
  function drawMissileFallback(x,y){
    ctx.save();
    const s = 4*CFG.SCALE; // 4x bigger
    // body
    ctx.fillStyle='#bbb'; ctx.fillRect(x-10*s, y-40*s, 20*s, 40*s);
    // cone
    ctx.beginPath(); ctx.moveTo(x, y-56*s); ctx.lineTo(x-10*s, y-40*s); ctx.lineTo(x+10*s, y-40*s); ctx.closePath(); ctx.fillStyle='#999'; ctx.fill();
    // fins
    ctx.fillStyle='#777'; ctx.fillRect(x-16*s, y-18*s, 6*s, 12*s);
    ctx.fillRect(x+10*s, y-18*s, 6*s, 12*s);
    // nuclear symbol
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x, y-26*s, 6*s, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#ffd54f';
    ctx.beginPath(); ctx.moveTo(x, y-26*s); ctx.arc(x, y-26*s, 5*s, -Math.PI/6, Math.PI/6); ctx.lineTo(x, y-26*s); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x, y-26*s); ctx.arc(x, y-26*s, 5*s, Math.PI/2 - Math.PI/6, Math.PI/2 + Math.PI/6); ctx.lineTo(x, y-26*s); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x, y-26*s); ctx.arc(x, y-26*s, 5*s, Math.PI - Math.PI/6, Math.PI + Math.PI/6); ctx.lineTo(x, y-26*s); ctx.fill();
    // flame
    ctx.fillStyle='#ff9800'; ctx.fillRect(x-6*s, y, 12*s, 12*s);
    ctx.fillStyle='#ffd54f'; ctx.fillRect(x-3*s, y+2*s, 6*s, 6*s);
    ctx.restore();
  }

  function drawMissile(x,y){
    if (GRAPHICS.drawOrFallback(ctx, 'missile', drawMissileFallback, x, y)) return;
    drawMissileFallback(x,y);
  }

  // ---------- Hint tegning ----------
  
  // pulsating hover outline (disabled by default via CFG.SHOW_PULSE)
  function drawPulseFor(o){
    const t = nowMs()/1000;
    const w = Math.max(18, o.w||22) * CFG.SCALE;
    const h = (o.h? Math.max(10, o.h/2): 12) * CFG.SCALE;
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(o.x, o.y-6, w*0.9 + Math.sin(t*3)*2, h*0.5 + Math.sin(t*3)*1, 0, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 1.5 + (Math.sin(t*3)*0.6);
    ctx.stroke();
    ctx.restore();
  }
  // Shape-following interact glow outlines
  function drawGlowOutline(obj){
    const maxR = CFG.INTERACT_DIST*2.2*CFG.SCALE;
    const d = Math.hypot(player.x-obj.x, player.y-obj.y);
    if (d>maxR) return;
    const a = Math.max(0, 1 - d/maxR);
    const color = (obj.type==='bear') ? 'rgba(120,170,255,'+(0.6*a).toFixed(3)+')' : 'rgba(255,255,255,'+(0.55*a).toFixed(3)+')';
    ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
    if (obj.type==='bear'){
      const w=60*CFG.SCALE, h=20*CFG.SCALE; const x=obj.x, y=obj.y-12*CFG.SCALE;
      roundedRectPath(x-w/2, y-h/2, w, h, 10*CFG.SCALE);
      ctx.moveTo(x+w*0.35, y-h*0.6); roundedRectPath(x+w*0.35, y-h*0.9, 22*CFG.SCALE, 14*CFG.SCALE, 4*CFG.SCALE);
    } else if (obj.type==='rig'){
      const x=obj.x, y=obj.y-60*CFG.SCALE; const base=32*CFG.SCALE;
      ctx.moveTo(x-base, y+70*CFG.SCALE); ctx.lineTo(x, y-8*CFG.SCALE); ctx.lineTo(x+base, y+70*CFG.SCALE); ctx.closePath();
      ctx.moveTo(x-36*CFG.SCALE, y+70*CFG.SCALE); ctx.lineTo(x+36*CFG.SCALE, y+70*CFG.SCALE);
    } else if (obj.type==='mine'){
      ctx.ellipse(obj.x, obj.y, 20*CFG.SCALE, 8*CFG.SCALE, 0, 0, Math.PI*2);
    } else if (obj.type==='heli'){
      const x=obj.x, y=obj.y; ctx.rect(x-40*CFG.SCALE, y-10*CFG.SCALE, 100*CFG.SCALE, 28*CFG.SCALE);
    } else if (obj.type==='mette' || obj.type==='putin' || obj.type==='aide'){
      roundedRectPath(obj.x-12*CFG.SCALE, obj.y-44*CFG.SCALE, 24*CFG.SCALE, 44*CFG.SCALE, 6*CFG.SCALE);
    } else if (obj.type==='door'){
      roundedRectPath(obj.x-14*CFG.SCALE, obj.y-80*CFG.SCALE, 28*CFG.SCALE, 80*CFG.SCALE, 4*CFG.SCALE);
    } else if (obj.type==='glacier'){
      const w = obj.w*CFG.SCALE, h = obj.h*CFG.SCALE;
      ctx.beginPath();
      ctx.moveTo(obj.x-w/2, obj.y+h/2);
      ctx.lineTo(obj.x-w/3, obj.y-h/2);
      ctx.lineTo(obj.x, obj.y-h/2-20*CFG.SCALE);
      ctx.lineTo(obj.x+w/3, obj.y-h/2);
      ctx.lineTo(obj.x+w/2, obj.y+h/2);
      ctx.closePath();
    } else if (obj.type==='phone'){
      roundedRectPath(obj.x-8*CFG.SCALE, obj.y-34*CFG.SCALE, 16*CFG.SCALE, 28*CFG.SCALE, 3*CFG.SCALE);
    } else if (obj.type==='statue'){
      roundedRectPath(obj.x-10*CFG.SCALE, obj.y-30*CFG.SCALE, 20*CFG.SCALE, 30*CFG.SCALE, 4*CFG.SCALE);
    } else {
      ctx.restore(); return;
    }
    ctx.stroke(); ctx.restore();
  }
  function roundedRectPath(x,y,w,h,r){
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
  }
  // (outline hint removed for now per request)

  // Hint: planting instruction for Greenland when dynamite is selected
  function drawPlantHintGreenland(){
    if (scene!=='greenland') return;
    if (player.selectedItem !== 'dynamite') return;
    const dyn = inventory.find(i=>i.id==='dynamite');
    if (!dyn || (dyn.qty||0)<=0) return;
    // find nearest valid target
    const obj = nearestGL();
    const valid = obj && (obj.type==='mette' || obj.type==='bear' || obj.type==='rig' || obj.type==='glacier');
    if (!valid) return; // show only when near a valid target
    const x = obj.x;
    const y = obj.y;
    const msg = 'Press E to plant dynamite';
    ctx.save();
    ctx.font = `${12*CFG.SCALE}px system-ui`;
    const pad = 8*CFG.SCALE; const tw = ctx.measureText(msg).width; const w = tw + pad*2; const h = 22*CFG.SCALE;
    const bx = Math.max(pad, Math.min(W - w - pad, x - w/2));
    // Raise hint higher to avoid overlapping characters
    const by = y - 100*CFG.SCALE;
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.lineWidth = 1;
    roundRect(bx, by, w, h, 6*CFG.SCALE); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.fillText(msg, bx + w/2, by + h*0.7);
    ctx.textAlign='left'; ctx.restore();
  }
  function drawPlantHintGeneric(){
    // Currently we only support valid planting targets in Greenland.
    // For other scenes, do not show a generic hint to avoid confusion.
    return;
  }

  // Navigation hints for new players in Greenland
  function drawGreenlandNavHints(){
    if (scene !== 'greenland') return;
    ctx.save();

    // "Tryk E for at flyve til næste bane" over helikopteren
    const heliX = GL.heli.x;
    const heliY = GL.heli.y - 170*CFG.SCALE;
    const heliLine1 = 'E';
    const heliLine2 = 'Tryk E for at flyve til næste bane';
    ctx.font = `${11*CFG.SCALE}px system-ui`;
    const heliTw = ctx.measureText(heliLine2).width;
    const heliBoxW = heliTw + 16*CFG.SCALE;
    const heliBoxH = 50*CFG.SCALE;
    const heliBoxX = heliX - heliBoxW/2;
    const heliBoxY = heliY - 10*CFG.SCALE;

    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    roundRect(heliBoxX, heliBoxY, heliBoxW, heliBoxH, 8*CFG.SCALE);
    ctx.fill();

    ctx.textAlign = 'center';
    ctx.font = `bold ${14*CFG.SCALE}px system-ui`;
    ctx.fillStyle = '#ffeb3b';
    ctx.fillText(heliLine1, heliX, heliBoxY + 18*CFG.SCALE);

    ctx.font = `${11*CFG.SCALE}px system-ui`;
    ctx.fillStyle = '#fff';
    ctx.fillText(heliLine2, heliX, heliBoxY + 36*CFG.SCALE);

    // "E interakt" og "Køb powerups..." over shoppen
    const shopX = GL.shop.x;
    const shopY = GL.shop.y - 280*CFG.SCALE;

    // Baggrundsboks til shop-tekst
    ctx.font = `bold ${14*CFG.SCALE}px system-ui`;
    const line1 = 'E interakt';
    const line2a = 'Køb powerups i butik';
    const line2b = '(du får måske brug for senere)';
    ctx.font = `${11*CFG.SCALE}px system-ui`;
    const tw2a = ctx.measureText(line2a).width;
    const tw2b = ctx.measureText(line2b).width;
    const boxW = Math.max(tw2a, tw2b) + 16*CFG.SCALE;
    const boxH = 62*CFG.SCALE;
    const boxX = shopX - boxW/2;
    const boxY = shopY - 10*CFG.SCALE;

    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    roundRect(boxX, boxY, boxW, boxH, 8*CFG.SCALE);
    ctx.fill();

    // Tekst linje 1: "E interakt"
    ctx.font = `bold ${14*CFG.SCALE}px system-ui`;
    ctx.fillStyle = '#ffeb3b';
    ctx.fillText(line1, shopX, boxY + 18*CFG.SCALE);

    // Tekst linje 2: "Køb powerups..." (to linjer)
    ctx.font = `${11*CFG.SCALE}px system-ui`;
    ctx.fillStyle = '#fff';
    ctx.fillText(line2a, shopX, boxY + 34*CFG.SCALE);
    ctx.fillText(line2b, shopX, boxY + 48*CFG.SCALE);

    ctx.textAlign = 'left';
    ctx.restore();
  }

  // ╔════════════════════════════════════════════════════════════════════════════╗
  // ║                         18. GAME LOOP & MAIN RENDER                        ║
  // ║  Main step function, scene rendering, error handling                       ║
  // ╚════════════════════════════════════════════════════════════════════════════╝

  // ---------- Error Handling Utilities ----------
  function safeExecute(fn, errorMsg, fallback = null) {
    try {
      return fn();
    } catch(err) {
      if (CFG.DEBUG) {
        console.error(`${errorMsg}:`, err);
      }
      return fallback;
    }
  }
  
  function safeDraw(fn, context = 'render') {
    try {
      fn();
    } catch(err) {
      if (CFG.DEBUG) {
        console.error(`Drawing error in ${context}:`, err);
      }
      // Drawing errors shouldn't crash the game
    }
  }

  // ---------- Loop ----------
  function step(t){
    try {
      const renderStart = performance.now();
      
      // Performance monitoring
      PERF.frameCount++;
      if (t - PERF.lastFpsUpdate > 1000) { // Update FPS every second
        PERF.fps = Math.round(PERF.frameCount * 1000 / (t - PERF.lastFpsUpdate));
        PERF.frameCount = 0;
        PERF.lastFpsUpdate = t;
      }
      
      deltaTime = Math.min(MAX_DELTA, t - last);
      const dt = Math.min(0.033, deltaTime/1000); 
      last = t;
    
    // Handle intro screen animation
    if (scene === 'intro') {
      const introCanvas = document.getElementById('intro-canvas');
      if (introCanvas && (t - introStartTime) > (GAME_CONSTANTS.ANIMATION && GAME_CONSTANTS.ANIMATION.INTRO_UPDATE_MS || 100)) { // Update frequency
        const ictx = introCanvas.getContext('2d');
        ictx.imageSmoothingEnabled = false; // Ensure pixel art style
        drawIntroGraphics(ictx, introCanvas.width, introCanvas.height);
        introStartTime = t;
      }
      requestAnimationFrame(step);
      return;
    }
    // No global countdown timer


    if (scene === 'golf') {
      golfUpdate(dt);
    }

    // bevægelse (ingen i choice-overlay). Stopper ved auto-walk tween
    // Also block manual movement during Oval Office Presidential Decisions auto-walk
    const ovalAutoWalking = scene === 'oval' && OV.decisions.active && OV.decisions.phase === 'walking';
    if (scene !== 'golf' && !choiceOverlay && !infoCard && !flagOverlay && !walkTween && !introRunning && !tug && !ovalAutoWalking) {
      let dx=0, dy=0;
      if (keys.has('arrowleft')) dx-=1;
      if (keys.has('arrowright')) dx+=1;
      if (keys.has('arrowup')) dy-=1;
      if (keys.has('arrowdown')) dy+=1;
      const len=Math.hypot(dx,dy)||1;
      // Swim damping when head is under water in Greenland
      let submerged = false;
      if (scene==='greenland' && glacierExplosion && glacierExplosion.active && glacierExplosion.waterLevel>0){
        const waterLine = H - glacierExplosion.waterLevel;
        const headY = player.y - 38*CFG.SCALE;
        submerged = headY > waterLine;
      }
      const spd = CFG.SPEED * (player.speedMul||1) * (submerged ? 0.85 : 1);
      const oldX = player.x;
      player.x += (dx/len)*spd*dt*CFG.SCALE;
      player.y += (dy/len)*spd*dt*CFG.SCALE;
      if (dx) player.facing=Math.sign(dx);
      
      // Walking animation logic
      const isMoving = Math.abs(player.x - oldX) > 0.1 || Math.abs(dx) > 0 || Math.abs(dy) > 0;
      if (isMoving) {
        player.walking = true;
        player.walkCycle += dt * 8; // Walking speed (higher = faster steps)
      } else {
        player.walking = false;
        player.walkCycle = 0; // Reset to neutral pose when stopped
      }
      // bounds
      const g = H-world.floor; const minX=40*CFG.SCALE,maxX=W-40*CFG.SCALE;
      player.x=clamp(player.x,minX,maxX); player.y=g;
    }

    // opdater auto-walk tween
    stepWalkTween(t);

    // speed boost timeout + HUD refresh
    if (speedBoostUntil && nowMs() > speedBoostUntil){ speedBoostUntil=0; player.baseSpeedMul = 1; updatePlayerSpeedMul(); }
    renderHUD();

    // opdater hop (jump) tween
    const ground = H - world.floor;
    if (jumpTween){
      const k = Math.min(1, (t - jumpTween.start)/jumpTween.dur);
      const lift = Math.sin(k*Math.PI) * jumpTween.height;
      player.y = ground - lift;
      if (k>=1){ jumpTween=null; if (!entryHeli.active) player.y = ground; }
    } else {
      if (!entryHeli.active) player.y = ground;
    }

    // update actors + fx
    updateActors(dt);
    updateFx(dt);
    
    // Update particle count for monitoring
    PERF.particleCount = fx.blood.length + fx.sparks.length + fx.downwash.length + fx.oil.length + fx.flame.length + fx.confetti.length;

    // ensure player is inside helicopter during entry before drawing
    if (entryHeli.active){
      const ktmp = Math.min(1, (nowMs() - entryHeli.start)/entryHeli.dur);
      if (entryHeli.vertical){
        entryHeli.y = entryHeli.startY + (entryHeli.targetY - entryHeli.startY) * ktmp;
      } else {
        entryHeli.x = -180*CFG.SCALE + (entryHeli.targetX - (-180*CFG.SCALE)) * ktmp;
      }
      player.x = entryHeli.x + 30*CFG.SCALE;
      // keep Trump inside vertically as well (sit in cabin)
      player.y = entryHeli.y + 18*CFG.SCALE;
    }

    // optional camera shake near heli touchdown
    let shakeApplied=false; ctx.save();
    if (entryHeli.active){ const kshake = Math.min(1, (nowMs()-entryHeli.start)/entryHeli.dur); if (kshake>0.8){ const p=(kshake-0.8)/0.2; const amp = 2*CFG.SCALE*p; ctx.translate((Math.random()-0.5)*amp, (Math.random()-0.5)*amp); shakeApplied=true; } }

    // tegning
    if (scene==='greenland'){
      // Background: try custom image first, else fallback gradient + clouds
      const bgDrawn = GRAPHICS.drawBackground(ctx, 'greenland_bg');
      if (!bgDrawn){
        ctx.fillStyle=skyGrad; ctx.fillRect(0,0,W,H);
        CLOUDS.forEach(c=>{ ctx.globalAlpha=c.a; ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.ellipse(c.x, c.y, c.w/2, c.h/2, 0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; });
        ctx.fillStyle='#ebf8ff';
      }
      
      // Interactive glaciers
      GL.glaciers.forEach(glacier => {
        if (!glacier.blown) {
          drawGlacier(glacier.x, glacier.y, glacier.w, glacier.h, glacier.blown);
        }
      });
      const ground=H-world.floor; ctx.fillStyle='#e7fbff'; ctx.fillRect(0,ground,W,world.floor);
      ctx.fillStyle='#cfeef9'; for(let i=0;i<6;i++){ const y=ground+20+i*18*CFG.SCALE; ctx.fillRect(0,y,W,4); }

      // objekter
      drawMine(GL.mine.x, GL.mine.y);
      // Draw US flag at mine if planted
      if (GL.state.mineFlagPlanted) {
        drawMineFlagUS(GL.mine.x + 45*CFG.SCALE, GL.mine.y - 40*CFG.SCALE);
      }
      drawRig(GL.rig.x, GL.rig.y);
      drawShopStall(GL.shop);
      if (GL.flag) drawFlag(GL.flag.x, GL.flag.y);
      // Tegn faldende flag animation
      if (flagDrop && !flagDrop.landed){
        drawFlag(flagDrop.x, flagDrop.y);
      }
      drawBear(GL.bear.x, GL.bear.y, GL.bear.alive);
      // Tegn Mette (med rotation hvis sprunget i luften)
      if (!GL.mette.blownUp || (GL.mette.y < H + 100*CFG.SCALE)){
        drawMette(GL.mette.x, GL.mette.y, GL.mette.blownUp ? GL.mette.rotation : 0);
      }
      // during entry, draw only Trump here (heli is drawn in overlay)
      if (entryHeli.active){
        drawTrump(player.x, player.y, player.facing);
      } else {
        drawHeli(GL.heli.x, GL.heli.y, 0.35);
        drawTrump(player.x, player.y, player.facing);
      }
      GL.items.forEach(it=>{ if(!it.collected) drawPickup(it); });
      // Draw coins
      GL.coins.forEach(coin => { if(!coin.collected) drawGoldBar(coin); });
      // blood/sparks/downwash fx
      drawFx();

      // Navigation hints for new players
      drawGreenlandNavHints();

      // Rising water level overlay (drawn on top of everything)
      if (glacierExplosion.active && glacierExplosion.waterLevel > 0) {
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = '#4a90e2'; // Ocean blue
        ctx.fillRect(0, H - glacierExplosion.waterLevel, W, glacierExplosion.waterLevel);
        
        // Water surface waves
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#ffffff';
        const waveY = H - glacierExplosion.waterLevel;
        for (let x = 0; x < W; x += 40) {
          const waveHeight = Math.sin((nowMs() * 0.005) + (x * 0.02)) * 3;
          ctx.fillRect(x, waveY + waveHeight - 2, 30, 4);
        }
        ctx.restore();
      }

      // bobler
      const n=nowMs();
      const placed=[];
      renderPlayerBubble(n, placed);
      renderNpcBubble(GL.mette, n, placed, 'mette');
      renderNpcBubble(GL.bear, n, placed, 'bear');

      // interaktionshint
      const near=nearestGL();
      // hover pulse: prefer cursor target if active
      if (CFG.SHOW_PULSE && mouse.active){
        const objs=[GL.mine, GL.bear, GL.mette, GL.rig, GL.heli, ...GL.items.filter(it=>!it.collected)];
        const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
        if (obj && dist < 110*CFG.SCALE) drawPulseFor(obj);
      } else if (CFG.SHOW_PULSE && near){ drawPulseFor(near); }
      // airborne pickup collection: collide with player's head while jumping
      const gnd = H - world.floor;
      if (player.y < gnd - 4*CFG.SCALE){
        const headX = player.x, headY = player.y - 38*CFG.SCALE;
        GL.items.forEach(it=>{
          if (it.collected) return;
          const cx = it.x, cy = it.y - 18*CFG.SCALE;
          const d = Math.hypot(headX - cx, headY - cy);
          if (d < 26*CFG.SCALE){ it.collected=true; addToInventory(it.id, it.name); spawnSparks(cx, cy, 10); }
        });
      }

      // Plant hint when dynamite selected
      drawPlantHintGreenland();
    }
    
    // Global gold bar collection logic for all scenes (when jumping)
    if (scene!=='golf'){
      const gnd = H - world.floor;
      if (player.y < gnd - 4*CFG.SCALE){
        const headX = player.x, headY = player.y - 38*CFG.SCALE;
        const currentCoins = scene==='greenland' ? GL.coins : scene==='oval' ? OV.coins : KR.coins;
        currentCoins.forEach(coin=>{
          if (coin.collected) return;
          const cx = coin.x, cy = coin.y - 20*CFG.SCALE;
          const d = Math.hypot(headX - cx, headY - cy);
          if (d < 20*CFG.SCALE){ 
            coin.collected=true; 
            collectedCoins++; 
            player.goldBalance = (player.goldBalance || 0) + 1;
            spawnSparks(cx, cy, 15);
            checkCoinRewards();
            renderHUD(); // Update HUD to show new coin count
          }
        });
      }
    }
    
    if (scene==='golf') {
      golfDraw();
    } else if (scene==='oval') {
      drawOvalBackdrop();
      drawDoor(OV.door.x, OV.door.y);
      // aide removed from behind the desk for this layout
      drawYesGroup(OV.yes.x, OV.yes.y);
      // draw Trump first so desk can overlay (he stands behind desk)
      if (entryHeli.active){ drawTrump(player.x, player.y, player.facing); }
      else { drawHeli(OV.heli.x, OV.heli.y, 0.35); drawTrump(player.x, player.y, player.facing); }
      // Draw coins first (background layer)
      OV.coins.forEach(coin => { if(!coin.collected) drawGoldBar(coin); });
      // Draw guest behind desk (desk will cover legs/lower body)
      if (OV.guest.visible) {
        drawOvalGuest(OV.guest.x, OV.guest.y);
      }
      // then desk on top, with buttons
      drawOvalDesk();
      drawFx();

      const n=nowMs();
      const placed=[];
      renderPlayerBubble(n, placed);
      renderNpcBubble(OV.aide, n, placed, 'aide');
      // Guest speech bubble
      if (OV.guest.visible && OV.guest.speakingUntil > n) {
        const guestCenterX = OV.guest.x;
        const guestBaseY = OV.guest.y - 70*CFG.SCALE;
        const yOff = placeBubble(OV.guest.say, guestCenterX, guestBaseY, false, placed) - 8*CFG.SCALE;
        textBubble(OV.guest.say, guestCenterX, guestBaseY, false, 'default', yOff);
      }
      if (OV.yes.speakingUntil>n){
        const centerX = OV.yes.x; const baseY = OV.yes.y - 46*CFG.SCALE;
        const yOff = placeBubble(OV.yes.say, centerX, baseY, false, placed) - 8*CFG.SCALE;
        textBubble(OV.yes.say, centerX, baseY, false, 'default', yOff);
      }

      const near=nearestOV();
      if (CFG.SHOW_PULSE && mouse.active){
        const objs=[OV.door, OV.phone, OV.aide];
        const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
        if (obj && dist < 110*CFG.SCALE) drawPulseFor(obj);
      } else if (CFG.SHOW_PULSE && near){ drawPulseFor(near); }
    } else if (scene==='kremlin') {
      drawKremlinBackdrop();
      drawDoor(KR.door.x, KR.door.y);
      drawSecurityCamera(); // Draw camera body first (but not laser - comes later)
      
      // Depth sorting: collect all drawable objects with y-positions
      const drawables = [];
      
      // Add Putin
      drawables.push({y: KR.putin.y, draw: () => drawPutin(KR.putin.x, KR.putin.y)});
      
      // Add Trump with artificially low y-value to force him behind everything
      if (entryHeli.active) {
        drawables.push({y: 0, draw: () => drawTrump(player.x, player.y, player.facing)});
      } else {
        drawables.push({y: KR.heli.y, draw: () => drawHeli(KR.heli.x, KR.heli.y, 0.35)});
        drawables.push({y: 0, draw: () => drawTrump(player.x, player.y, player.facing)});
      }
      
      // Add statues
      KR.statues.forEach(s => {
        if (!s.collected) {
          drawables.push({y: s.y, draw: () => drawGoldStatue(s.x, s.y, s.variant)});
        }
      });
      
      // Add desk top edge (high y-value to render in front)
      const deskY = H - world.floor + 24*CFG.SCALE;
      const deskX = 300*CFG.SCALE, deskW = (W - 2*300*CFG.SCALE);
      drawables.push({y: deskY, draw: () => {
        const lipHeight = 16*CFG.SCALE;
        const lipTop = deskY - 36*CFG.SCALE;
        ctx.fillStyle = '#1c1c1c';
        ctx.fillRect(deskX-6, lipTop, deskW+12, lipHeight);
        // subtle highlight along edge
        ctx.fillStyle = '#272727';
        ctx.fillRect(deskX-6, lipTop, deskW+12, 3*CFG.SCALE);
        ctx.fillStyle = '#0d0d0d';
        ctx.fillRect(deskX-6, lipTop + lipHeight - 2*CFG.SCALE, deskW+12, 2*CFG.SCALE);
      }});
      
      // Sort by y-position (top to bottom) and draw
      drawables.sort((a, b) => a.y - b.y);
      drawables.forEach(drawable => drawable.draw());
      if (player.selectedItem==='dynamite') drawPlantHintGeneric();
      
      // Draw laser cones AFTER everything else so they're always on top
      const camerasToDrawLaser = (KR.cameras && KR.cameras.length > 0) ? KR.cameras : [KR.camera];
      camerasToDrawLaser.forEach(cam => {
        const lensX = cam.x;
        const lensY = cam.y - 18*CFG.SCALE;
        drawLaserCone(lensX, lensY, cam.angle);
      });

      // Update and draw Wagner soldiers if chase is active
      updateWagnerChase();
      drawWagnerSoldiers();

      // Draw coins
      KR.coins.forEach(coin => { if(!coin.collected) drawGoldBar(coin); });
      
      drawFx();

      const n=nowMs();
      const placed=[];
      renderPlayerBubble(n, placed);
      renderNpcBubble(KR.putin, n, placed, 'default');

      // Thought bubble when near statues (not speaking)
      const nearStatue = KR.statues.find(s => !s.collected && dist(player, s) < 80*CFG.SCALE);
      if (nearStatue && player.speakingUntil < n) {
        const thoughts = [
          'These would look great in my office...',
          'Very classy gold. The best gold.',
          'Putin won\'t miss just one...',
          'I could fit three of these in Mar-a-Lago!'
        ];
        // Use statue variant to pick consistent thought
        const thought = thoughts[nearStatue.variant % thoughts.length];
        const bubbleX = player.x;
        const bubbleY = player.y - 70*CFG.SCALE;
        // Draw thought bubble (cloud style)
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.font = `${9*CFG.SCALE}px system-ui`;
        const textWidth = ctx.measureText(thought).width + 16*CFG.SCALE;
        // Main bubble
        ctx.beginPath();
        ctx.roundRect(bubbleX - textWidth/2, bubbleY - 12*CFG.SCALE, textWidth, 20*CFG.SCALE, 8*CFG.SCALE);
        ctx.fill();
        ctx.stroke();
        // Thought dots
        ctx.beginPath();
        ctx.arc(bubbleX - 10*CFG.SCALE, bubbleY + 12*CFG.SCALE, 4*CFG.SCALE, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
        ctx.beginPath();
        ctx.arc(bubbleX - 5*CFG.SCALE, bubbleY + 18*CFG.SCALE, 3*CFG.SCALE, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
        // Text
        ctx.fillStyle = '#333';
        ctx.textAlign = 'center';
        ctx.fillText(thought, bubbleX, bubbleY + 2*CFG.SCALE);
        ctx.restore();
      }

      const near=nearestKR();
      if (CFG.SHOW_PULSE && mouse.active){
        const objs=[KR.door, KR.putin];
        const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
        if (obj && dist < 110*CFG.SCALE) drawPulseFor(obj);
      } else if (CFG.SHOW_PULSE && near){ drawPulseFor(near); }

      // Security camera flash effect
      if (KR.camera.flashUntil && nowMs() < KR.camera.flashUntil) {
        ctx.save();
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }
    } else if (scene==='epstein') {
      drawEpsteinScene();
      if (player.selectedItem==='dynamite') drawPlantHintGeneric();
    }

    if (scene!=='epstein') setCanvasCursor('default');

    // restore after scene draw
    if (shakeApplied) { /* keep overlay unaffected */ } ctx.restore();

    // entry helicopter overlay
    if (entryHeli.active){
      const k = Math.min(1, (nowMs() - entryHeli.start)/entryHeli.dur);
      if (entryHeli.vertical){
        entryHeli.y = entryHeli.startY + (entryHeli.targetY - entryHeli.startY) * k;
      } else {
        entryHeli.x = -180*CFG.SCALE + (entryHeli.targetX - (-180*CFG.SCALE)) * k;
      }
      // keep player "inside" helicopter as it arrives
      player.x = entryHeli.x + 30*CFG.SCALE;
      player.y = entryHeli.y + 18*CFG.SCALE;
      if (scene === 'golf') {
        drawTrump(player.x, player.y, 1);
      }
      drawHeli(entryHeli.x, entryHeli.y, (scene === 'golf') ? GOLF_HELI_SCALE : 1.0);
      // rotor downwash while arriving
      if (k>0.6) spawnDownwash(entryHeli.x, entryHeli.y + 12*CFG.SCALE, scene);
      if (k>=1){
        entryHeli.active = false;
        introPlayed = true;
        if (scene === 'golf'){
          try { golfAfterHeliLanding(); } catch(_){ }
        } else {
          startWalkTo(player.x + 40*CFG.SCALE, 500, ()=>{ if (entryHeli.line) say(player, entryHeli.line, 1600); });
        }
      }
    }

    // missile overlay (in front of everything)
    if (NUKE.active){
      const k = Math.min(1, (nowMs() - NUKE.start)/NUKE.dur);
      NUKE.y = NUKE.startY + (NUKE.endY - NUKE.startY)*k;
      drawMissile(NUKE.x, NUKE.y);
      if (k>=1){ NUKE.active=false; gameOverCause('nuke', {delayMs: 900}); }
    }

    // tug-of-war (arm wrestling) overlay
    if (tug){
      const elapsed = nowMs() - tug.start; const k = Math.min(1, elapsed/tug.dur);
      const halfTime = tug.dur / 2;

      // opponent pull - harder in phase 2
      const pullStrength = elapsed < halfTime ? 0.18 : 0.25;
      tug.pos -= pullStrength * (1/60);
      tug.pos = Math.max(-1, Math.min(1, tug.pos));

      // Determine current phase and keys
      const phase = elapsed < halfTime ? 1 : 2;
      const keys = phase === 1 ? 'A + D' : 'F + K';

      // Dark overlay
      ctx.fillStyle='rgba(0,0,0,.7)';
      ctx.fillRect(0, 0, W, H);

      // Draw arm wrestling graphic
      drawArmWrestling(ctx, W/2, H/2 - 30*CFG.SCALE, tug.pos);

      // Title
      ctx.fillStyle='#fff';
      ctx.font = `bold ${20*CFG.SCALE}px system-ui`;
      ctx.textAlign='center';
      ctx.fillText('ARM WRESTLING!', W/2, H/2 - 100*CFG.SCALE);

      // Current keys to mash - big and flashy
      const keyFlash = Math.sin(nowMs()/100) > 0 ? '#f1c40f' : '#fff';
      ctx.fillStyle = keyFlash;
      ctx.font = `bold ${28*CFG.SCALE}px system-ui`;
      ctx.fillText(`MASH ${keys}!`, W/2, H/2 + 70*CFG.SCALE);

      // Phase indicator
      if (phase === 2) {
        ctx.fillStyle = '#e74c3c';
        ctx.font = `bold ${14*CFG.SCALE}px system-ui`;
        ctx.fillText('HARDER MODE!', W/2, H/2 + 90*CFG.SCALE);
      }

      // Progress bar
      const barW = 280*CFG.SCALE, barH=16*CFG.SCALE, cx=W/2, cy=H/2 + 110*CFG.SCALE;
      ctx.fillStyle = '#333';
      ctx.fillRect(cx-barW/2, cy, barW, barH);
      ctx.strokeStyle='#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(cx-barW/2, cy, barW, barH);

      // Trump side (green, right)
      ctx.fillStyle = '#27ae60';
      ctx.fillRect(cx, cy, (barW/2)*Math.max(0, tug.pos), barH);

      // Putin side (red, left)
      ctx.fillStyle = '#c0392b';
      ctx.fillRect(cx - (barW/2)*Math.max(0, -tug.pos), cy, (barW/2)*Math.max(0, -tug.pos), barH);

      // Center marker
      ctx.fillStyle = '#fff';
      ctx.fillRect(cx - 2, cy - 4, 4, barH + 8);

      // Labels
      ctx.font = `bold ${12*CFG.SCALE}px system-ui`;
      ctx.fillStyle = '#27ae60';
      ctx.fillText('TRUMP', cx + barW/2 - 30*CFG.SCALE, cy - 8*CFG.SCALE);
      ctx.fillStyle = '#c0392b';
      ctx.fillText('PUTIN', cx - barW/2 + 30*CFG.SCALE, cy - 8*CFG.SCALE);

      // Time remaining
      const timeLeft = Math.max(0, (tug.dur - elapsed) / 1000).toFixed(1);
      ctx.fillStyle = '#aaa';
      ctx.font = `${12*CFG.SCALE}px system-ui`;
      ctx.fillText(`Time: ${timeLeft}s`, W/2, H/2 + 135*CFG.SCALE);

      ctx.textAlign='left';
      if (elapsed >= tug.dur){
        const win = tug.pos > 0.5;
        
        // Dynamic Putin dialogue based on relationships
        const putinRel = RELATIONSHIPS.putin;
        let putinResponse, trumpResponse;
        
        if (win) {
          // Trump wins handshake
          if (putinRel.respect >= 70) {
            putinResponse = 'Impressive strength, my friend.';
            trumpResponse = 'Mutual respect achieved!';
          } else if (putinRel.respect >= 40) {
            putinResponse = 'Strong. I respect that.';
            trumpResponse = 'Dominated the handshake!';
          } else {
            putinResponse = 'Strong.';
            trumpResponse = 'Power move successful!';
          }
          adjustRelationship('putin', {respect: 8, fear: -3}, 'handshake_win');
          addSafe('kremlin', 'putin-handshake-win');
          awardMedal('kremlin');
        } else {
          // Putin wins handshake
          if (putinRel.trust <= 20) {
            putinResponse = 'Weakness. Disappointing.';
            trumpResponse = 'Strategic retreat...';
          } else if (putinRel.fear >= 60) {
            putinResponse = 'You seem... nervous, Donald.';
            trumpResponse = 'Recalibrating approach...';
          } else {
            putinResponse = 'Too soft.';
            trumpResponse = 'Next time…';
          }
          adjustRelationship('putin', {respect: -5, trust: -3, fear: 2}, 'handshake_loss');
        }
        
        KR.putin.speakingUntil = nowMs()+1600; 
        KR.putin.say = putinResponse;
        say(player, trumpResponse, 1000);
        tug = null;
        // plant flag based on who won
        if (win) { 
          plantFlag('american'); 
          KR.nobelPending = true; // award Nobel after player exits the map overlay
        } else { 
          plantFlag('russian'); 
        }
      }
    }

    // Nobel medal drop overlay (after returning from map)
    if (nobelDrop && nobelDrop.active){
      const chestX = player.x;
      const chestY = player.y - 24*CFG.SCALE; // approx medal center
      // physics
      // Even slower falling speed (about 1/8 of original)
      nobelDrop.vy += 300*dt*CFG.SCALE;
      nobelDrop.y += nobelDrop.vy*dt;
      // ribbon swing update (simple damped oscillation)
      nobelDrop.swingPhase += dt*4; // slower swing frequency to match slower fall
      nobelDrop.swingAmp *= 0.992; // damping
      const angle = Math.sin(nobelDrop.swingPhase) * nobelDrop.swingAmp; // radians
      if (nobelDrop.y >= chestY){
        nobelDrop.y = chestY;
        nobelDrop.active = false;
        GS.nobelAwarded = true;
        GS.achievements.nobelLaureate = true;
        spawnConfetti(chestX, chestY, 60);
        SFX.achievement();
        // Play voiceline 1s after landing
        setTimeout(() => { try { say(player, 'Thanks for the Nobel Prize — finally!', 2200); } catch(_){} }, 1000);
      }
      // draw falling medal
      ctx.save();
      ctx.fillStyle = '#d4af37';
      ctx.beginPath(); ctx.arc(chestX, nobelDrop.y, 6*CFG.SCALE, 0, Math.PI*2); ctx.fill();
      // ribbon dangling (rotated rectangle anchored above medal)
      ctx.translate(chestX, nobelDrop.y - 6*CFG.SCALE);
      ctx.rotate(angle);
      ctx.fillStyle = '#1e88e5';
      const rw = 4*CFG.SCALE, rh = 18*CFG.SCALE;
      ctx.fillRect(-rw/2, -rh, rw, rh);
      ctx.restore();
    }

    // border draw overlay
    if (borderDraw){
      const card = getBorderCardRect();
      // dim
      ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,W,H);
      // card background (image if available)
      if (MAP_IMG_READY){
        ctx.drawImage(MAP_IMG, card.x, card.y, card.w, card.h);
      } else {
        ctx.fillStyle='#f7f5ee'; ctx.fillRect(card.x, card.y, card.w, card.h);
      }
      ctx.strokeStyle='#c9a641'; ctx.lineWidth=4; ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
      // Enhanced world map with recognizable regions
      if (!MAP_IMG_READY){
        ctx.save(); ctx.translate(card.x, card.y);
        drawEnhancedWorldMap(ctx, card.w, card.h);
        ctx.restore();
      }

      // auto-generate border if putin mode and not generated
      if (borderDraw.mode==='putin' && !borderDraw.gen){
        const pts=[]; const steps=12; for (let i=0;i<=steps;i++){ const t=i/steps; const x=card.x + card.w*(0.35+0.45*t); const y=card.y + card.h*(0.40+0.05*Math.sin(t*Math.PI)); pts.push({x,y}); }
        borderDraw.points = pts; borderDraw.gen = true;
      }
      // draw user path with enhanced visual feedback
      if (borderDraw.points.length){
        // Main border line
        const borderColor = borderDraw.mode === 'trump' ? '#ff6b35' : '#d63031';
        ctx.strokeStyle = borderColor; 
        ctx.lineWidth = 5; 
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath(); 
        ctx.moveTo(borderDraw.points[0].x, borderDraw.points[0].y); 
        for (let i=1;i<borderDraw.points.length;i++){ 
          ctx.lineTo(borderDraw.points[i].x, borderDraw.points[i].y); 
        } 
        ctx.stroke();
        
        // Add glow effect
        ctx.strokeStyle = borderColor; 
        ctx.lineWidth = 8; 
        ctx.globalAlpha = 0.3;
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        // Mark start and end points
        if (borderDraw.points.length > 0) {
          const start = borderDraw.points[0];
          const end = borderDraw.points[borderDraw.points.length - 1];
          
          // Start marker (green)
          ctx.fillStyle = '#00b894';
          ctx.beginPath();
          ctx.arc(start.x, start.y, 6, 0, Math.PI * 2);
          ctx.fill();
          
          // End marker (red)
          if (borderDraw.points.length > 1) {
            ctx.fillStyle = '#e84393';
            ctx.beginPath();
            ctx.arc(end.x, end.y, 6, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Preview line to current mouse position (if drawing mode)
          if (borderDraw.mode === 'trump' && mouse.active && !isDrawing && drawingSettings.showPreview) {
            const card = getBorderCardRect();
            if (mouse.x>=card.x && mouse.x<=card.x+card.w && mouse.y>=card.y && mouse.y<=card.y+card.h) {
              ctx.strokeStyle = '#ff6b35';
              ctx.lineWidth = 2;
              ctx.globalAlpha = 0.5;
              ctx.setLineDash([8, 8]);
              ctx.beginPath();
              ctx.moveTo(end.x, end.y);
              ctx.lineTo(mouse.x, mouse.y);
              ctx.stroke();
              ctx.setLineDash([]);
              ctx.globalAlpha = 1;
            }
          }
        }
        
        // Drawing cursor and tools
        if (borderDraw.mode === 'trump' && mouse.active) {
          const card = getBorderCardRect();
          if (mouse.x>=card.x && mouse.x<=card.x+card.w && mouse.y>=card.y && mouse.y<=card.y+card.h) {
            // Crosshair cursor
            ctx.strokeStyle = isDrawing ? '#ff3333' : '#ff6b35';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.moveTo(mouse.x - 10, mouse.y);
            ctx.lineTo(mouse.x + 10, mouse.y);
            ctx.moveTo(mouse.x, mouse.y - 10);
            ctx.lineTo(mouse.x, mouse.y + 10);
            ctx.stroke();
            
            // Center dot
            ctx.fillStyle = isDrawing ? '#ff3333' : '#ff6b35';
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }
        }
      }
      // Enhanced instructions and live analysis
      ctx.fillStyle='#333'; ctx.font=`bold ${14*CFG.SCALE}px system-ui`; ctx.textAlign='center';
      
      // Enhanced Instructions
      let msg;
      if (borderDraw.mode==='trump') {
        if (borderDraw.points.length === 0) {
          msg = '🖊️ Click and drag to draw border · Hold mouse button and draw smoothly';
        } else {
          msg = `🖊️ Drawing (${borderDraw.points.length} points) · Enter: Confirm · Backspace: Undo · C: Clear · U: Smooth · Esc: Cancel`;
        }
      } else {
        msg = '🤖 Putin\'s Proposed Border';
      }
      
      ctx.fillText(msg, W/2, card.y + card.h + 28);
      
      // Live border analysis and drawing stats
      if (borderDraw.mode === 'trump') {
        ctx.font = `${12*CFG.SCALE}px system-ui`;
        ctx.fillStyle='rgba(0,0,0,.8)';
        const statBoxHeight = borderDraw.points.length > 3 ? 80 : 40;
        ctx.fillRect(card.x + 10, card.y + 10, 200, statBoxHeight);
        ctx.fillStyle='#fff';
        ctx.textAlign='left';
        
        // Drawing progress
        ctx.fillText(`🖊️ Points: ${borderDraw.points.length}`, card.x + 20, card.y + 28);
        
        if (isDrawing) {
          ctx.fillStyle='#ff3333';
          ctx.fillText(`✏️ Drawing...`, card.x + 120, card.y + 28);
        }
        
        // Border analysis (if enough points)
        if (borderDraw.points.length > 3) {
          const analysis = analyzeBorderLive(borderDraw.points, card);
          ctx.fillStyle='#fff';
          ctx.fillText(`📏 Length: ${analysis.lengthDesc}`, card.x + 20, card.y + 45);
          ctx.fillText(`🎯 Strategy: ${analysis.strategyDesc}`, card.x + 20, card.y + 62);
          ctx.fillText(`⚡ Aggression: ${analysis.aggressionDesc}`, card.x + 20, card.y + 79);
        }
      }
      ctx.textAlign='left';
      
      // Relationship display (top right corner)
      if (scene === 'greenland' || scene === 'kremlin') {
        ctx.font = `${11*CFG.SCALE}px system-ui`;
        ctx.fillStyle = 'rgba(0,0,0,.8)';
        ctx.fillRect(W - 200, 10, 190, 80);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';
        ctx.fillText('👥 RELATIONSHIPS', W - 195, 28);
        
        // Mette relationship
        if (scene === 'greenland') {
          const metteEmoji = getRelationshipEmoji('mette');
          const metteRel = RELATIONSHIPS.mette;
          ctx.fillText(`${metteEmoji} Løkke: R${metteRel.respect} T${metteRel.trust} F${metteRel.fear}`, W - 195, 48);
          
          // Relationship bar
          const barWidth = 60;
          const avg = (metteRel.respect + metteRel.trust - metteRel.fear) / 3;
          ctx.fillStyle = avg >= 50 ? '#4CAF50' : avg >= 25 ? '#FF9800' : '#F44336';
          ctx.fillRect(W - 120, 40, (avg/100) * barWidth, 8);
          ctx.strokeStyle = '#333';
          ctx.strokeRect(W - 120, 40, barWidth, 8);
        }
        
        // Putin relationship  
        if (scene === 'kremlin') {
          const putinEmoji = getRelationshipEmoji('putin');
          const putinRel = RELATIONSHIPS.putin;
          ctx.fillStyle = '#fff';
          ctx.fillText(`${putinEmoji} Putin: R${putinRel.respect} T${putinRel.trust} F${putinRel.fear}`, W - 195, 68);
          
          // Relationship bar
          const barWidth = 60;
          const avg = (putinRel.respect + putinRel.trust - putinRel.fear) / 3;
          ctx.fillStyle = avg >= 50 ? '#4CAF50' : avg >= 25 ? '#FF9800' : '#F44336';
          ctx.fillRect(W - 120, 60, (avg/100) * barWidth, 8);
          ctx.strokeStyle = '#333';
          ctx.strokeRect(W - 120, 60, barWidth, 8);
        }
      }
    }

    // choice overlay
    if (choiceOverlay){
      const layout = layoutChoiceOverlay();
      ctx.fillStyle='rgba(0,0,0,.82)'; ctx.fillRect(0,0,W,H);
      if (layout && choiceOverlay.header){
        ctx.fillStyle='#fff';
        ctx.font=`800 ${19*CFG.SCALE}px system-ui`;
        ctx.textAlign='center';
        ctx.textBaseline='bottom';
        ctx.fillText(choiceOverlay.header, W/2, layout.headerY);
      }
      if (layout && layout.boxes && layout.boxes.length){
        const highlightIndex = choiceOverlay.hoverIndex != null ? choiceOverlay.hoverIndex : choiceOverlay.selected;
        const padX = Math.max(18*CFG.SCALE, layout.boxW * 0.06);
        ctx.textAlign='left';
        ctx.textBaseline='middle';
        layout.boxes.forEach((box, i) => {
          const color = CHOICE_BOX_COLORS[i % CHOICE_BOX_COLORS.length];
          ctx.fillStyle = color;
          ctx.fillRect(box.x, box.y, box.w, box.h);
          if (i === highlightIndex){
            ctx.save();
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = '#fff';
            ctx.fillRect(box.x, box.y, box.w, box.h);
            ctx.restore();
          }
          const lineW = (i === highlightIndex ? 5 : 3) * CFG.SCALE;
          ctx.lineWidth = lineW;
          ctx.strokeStyle = '#fff';
          ctx.strokeRect(box.x + lineW/2, box.y + lineW/2, box.w - lineW, box.h - lineW);
          let fontSize = Math.min(28*CFG.SCALE, box.h * 0.55);
          const maxTextW = box.w - padX * 2;
          ctx.font = `800 ${fontSize}px system-ui`;
          while (ctx.measureText(box.label).width > maxTextW && fontSize > 12*CFG.SCALE){
            fontSize -= 1*CFG.SCALE;
            ctx.font = `800 ${fontSize}px system-ui`;
          }
          ctx.fillStyle = '#fff';
          ctx.fillText(box.label, box.x + padX, box.y + box.h/2);
        });
        ctx.textBaseline='alphabetic';
        ctx.textAlign='left';
      }
    }

    // info card overlay
    if (infoCard){
      drawInfoCard();
    }

    // flag overlay
    if (flagOverlay){
      drawFlagOverlay();
    }

    // HUD toast
    if (hudToast){ ctx.save(); ctx.globalAlpha=0.9; ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(W-260, 44, 240, 26); ctx.fillStyle='#fff'; ctx.font=`12px system-ui`; ctx.fillText(hudToast, W-248, 62); ctx.restore(); hudToast=null; }

    // game over overlay
      if (GS.over){ 
      // Continue overlay (after game over)
      if (GS.overMode === 'continue'){
        // Background
        ctx.fillStyle = '#efe8d2';
        ctx.fillRect(0,0,W,H);
        ctx.textAlign='center';
        
        // Title
        ctx.fillStyle='#141414';
        ctx.font=`800 ${28*CFG.SCALE}px system-ui`;
        ctx.fillText('Continue?', W/2, H*0.18);
        ctx.font=`${14*CFG.SCALE}px system-ui`;
        ctx.fillStyle='#2a2a2a';
        ctx.fillText('Make America Continue Again', W/2, H*0.18 + 22*CFG.SCALE);

        // Voting machine box on pedestal
        const boxW = Math.min(W*0.66, 580*CFG.SCALE);
        const boxH = Math.min(H*0.46, 280*CFG.SCALE);
        const bx = (W - boxW)/2, by = H*0.28;
        // Pedestal column
        const stemW = Math.max(18*CFG.SCALE, boxW*0.04);
        const stemH = 120*CFG.SCALE;
        const stemX = W/2 - stemW/2;
        const stemY = by + boxH + 6*CFG.SCALE;
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(stemX, stemY, stemW, stemH);
        // Base
        const baseW = boxW*0.5, baseH = 18*CFG.SCALE;
        const baseY = stemY + stemH;
        ctx.fillStyle = '#1b1b1b';
        ctx.fillRect(W/2 - baseW/2, baseY, baseW, baseH);
        // Feet
        ctx.fillStyle = '#111';
        ctx.fillRect(W/2 - baseW/2 - 24*CFG.SCALE, baseY + baseH - 6*CFG.SCALE, 24*CFG.SCALE, 6*CFG.SCALE);
        ctx.fillRect(W/2 + baseW/2, baseY + baseH - 6*CFG.SCALE, 24*CFG.SCALE, 6*CFG.SCALE);

        // Outer case
        ctx.fillStyle = '#222';
        ctx.fillRect(bx, by, boxW, boxH);
        // Inner bezel
        ctx.fillStyle = '#333';
        ctx.fillRect(bx+8*CFG.SCALE, by+8*CFG.SCALE, boxW-16*CFG.SCALE, boxH-16*CFG.SCALE);
        // Screen area
        const pad = 18*CFG.SCALE;
        const sx = bx + pad, sy = by + pad, sw = boxW - pad*2, sh = boxH - pad*2 - 56*CFG.SCALE;
        ctx.fillStyle = '#0b0d2b';
        ctx.fillRect(sx, sy, sw, sh);
        // Slot window for text
        const winH = 40*CFG.SCALE;
        const winY = sy + sh*0.36 - winH/2;
        ctx.fillStyle = '#111a39';
        ctx.fillRect(sx + sw*0.12, winY, sw*0.76, winH);
        ctx.strokeStyle = '#6ad3ff';
        ctx.lineWidth = 3;
        ctx.strokeRect(sx + sw*0.12, winY, sw*0.76, winH);

        // Update slot state
        if (continueOverlay){
          const nowt = nowMs();
          if (continueOverlay.phase === 'spinning'){
            // Advance steps with deceleration
            while(!continueOverlay.stopped && nowt >= continueOverlay.nextAt){
              continueOverlay.idx = (continueOverlay.idx + 1) % continueOverlay.words.length;
              continueOverlay.stepsLeft = Math.max(0, continueOverlay.stepsLeft - 1);
              continueOverlay.interval += continueOverlay.inc;
              continueOverlay.nextAt += continueOverlay.interval;
              if (continueOverlay.stepsLeft <= 1){
                // Land on TRUMP and stop
                const stopIdx = continueOverlay.words.indexOf(continueOverlay.stopAt);
                continueOverlay.idx = stopIdx >= 0 ? stopIdx : continueOverlay.idx;
                continueOverlay.stopped = true;
                continueOverlay.stopAtTime = nowt;
                continueOverlay.phase = 'done';
                if (!continueOverlay.grantDone){ GS.lives = (GS.lives|0) + 1; continueOverlay.grantDone = true; renderHUD(); }
              }
            }
          }
          const N = continueOverlay.words.length;
          const idx = continueOverlay.idx;
          const prev = continueOverlay.words[(idx-1+N)%N];
          const cur = continueOverlay.words[idx];
          const next = continueOverlay.words[(idx+1)%N];
          // Local progress 0..1 within current step (for slide effect)
          const lastStepAt = continueOverlay.nextAt - continueOverlay.interval;
          let p = 0;
          if (continueOverlay.phase === 'spinning'){
            p = Math.max(0, Math.min(1, (nowt - lastStepAt)/Math.max(1, continueOverlay.interval)));
          } else {
            p = 1; // settle (idle or done)
          }
          const lineH = 28*CFG.SCALE;
          const centerY = winY + winH/2;
          const offset = (1-p) * lineH; // slide upward
          ctx.save();
          // Clip to window
          ctx.beginPath(); ctx.rect(sx + sw*0.12, winY, sw*0.76, winH); ctx.clip();
          ctx.fillStyle='#a5c4ff';
          ctx.font = `bold ${20*CFG.SCALE}px system-ui`;
          ctx.fillText(prev, W/2, centerY - lineH + offset);
          ctx.fillStyle='#ffffff';
          ctx.fillText(cur,  W/2, centerY + offset);
          ctx.fillStyle='#a5c4ff';
          ctx.fillText(next, W/2, centerY + lineH + offset);
          ctx.restore();
          // +1 LIFE popup when done
          if (continueOverlay.phase === 'done'){
            ctx.fillStyle = '#2a2a2a';
            ctx.font = `bold ${16*CFG.SCALE}px system-ui`;
            ctx.fillText('+1 LIFE', W/2, sy + sh + 18*CFG.SCALE);
          }
        }

        // Confirm button row
        const btnY = by + boxH - 40*CFG.SCALE;
        // Left dim button (Democrat)
        const bw = 120*CFG.SCALE, bh = 26*CFG.SCALE;
        const gap = 18*CFG.SCALE;
        const bx1 = bx + boxW/2 - bw - gap/2, bx2 = bx + boxW/2 + gap/2;
        ctx.fillStyle = '#555'; ctx.fillRect(bx1, btnY, bw, bh);
        ctx.fillStyle = '#222'; ctx.font=`bold ${12*CFG.SCALE}px system-ui`; ctx.textAlign='center';
        ctx.fillText('DEMOCRAT', bx1 + bw/2, btnY + 17*CFG.SCALE);
        // Right bright TRUMP button
        ctx.fillStyle = '#e6a300'; ctx.fillRect(bx2, btnY, bw, bh);
        ctx.fillStyle = '#211a00'; ctx.fillText('TRUMP', bx2 + bw/2, btnY + 17*CFG.SCALE);

        // Prompt
        ctx.textAlign='center';
        ctx.fillStyle='#1f1f1f'; ctx.font=`${14*CFG.SCALE}px system-ui`;
        const prompt = (continueOverlay && continueOverlay.phase !== 'done') ? 'Press Enter or T to vote' : 'Press Enter or T to continue';
        ctx.fillText(prompt, W/2, by + boxH + 36*CFG.SCALE);
        ctx.textAlign='left';
      } else if (GS.overMode === 'epstein_success'){
        // Custom Epstein success card overlay (like Kremlin map card)
        const card = getBorderCardRect();
        // Dim background outside card area only
        ctx.fillStyle='rgba(0,0,0,.6)';
        ctx.fillRect(0,0,W,H);
        // Clear card area
        ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
        // Card background + frame borders
        ctx.fillStyle='#f7f5ee';
        ctx.fillRect(card.x, card.y, card.w, card.h);
        ctx.strokeStyle='#c9a641'; ctx.lineWidth=6; ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
        ctx.strokeStyle='#8b7355'; ctx.lineWidth=2; ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);

        // Inner content: title, plane, characters, prompt
        ctx.textAlign='center';
        ctx.fillStyle='#111';
        ctx.font = `bold ${20*CFG.SCALE}px system-ui`;
        ctx.fillText('Selvfølgelig er jeg ikke nævnt — never met the guy', card.x + card.w/2, card.y + 36*CFG.SCALE);

        // Plane centered in upper/middle area
        drawVirginPlane(card.x + card.w/2, card.y + card.h/2 - 20*CFG.SCALE, 1.0);
        // Characters near bottom center inside card
        const baseY = card.y + card.h - 40*CFG.SCALE;
        drawEpsteinSunglasses(card.x + card.w/2 - 20*CFG.SCALE, baseY);
        drawTrumpSmile(card.x + card.w/2 + 20*CFG.SCALE, baseY);

        // Prompt inside card bottom
        ctx.fillStyle='#333';
        ctx.font = `${14*CFG.SCALE}px system-ui`;
        ctx.fillText('Press Enter to continue', card.x + card.w/2, card.y + card.h - 12*CFG.SCALE);
        ctx.textAlign='left';
      } else if (GS.overMode === 'epstein_fail'){
        // Newspaper-style fail card
        const card = getBorderCardRect();
        ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,W,H);
        ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
        // Card
        ctx.fillStyle='#f7f5ee'; ctx.fillRect(card.x, card.y, card.w, card.h);
        ctx.strokeStyle='#c9a641'; ctx.lineWidth=6; ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
        ctx.strokeStyle='#8b7355'; ctx.lineWidth=2; ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);

        // Rotated newspaper content (clip to card so paper can bleed beyond edges)
        const cx = card.x + card.w/2, cy = card.y + card.h/2;
        ctx.save();
        ctx.save(); ctx.beginPath(); ctx.rect(card.x, card.y, card.w, card.h); ctx.clip();
        ctx.translate(cx, cy); ctx.rotate(10*Math.PI/180);
        // Paper wider inside card, and much taller so it extends beyond the bottom edge.
        const baseH = card.h*0.75; // original visible height to anchor top
        const paperW = card.w*0.9;
        const paperH = card.h*1.6; // extend downward
        const iyTop = -baseH/2; // keep top where it used to be
        const ix = -paperW/2, iy = iyTop;
        ctx.fillStyle = '#ffffff'; ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 2;
        ctx.fillRect(ix, iy, paperW, paperH);
        ctx.strokeRect(ix, iy, paperW, paperH);

        // Content margins inside paper
        const padX = 22*CFG.SCALE, padY = 18*CFG.SCALE;
        // masthead + date
        ctx.fillStyle='#111'; ctx.font=`bold ${18*CFG.SCALE}px system-ui`; ctx.textAlign='center';
        ctx.fillText('The Daily Tremendous', 0, iy + padY + 8*CFG.SCALE);
        ctx.font=`${10*CFG.SCALE}px system-ui`; ctx.fillStyle='#555';
        ctx.fillText('Today • Washington D.C.', 0, iy + padY + 22*CFG.SCALE);
        // headline
        ctx.fillStyle='#b71c1c'; ctx.font=`bold ${20*CFG.SCALE}px system-ui`;
        ctx.fillText('BREAKING: DONALD NAMED. MULTIPLE TIMES.', 0, iy + padY + 46*CFG.SCALE);
        // photo box
        const px = ix + padX, py = iy + padY + 64*CFG.SCALE, pw = paperW - padX*2, ph = 80*CFG.SCALE;
        ctx.fillStyle='#d9d9d9'; ctx.fillRect(px, py, pw, ph);
        ctx.strokeStyle='#aaa'; ctx.lineWidth=3; ctx.strokeRect(px, py, pw, ph);
        // black-and-white figures inside photo (side-by-side)
        drawTrumpBW(px + pw*0.35, py + ph);
        drawEpsteinBWSunglasses(px + pw*0.65, py + ph);
        // subhead: only Trump quote
        ctx.fillStyle='#333'; ctx.font=`italic ${12*CFG.SCALE}px system-ui`;
        ctx.fillText('\"Witch hunt. Very unfair newspaper.\"', 0, py + ph + 22*CFG.SCALE);
        // article lines
        ctx.fillStyle='#bbb'; let ly = py + ph + 36*CFG.SCALE;
        for (let i=0;i<7;i++){ const lw = pw - (i%2?30:0); ctx.fillRect(px, ly + i*10*CFG.SCALE, lw, 6*CFG.SCALE); }
        // prompt
        ctx.fillStyle='#333'; ctx.font=`${13*CFG.SCALE}px system-ui`;
        ctx.fillText('Press Enter to continue', 0, iy + paperH - 12*CFG.SCALE);
        ctx.restore();
        ctx.restore();
        ctx.textAlign='left';
      } else if (GS.overMode && String(GS.overMode).startsWith('go_')){
        // Generic Game Over with cause-specific art
        ctx.fillStyle='#efe8d2'; ctx.fillRect(0,0,W,H);
        ctx.textAlign='center';
        // Title and subtitle (allow overrides via GO or asset-pack options)
        const opt = (GRAPHICS && GRAPHICS.config) || {};
        const tKey = 'gameover_title_' + (GO.cause||'generic');
        const sKey = 'gameover_subtitle_' + (GO.cause||'generic');
        const title = GO.title || opt[tKey] || opt.gameover_title || 'Game Over';
        const subtitle = GO.subtitle || opt[sKey] || opt.gameover_subtitle || 'Bedre held næste gang';
        ctx.fillStyle='#141414';
        ctx.font=`800 ${28*CFG.SCALE}px system-ui`;
        ctx.fillText(title, W/2, H*0.18);
        ctx.font=`${16*CFG.SCALE}px system-ui`;
        ctx.fillStyle='#2a2a2a';
        ctx.fillText(subtitle, W/2, H*0.22 + 14*CFG.SCALE);

        // Art area
        const boxW = Math.min(W*0.7, 720*CFG.SCALE);
        const boxH = Math.min(H*0.55, 360*CFG.SCALE);
        const bx = (W - boxW)/2, by = H*0.28;
        // Try to draw custom art from asset pack: gameover_<cause>
        const artKey = 'gameover_' + (GO.cause||'generic');
        const cfg = GRAPHICS && GRAPHICS.config;
        const url = cfg && (cfg[artKey] || cfg.gameover_default || cfg.gameover);
        let drawn=false;
        if (url){
          const img = GRAPHICS.images.get(artKey);
          if (img && img.complete){
            // contain fit (use global gameover_fit if provided)
            const iw = img.naturalWidth||img.width||1, ih=img.naturalHeight||img.height||1;
            const fit = (cfg && (cfg.gameover_fit)) || 'contain';
            const s = fit==='cover' ? Math.max(boxW/iw, boxH/ih) : Math.min(boxW/iw, boxH/ih);
            const dw = iw*s, dh = ih*s; const dx = bx+(boxW-dw)/2, dy=by+(boxH-dh)/2;
            try { ctx.imageSmoothingEnabled=false; } catch(_){ }
            ctx.drawImage(img, dx, dy, dw, dh);
            drawn=true;
          } else { GRAPHICS.loadImage(artKey, url); }
        }
        if (!drawn){
          // Simple pixel fallback by cause
          ctx.save(); try{ctx.imageSmoothingEnabled=false;}catch(_){ }
          if (GO.cause==='ice'){
            ctx.fillStyle='#cfe9ff'; ctx.fillRect(bx,by,boxW,boxH); ctx.fillStyle='#80c0ff'; ctx.fillRect(bx, by+boxH*0.7, boxW, boxH*0.3);
          } else if (GO.cause==='nuke'){
            ctx.fillStyle='#000'; ctx.fillRect(bx,by,boxW,boxH); ctx.fillStyle='#0a0a2a'; ctx.fillRect(bx,by,boxW,boxH*0.6);
            ctx.fillStyle='#3cf'; ctx.beginPath(); ctx.arc(bx+boxW*0.6, by+boxH*0.45, boxH*0.18, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#ffb300'; ctx.beginPath(); ctx.arc(bx+boxW*0.6, by+boxH*0.45, boxH*0.12, 0, Math.PI*2); ctx.fill();
          } else if (GO.cause==='kremlin'){
            ctx.fillStyle='#1a1a1a'; ctx.fillRect(bx,by,boxW,boxH); ctx.fillStyle='rgba(255,0,0,0.25)'; ctx.fillRect(bx+boxW*0.1, by+boxH*0.1, boxW*0.8, boxH*0.8);
          } else if (GO.cause==='epstein'){
            ctx.fillStyle='#f7f5ee'; ctx.fillRect(bx,by,boxW,boxH); ctx.strokeStyle='#8b7355'; ctx.strokeRect(bx+8,by+8,boxW-16,boxH-16);
          } else {
            ctx.fillStyle='#ddd'; ctx.fillRect(bx,by,boxW,boxH);
          }
          ctx.restore();
        }

        // Continue prompt
        ctx.fillStyle='#1f1f1f'; ctx.font=`${14*CFG.SCALE}px system-ui`;
        ctx.fillText('Tryk for at fortsætte', W/2, by + boxH + 36*CFG.SCALE);
        ctx.textAlign='left';
      } else {
        ctx.fillStyle='rgba(0,0,0,.8)'; 
        ctx.fillRect(0,0,W,H); 
        ctx.fillStyle='#fff'; 
        ctx.textAlign='center'; 
        
        // Main ending text
        ctx.font=`bold ${24*CFG.SCALE}px system-ui`; 
        const lines = GS.overText.split('\n');
        lines.forEach((line, i) => {
          ctx.fillText(line, W/2, H/2 - 60*CFG.SCALE + i*28*CFG.SCALE);
        });
        
        // Show achievements earned
        const earnedAchievements = Object.entries(GS.achievements).filter(([key, earned]) => earned);
        if (earnedAchievements.length > 0) {
          ctx.font=`bold ${16*CFG.SCALE}px system-ui`;
          ctx.fillText('🏆 ACHIEVEMENTS UNLOCKED:', W/2, H/2 + 50*CFG.SCALE);
          
          ctx.font=`${12*CFG.SCALE}px system-ui`;
          const achievementNames = {
            perfectDiplomat: '🤝 Perfect Diplomat',
            collector: '🗃️ Master Collector',
            twitterAddict: '📱 Twitter Master',
            bearWhisperer: '🐻 Bear Whisperer',
            nobelLaureate: '🏅 Nobel Peace Prize'
          };
          
          earnedAchievements.forEach(([key], i) => {
            ctx.fillText(achievementNames[key], W/2, H/2 + 75*CFG.SCALE + i*18*CFG.SCALE);
          });
        }
        
        ctx.font=`${14*CFG.SCALE}px system-ui`; 
        const restartY = (Object.values(GS.achievements).filter(Boolean).length > 0) ? H/2 + 140*CFG.SCALE : H/2 + 80*CFG.SCALE;
        ctx.fillText('Tryk for at fortsætte', W/2, restartY); 
        ctx.textAlign='left'; 
      }
    }
    
    // Debug and performance info
    if (CFG.SHOW_FPS || CFG.DEBUG) {
      ctx.save();
      const panelH = CFG.DEBUG ? 120 : 40;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(10, 10, 200, panelH);
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.fillText(`FPS: ${PERF.fps}`, 15, 28);
      if (CFG.DEBUG) {
        ctx.fillText(`Particles: ${PERF.particleCount}`, 15, 45);
        ctx.fillText(`Delta: ${deltaTime.toFixed(1)}ms`, 15, 62);
        ctx.fillText(`Render: ${PERF.renderTime.toFixed(1)}ms`, 15, 79);
        // Debug: final art source, fit, and rect size
        try {
          const fit = (GRAPHICS && GRAPHICS.config && GRAPHICS.config.birthday_art_fit) || 'cover';
          const src = (GRAPHICS && GRAPHICS.config && GRAPHICS.config.birthday_art) ? 'PNG' : ((window.LOTTIE_ART && LOTTIE_ART.json) ? 'Lottie' : 'Vector');
          const r = (typeof EP!=='undefined' && EP && EP.finalArtRect) ? EP.finalArtRect : null;
          const sz = r ? `${Math.round(r.w)}x${Math.round(r.h)}` : 'n/a';
          ctx.fillText(`FinalArt: ${src} | fit=${fit} | box=${sz}`, 15, 96);
        } catch(_){}
      }
      ctx.restore();
    }
    
      // Record render time
      PERF.renderTime = performance.now() - renderStart;

      requestAnimationFrame(step);
    } catch(err) {
      console.error('Game loop error:', err);
      // Try to continue running after a short delay
      setTimeout(() => requestAnimationFrame(step), 100);
    }
  }
  
  // Start the game loop with error handling
  try {
    requestAnimationFrame(step);
  } catch(err) {
    console.error('Failed to start game loop:', err);
  }
})();
</script>

<script id="course-mar-a-lago" type="application/json">
{
  "name": "Mar-a-Lago Mini-Putt",
  "par": [3, 3, 3],
  "holes": [
    {
      "id": 1,
      "bounds": { "x": 0, "y": 0, "w": 960, "h": 540 },
      "overlay": "golf1 ny.png",
      "spawn": { "x": 236, "y": 368 },
      "teeRect": { "x": 161, "y": 312, "w": 76, "h": 85 },
      "cup": { "x": 713, "y": 131, "r": 24 },
      "rails": [
        { "x1": 785, "y1": 49, "x2": 628, "y2": 49 },
        { "x1": 628, "y1": 49, "x2": 629, "y2": 281 },
        { "x1": 629, "y1": 281, "x2": 166, "y2": 280 },
        { "x1": 166, "y1": 280, "x2": 163, "y2": 460 },
        { "x1": 163, "y1": 460, "x2": 785, "y2": 460 },
        { "x1": 785, "y1": 460, "x2": 785, "y2": 49 }
      ]
    },
    {
      "id": 2,
      "bounds": { "x": 0, "y": 0, "w": 960, "h": 540 },
      "overlay": "bane.png",
      "lottieInline": "course-mar-a-lago-2"
    },
    {
      "id": 3,
      "bounds": { "x": 0, "y": 0, "w": 960, "h": 540 },
      "overlay": "bane3.png",
      "lottieInline": "course-mar-a-lago-3",
      "railsFromOverlay": false
    }
  ]
}
</script>


<script id="course-mar-a-lago-2" type="application/json">
{"v":"5.7.0","ip":0,"op":575,"fr":25,"w":960,"h":540,"nm":"bane2","assets":[],"layers":[{"ind":1,"ty":4,"nm":"genstand","sr":1,"ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":180},"p":{"a":0,"k":[565,83.896,0]},"a":{"a":0,"k":[85,-162.104,0]},"s":{"a":0,"k":[100,149.187,100]},"sa":{"a":0,"k":0}},"shapes":[{"ty":"gr","nm":"Rectangle 1","it":[{"ty":"rc","nm":"Rectangle Path 1","d":1,"s":{"a":0,"k":[152,24.396]},"p":{"a":0,"k":[0,0]},"r":{"a":0,"k":0}},{"ty":"st","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100},"w":{"a":0,"k":0},"c":{"a":0,"k":[0,0,0]}},{"ty":"fl","nm":"Fill 1","c":{"a":0,"k":[0,0,0]},"o":{"a":0,"k":100},"r":1},{"ty":"tr","o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[85,-174.302]},"a":{"a":0,"k":[0,0]},"s":{"a":0,"k":[100,100]},"sa":{"a":0,"k":0}}]}],"hasMask":false,"ln":"27","ip":0,"op":575,"st":0},{"ind":2,"ty":4,"nm":"genstand","sr":1,"ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[565,184.896,0]},"a":{"a":0,"k":[85,-162.104,0]},"s":{"a":0,"k":[100,149.187,100]},"sa":{"a":0,"k":0}},"shapes":[{"ty":"gr","nm":"Rectangle 1","it":[{"ty":"rc","nm":"Rectangle Path 1","d":1,"s":{"a":0,"k":[152,24.396]},"p":{"a":0,"k":[0,0]},"r":{"a":0,"k":0}},{"ty":"st","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100},"w":{"a":0,"k":0},"c":{"a":0,"k":[0,0,0]}},{"ty":"fl","nm":"Fill 1","c":{"a":0,"k":[0,0,0]},"o":{"a":0,"k":100},"r":1},{"ty":"tr","o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[85,-174.302]},"a":{"a":0,"k":[0,0]},"s":{"a":0,"k":[100,100]},"sa":{"a":0,"k":0}}]}],"hasMask":false,"ln":"24","ip":0,"op":575,"st":0},{"ind":3,"ty":4,"nm":"tee","sr":1,"ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[163.438,290.771,0]},"a":{"a":0,"k":[-316.562,20.771,0]},"s":{"a":0,"k":[100,100]},"sa":{"a":0,"k":0}},"shapes":[{"ty":"gr","nm":"Rectangle 1","it":[{"ty":"rc","nm":"Rectangle Path 1","d":1,"s":{"a":0,"k":[72.875,45.543]},"p":{"a":0,"k":[0,0]},"r":{"a":0,"k":0}},{"ty":"st","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100},"w":{"a":0,"k":0},"c":{"a":0,"k":[0,0,0]}},{"ty":"fl","nm":"Fill 1","c":{"a":0,"k":[0.9024,0.4878,0.9528]},"o":{"a":0,"k":100},"r":1},{"ty":"tr","o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[-316.562,20.771]},"a":{"a":0,"k":[0,0]},"s":{"a":0,"k":[100,100]},"sa":{"a":0,"k":0}}]}],"hasMask":false,"ln":"20","ip":0,"op":575,"st":0},{"ind":4,"ty":4,"nm":"hul","sr":1,"ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[376,420,0]},"a":{"a":0,"k":[-104,150,0]},"s":{"a":0,"k":[100,100]},"sa":{"a":0,"k":0}},"shapes":[{"ty":"gr","nm":"Ellipse 1","it":[{"ty":"el","nm":"Ellipse Path 1","d":1,"p":{"a":0,"k":[0,0]},"s":{"a":0,"k":[36.875,36.875]}},{"ty":"st","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100},"w":{"a":0,"k":6},"c":{"a":0,"k":[0,0,0]}},{"ty":"fl","nm":"Fill 1","c":{"a":0,"k":[0.8486,0.9797,0.0341]},"o":{"a":0,"k":100},"r":1},{"ty":"tr","o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[-104,150]},"a":{"a":0,"k":[0,0]},"s":{"a":0,"k":[100,100]},"sa":{"a":0,"k":0}}]}],"hasMask":false,"ln":"19","ip":0,"op":575,"st":0},{"ind":5,"ty":4,"nm":"fairway","sr":1,"ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[495,280,0]},"a":{"a":0,"k":[15,10,0]},"s":{"a":0,"k":[100,100]},"sa":{"a":0,"k":0}},"shapes":[{"ty":"gr","nm":"Shape 1","it":[{"ty":"sh","nm":"Path 1","d":1,"ks":{"k":{"i":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],"v":[[408,-187],[-378,-187],[-378,77],[-261,77],[-261,-83],[286,-83],[286,91],[-176,91],[-176,207],[408,207]],"c":true},"a":0}},{"ty":"st","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100},"w":{"a":0,"k":6},"c":{"a":0,"k":[0,0,0]}},{"ty":"fl","nm":"Fill 1","c":{"a":0,"k":[0.6042,0.9506,0.4252]},"o":{"a":0,"k":100},"r":1},{"ty":"tr","o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[0,0]},"a":{"a":0,"k":[0,0]},"s":{"a":0,"k":[100,100]},"sa":{"a":0,"k":0}}]}],"hasMask":false,"ln":"18","ip":0,"op":575,"st":0}]}
</script>

<script id="course-mar-a-lago-3" type="application/json">
{"nm":"bane3","ddd":0,"h":540,"w":960,"meta":{"g":"@lottiefiles/toolkit-js 0.67.2"},"layers":[{"ty":4,"nm":"tee","sr":1,"st":0,"op":575,"ip":0,"ln":"207","hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[-316.562,20.771,0]},"s":{"a":0,"k":[100,100]},"p":{"a":0,"k":[235.438,396.771,0]},"r":{"a":0,"k":0},"sa":{"a":0,"k":0},"o":{"a":0,"k":100}},"shapes":[{"ty":"gr","nm":"Rectangle 1","it":[{"ty":"rc","nm":"Rectangle Path 1","d":1,"p":{"a":0,"k":[0,0]},"r":{"a":0,"k":0},"s":{"a":0,"k":[72.875,45.543]}},{"ty":"st","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100},"w":{"a":0,"k":0},"c":{"a":0,"k":[0,0,0]}},{"ty":"fl","nm":"Fill 1","c":{"a":0,"k":[0.9024,0.4878,0.9528]},"r":1,"o":{"a":0,"k":100}},{"ty":"tr","a":{"a":0,"k":[0,0]},"s":{"a":0,"k":[100,100]},"p":{"a":0,"k":[-316.562,20.771]},"r":{"a":0,"k":0},"sa":{"a":0,"k":0},"o":{"a":0,"k":100}}]}],"ind":1},{"ty":4,"nm":"hul","sr":1,"st":0,"op":575,"ip":0,"ln":"206","hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[-104,150,0]},"s":{"a":0,"k":[100,100]},"p":{"a":0,"k":[748,216,0]},"r":{"a":0,"k":0},"sa":{"a":0,"k":0},"o":{"a":0,"k":100}},"shapes":[{"ty":"gr","nm":"Ellipse 1","it":[{"ty":"el","nm":"Ellipse Path 1","d":1,"p":{"a":0,"k":[0,0]},"s":{"a":0,"k":[36.875,36.875]}},{"ty":"st","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100},"w":{"a":0,"k":6},"c":{"a":0,"k":[0,0,0]}},{"ty":"fl","nm":"Fill 1","c":{"a":0,"k":[0.8486,0.9797,0.0341]},"r":1,"o":{"a":0,"k":100}},{"ty":"tr","a":{"a":0,"k":[0,0]},"s":{"a":0,"k":[100,100]},"p":{"a":0,"k":[-104,150]},"r":{"a":0,"k":0},"sa":{"a":0,"k":0},"o":{"a":0,"k":100}}]}],"ind":2},{"ty":4,"nm":"fairway","sr":1,"st":0,"op":575,"ip":0,"ln":"220","hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[0,0]},"s":{"a":0,"k":[100,100]},"p":{"a":0,"k":[480,270]},"r":{"a":0,"k":0},"sa":{"a":0,"k":0},"o":{"a":0,"k":100}},"shapes":[{"ty":"gr","nm":"Shape 1","it":[{"ty":"sh","nm":"Path 1","d":1,"ks":{"a":0,"k":{"c":true,"i":[[84.013,-1.355],[-100.18,0],[-114,0],[2.667,52],[0,0],[-48.138,1.66],[46,-1],[90,-1],[0,0],[0,0]],"o":[[-124,2],[-78,-4],[142,0],[0,0],[0,0],[58,-2],[39,-7],[-66.996,0.744],[0,0],[0,0]],"v":[[-269,-198],[-290,-37],[-265,173],[-150,2],[190,-2],[258,52],[338,-54],[254,-157],[194,-110],[-150,-104]]}}},{"ty":"st","nm":"Stroke 1","lc":1,"lj":1,"ml":4,"o":{"a":0,"k":100},"w":{"a":0,"k":5},"c":{"a":0,"k":[0,0,0]}},{"ty":"fl","nm":"Fill 1","c":{"a":0,"k":[0.6039,0.949,0.4235]},"r":1,"o":{"a":0,"k":100}},{"ty":"tr","a":{"a":0,"k":[0,0]},"s":{"a":0,"k":[100,100]},"p":{"a":0,"k":[0,0]},"r":{"a":0,"k":0},"sa":{"a":0,"k":0},"o":{"a":0,"k":100}}]}],"ind":3}],"v":"5.7.0","fr":25,"op":575,"ip":0,"assets":[]}
</script>
</body>
</html>
